HELP TEXTS FOR MonoMaths

*** View this introduction outside of a text editor mode which processes tags. It is meant to be viewed exactly as written. ***

This file must be saved as the file "Help.txt" in the same directory as the program itself.

Each section must begin with an identifier line, e.g.: '//CATS AND DOGS//' (to identify the section entitled 'Care of your cats and dogs'). Note the introductory and final '//', with nothing else on the line (blanks before and after the '//' are significant).

Sections can begin with multiple lines beginning with '//', or even have such lines in the middle somewhere. Such lines will be searched for as above (but to be detected must be in capitals), and any further such lines will simply be ignored.

Each section must end with a line starting with '=======' (initial blanks ignored; at least 4 '=' needed).

Formatting instructions may be inserted, using a markup language not unlike HTML. The rules are given at the end of the file.
Example: 'aaa <U>bbb</U>  ccc' underlines bbb.

The only restriction on the use of characters is not to use valid tags in text that you want displayed. If you write '<hello>' the display will literally show this; but if you write '<U>', this will not be shown, but will cause underlining of the ensuing text.

[ I insert </U> here, in case this file is itself being viewed in markup form, so that the above tag does not cause the rest of the file to be underlined.]

It is best practice to use '\<' and '\>' whenever you want to display literal '<' and '>'; if you don't, sometimes you will get repetition of segments of text overlaying each other, even though the actual '<' and '>' will be displayed correctly. (This is most likely to occur where you double them - e.g. you want to display ">>".)

___________________________________

//OVERVIEW//
<just c><B>OVERVIEW</B>

<just l>The design philosophy of this program has been to bridge the gap between a simple scientific calculator (with lots of functions but minimal programming capability) and a fully-fledged mathematics program. Sometimes one just wants to try out a relatively small program or create a quick set of graphs for some functions, without having to start up a major mathematics application. The syntax is straightforward and similar to that of other common languages, and also there is help quickly available (either from the help menu, or by keying F1 - or right-clicking - with the cursor at an instruction that you have just typed).

You can use <I>MonoMaths</I>...
<bullet>As a calculator. (E.g. to find the square root of 2, enter "sqrt(2)" and click "GO")
<bullet>To write a mathematical program. (Many built-in functions; and write your own.)
<bullet>To draw graphs - 2-dimensional and 3-dimensional.

<B>Windows</B>
There are two windows, the "Assignments Window" and the "Results Window". You enter program code into the Assignments Window, then click the "GO" button. Results of calculations will appear in the Results Window. For example, write "x = 2 + 2" in the top window, click "GO", and hopefully "x = 4" will appear in the bottom window. You can leave out the "x" and just write "2+2" - in which case the Results Window will show "#1 = 4" (that is, expression no. 1 evaluates to 4). You can enter a string of such assignments or expressions; their answers will be shown together in the Results Window. But the individual expressions or assignments must be separated by semicolons. (E.g. try this sequence: "2=2; sqrt(3);  x=1;  sin(x)".)

The button labelled "Clear" can be used at any stage to clear the Results Window (note - not the Assignments Window). This is not normally necessary, as each "GO" click normally removes previous results; but a menu option can make them cumulative. You can write in the Results Window, but it would not be all that helpful to do so.

<B>Click and drag</B>
You can move the form"s margins, and also the division between the two windows, by clicking and dragging. [<i>Currently dragging the division between windows does not work smoothly, so you will not see the result till you stop the drag; then the change will happen. In the case of the KDE desktop, dragging here is hijacked by the operating system for moving the whole window. If this is your problem, try using drag with the right mouse button instead of the left button.</i>]

<B>Help and Hints</B>
For all functions and syntax items, help is available from this menu. You can also get help for a particular item by typing its name into the Assignments Window, putting the cursor in or beside it and either pressing the F1 key or clicking the right button. A message box will be displayed giving a brief description. 

<B>Using the F1 key with Variable Names</B>
Once you have run your program, you can display final variable values in the same way, by highlighting the variable name and then pressing the F1 key or right-clicking. In the case of variables within functions, scalar values will be accessible but array values will not (unless the program had crashed while operating in the particular function); this is because arrays initialized inside functions are destroyed when the function has finished its work.

You can even use this while the program is still running. For example, your convoluted program has been grinding on for several minutes, and you are wondering where it is up to; so you might key F1 with the cursor at the main loop's counter. (If you want to watch progress within a function, use a holding method - see below. You can obtain details of how to do this by entering the function name 'pause' into the Assignments Window, highlighting it and pressing F1, as described above.)

<b>Break Points</B>
You can insert break points in your program to temporarily halt operation while you use F1 to check values as just mentioned. You can also invoke a halt programmatically. See the Help Section "Loops and Interrupts" (second half) for details.

<B>During Long Runs</B>
If you are running a program lasting for more than a few seconds (because of looping), you will find that you can still use some menus, though they will sometimes work sluggishly. Also you can interrupt operation either by clicking the GO key (now relabelled FREEZE). You will be offered a choice of putting the program on hold (while you examine variable values, for example), aborting the program, or continuing the program. If you have put it on hold, you can resume program operation by clicking the GO key (once). During the 'hold' stage menu items may still be sluggish (as a holding loop is occurring, and this program is single-threaded).

There is also an ABORT button, which will offer you no choice, but will simply bomb the program. (Have no fear to use it; all the internal housework of freeing resources and resetting internal parameters occurs in the same way whether the program ends naturally or is aborted.)

You can't close the form during your program run; if you click on the corner icon (or on menu item 'File | Exit') you will only stop program operation (as if you had clicked 'ABORT'). Once operation has stopped, you will then be able to close the form.

<b>Using Command Line Arguments</b>
MonoMaths can be run from the command line with arguments which may set the size and position of the MonoMaths instance and the height of the Assignments Window. Arguments can also cause MonoMaths to load a given file at startup, and even directly run that file (assuming it is a program) at startup. To find out details of the syntax for this, enter the word "command" (small letters)  into the Assignments Window and then click F1 with the cursor at the word.

=======================================================

//SYNTAX//
<just c><B>SYNTAX</B>

<just L>Enter assignments in the form "a = sin(1);  b = -1.3; c = a+b". Spaces and line breaks are not significant. Note the semicolon ";" between assignments. It can be used after every assignment (and stylistically perhaps should), but in fact is unnecessary before keywords like "if", "else"... and at the end of the code (as in the third assignment above). The one place where it is <I>essential</I> is between successive assignments, even if they are on different lines.

<B>Variable names</B>
Variables can be made up from any English letters, the numerals 0 to 9, and single underscores '_'. There are two restrictions: (1) the name must not begin with a numeral; and (2) underscores cannot be next to one another ("a_1" would work, but not "a__1"). NB: Names are case-sensitive - "A" and "a" are two different variables!
<# grey>Fine print:  There is a way you can incorporate special characters, for example Greek letters. See the heading "Program Directives" at the end of this display, if curious.<# black>

Although it would not  be encouraged, it is actually legal to put spaces inside names, provided that none of the internally spaced words is a system keyword like 'if'. At parse time, keywords are identified first (and replaced by codes), and then spaces are removed, so that variable names "My Var" and "M y V a r" would both have been converted to "MyVar" before the action gets under way.

<B>Variable types</B>
Variables are all represented internally by one basic numerical type, referred to in .NET as <I>Double</I> (64-bit double-precision IEC 60559 format). There is no integer type and no character type. 
Variables are divided into <I>scalars</I> (inherently single values) and <I>arrays</I>. Arrays in turn are of two types: <I>list arrays</I> and <I>structured arrays</I>. 
<I>List arrays</I> are simply collections of one or more values, kept together for the purpose of processing data in batches. For example, if Arr is a list array, 'sin(Arr)' will return another list array made up of the sines of all the elements of Arr.
<I>Structured arrays</I> have either 2 or 3 dimensions. In particular 2-dimensional arrays can represent matrices and also vectors (as 1xN or Nx1 matrices).
The two types are easily converted from one form to the other, and most system functions work equally well on both types.
See the <I>Arrays</I> help section for further details.

It is possible for values in scalars and list arrays to be <I>interpreted</I> as characters for the purposes of displaying a message. 

<B>Variable Declarations</B>
Two declaration statements are allowed, and are occasionally useful; they are by no means essential, as a variable is automatically registered when it is first assigned a value. The allowed statements are:
<# blue>array Arr1, Arr2, Arr3;<# black> -- where any number of names are allowed. (They are either completely new names, or else names of preexisting arrays, which this declaration will re-create.) The resulting arrays will be list arrays of length 1, with value 0.
<# blue>scalar Arr1, Arr2, Arr3;<# black> -- again, any number of names are allowed. (They are either completely new names, or else names of preexisting scalars, which this declaration will re-create.) The resulting scalars will be assigned the value 0.

<b>Constants</b>
Objects defined as constants are available at any time throughout the whole program, having global scope. (For more on 'scope', see "Help | User Functions", heading "Scope"). This is the good news. The bad news is that you cannot assign them new values during the program run (hence the name). There are two types:
<bullet>System constants:
<bullet 50,➯>Mathematical values: 'PI' (3.14159...), 'EE' (2.71828...).
<bullet 50,➯>Boolean equivalents: 'TRUE' or 'true' (1), 'FALSE' or 'false' (0).
<bullet 50,➯>Values based on MONO/NET storage limits: MAXREAL, MINREAL, MAXINT32, MININT32, MAXINT64, MININT64, POSINF, NEGINF, NaN (or NAN). They represent the maximum and minimum values in MONO and .NET realizations of types Double, Int32 and Int64; and values Double.PositiveInfinity, Double.NegativeInfinity and Double.NaN.
<bullet>User-generated constants: The use of these only has point where some mathematical constant is commonly needed throughout the whole program, including in different functions.  Such constants are defined in a single paragraph that precedes all the code of the program; see the heading "Program Directives" at the end of this display for details.

<B>Mathematical Symbols</B>
The usual mathematical symbols - '+', '-', '*', '/' - apply. Also, "^" is used for raising a number to a power: 2^3 , 2^-1, 2^1.34. (An error results if you use it for a fractional power of a negative number, as this program does not currently directly handle complex numbers.) Interpretations of these symbols when used with arrays or scalar-array mixes is dealt with in the Arrays section.

There is a <b>further symbol '#'</b> which is used to concatenate variables; its use is discussed in the Arrays section.

<b>Multiple assignments from an array</b>
Suppose "aa" is the array [10, 20, 30]. We have three scalars, x, y and z, which we want to set to aa[0], aa[1] and aa[2] respectively. We could of course write: <# blue>x = aa[0];  y = aa[1];  z = aa[2];<# black>. Or we could do as follows:
	<# blue><<x, y, z>> = aa;<# black>
There can be any number of variables between "<<" and ">>"; they can be arrays or scalars or unassigned variables. If unassigned, they will become scalars. If the amount of data on the RHS is insufficient, RHS data will only overwrite data contained in the LHS values until that data runs out; for the rest, prior values in the variables will be unchanged. (Unassigned variables that never received data will simply never come to exist.) If the amount of RHS data is excessive, only what is needed by the LHS variables will be used. Note that "<< ... >>" must be the start of an assignment; it cannot occur in the RHS, and it must be immediately followed by "=".

<U>Shorthand forms allowed: </U>  
<bullet><B>a++</B> and <B>a--</B> increment / decrement the value of the variable "a" by 1. Thus far is as in C-based languages in general. The next part, however, is different:
<bullet 30,>"x = 0;  y = x++;" will set both x and y to 1, whereas in C, C++, C# et al it would first set y to 0 (the old value of x), and only then set x to 1. These languages also have a prefixed version "y = ++a" which does indeed increment x before its value is assigned to y. MonoMaths has no prefixed version, and 'x++' will always increment x <i>before</i> assigning it to y.
<bullet><B>a += [ <I>expression</I> ]</B> - as also in C etc. - indicates "a = a + [ <I>expression</I> ]". Similar meanings apply to a  -=..., a *= ..., a /= ...,  a ^= ...  and  arr #= ... . NB: When the pre-parser detects e.g. "a *= b + c", it simply replaces it internally with the equivalent of "a = a * (b + c)". With this example, then, 'a' is multiplied by the <i>whole RHS</i>, and not just by 'b'.
<bullet><b>a = b = c = 10;</b>  - Any number of variables can be assigned together to the one value or expression. This example is rewritten internally as: "c = 10;  b = c;  a = b;".
<bullet><B>a = x ? 10 : 20;</B>   and <B>a = x ? 10 : 20 : 30;</B> -- examples of shorthand available for conditional statements - see section "Conditionals" for details.



<B>Remarks</B>
There are three ways of indicating remarks (i.e. text not to be regarded by <I>MonoMaths</I> as a functional part of your program). Two are common to C clones; the third is an extra freebie. Each type of remark has its own colour (which you can alter from the 'View' menu; if you desire, you can make your changes permanent by then clicking on menu item 'File | Save Settings').

(1) Single-paragraph headings: All from "__ " (two underscores followed by a space) to the end of a paragraph is ignored.
(2) Single-paragraph remarks: All from "//" to the end of a paragraph is ignored.
(3) Blocked remarks: All between "/*" and "*/" is ignored, whether one character or many paragraphs.
<# grey>Fine print:  A special version of (3) still blocks out text from being parsed as program, but does NOT change colouring: "/*\\\" and "\*/". It can be used where your program is allowing you to enter text into the Assignments Window, so you put the program under the user's text part. The user part is blocked off by these marks. At the end of this page is an example of this symbol's use.<# black>

The point in having both (1) and (2) is that (1) has the more striking colour, so you can distinguish headings from merely commentative text (2).

One further refinement: You can cause a particular paragraph of <i>program text</i> to be displayed as bold text by ending it with a remark sign "//" followed immediately by "!" (no space):
	<# blue>a = sin(b);  <# magenta>// Normal print 
	<# blue><b>a = sin(b);</b>  <# magenta>//! Bold print <# black>
You can even use this to insert an important blue announcement, using the fact that it is legal to enter a term in MonoMaths without assigning it to anything. (You still have to end with a semicolon.)
	<# blue><b>"  *** ALL TIMES ARE IN MILLISECONDS throughout the program ***    ";</b>  <# magenta>//!<# black>

<B>Quotes</B>
Three punctuation marks are able to delineate quotes; they are the usual two -  ["], ['] - and the occasionally needed extra symbol [`] (unicode 96; found on a key usually way to the side of the keyboard; typically symbol [¬] is invoked by the same key in shift mode). There is no difference whatever in the way that they operate, and no hierarchy between them. When the parser comes across one such symbol it looks for the next occurrence of that same symbol, and regards everything in between as a literal quotation, including any instances of the other two quotation symbols. (This quotation is then stored separately, where it is not subject to any further parsing). Hence, these are all valid statements:
	<# blue>ss = "The 'cat' sat on the mat.";    tt = 'The "cat" sat on the mat.';   uu = `The "cat" sat on the 'mat'.`;<# black>

<B>Amputating Code</B>
Sometimes when drastically rewriting a program it is helpful to remark out all code from a certain point down. This can be done by literally remarking it out, but an aid to save the trouble is to insert a line "CUT" - exactly that; no blanks, and all capitals. After clicking 'GO', all code will be ignored from that line to the end of the program, and a warning will show in the Results Window. Obviously code before the call to "CUT" should not call any functions defined after that point!
Sometimes you don't want that message to appear in the Results Window. As long as the very next line <i>begins</i> with at least 4 contiguous equal signs - "====" - the message will be suppressed. (For example your program might be a text processor, and you want the text to be processed to appear below the program component. The message is then unhelpful and unsightly.)


<b>PROGRAM DIRECTIVES</b>
There are two statements which, if they appear at the very start of the program, modify operation. They are - 
<bullet>The ALLOW statement, which allows you to use special characters within identifier names (i.e. within names of variables and of functions);
<bullet>The CONSTANT statement, which allows you to define program-wide constants. These behave just like the system constants mentioned above; in the same way, they can be called from within any function, but they can not be altered anywhere by assignments. (You cannot redefine an existing system constant using this statement.)

For these directives:
<bullet>The statement(s) must precede all program code (though empty lines and remarks-only lines may precede or follow).
<bullet>Each directive command must be in a separate line.
<bullet>The directive command must be at the start of the line (though leading spaces are allowed).
<bullet>If both directives are present, the line with the ALLOW directive must come first.

<b>The ALLOW Statement -- Allow special characters in identifiers</b>
If you want to use unicode characters beyond unicode 127 as part of identifier names in some program, you can warn MonoMaths of your intentions by setting the <b>first data line of the program</b> to the word "ALLOW ", followed by a space, then the special characters you have in mind, all in the one paragraph. (Any characters after "ALLOW " which are ≤ unicode 127 will be removed from the line, so you are free to use punctuation and spaces, even interspersed comments.) A selection of such characters is available via the main menu option "Edit | Special Characters".
<u>Caveat:</u> Different fonts and operating systems may interprete unicode characters differently. A character that looks like an 'alpha' on your system might look like the Chinese logogram for 'crushed beetle' on someone else's computer!
<i>A special keyword:</i>  If you include the word "GREEK" (must be in capitals) anywhere in the paragraph, then all Greek letters will be allowed, both capital and lower case. These letters can all be entered from the keyboard; see Menu item "Edit | Special Characters" for how to do this. 

<b>The CONSTANT Statement -- Define program constants</b>
More exact syntax is required. Follow the word "CONSTANT " and a space should come assignments separated by commas:
<# blue>CONSTANT PISQ = PI*PI,  FOO = 1.234,  BAR = sin(2*PISQ)<# black>
All the basic scalar mathematical functions can be used.

An example of how a program might use these directives:

	<# red>__ GREAT MATHS PROGRAM No. 1
	<# magenta>// This great maths program will do thus and so....
	<# blue>ALLOW  ρ,  π,  ²,  ε, √, ω
	<# blue>CONSTANT  π = PI,  π² = π*π,  √ε = sqrt(EE), ω = 1.23456 <# magenta>// You can add comments. A final ';' is optional.

	<# blue>ρ = 100;   Whatever = π² * ρ; <# magenta>// And no syntax error will be raised!<# black>
------------------------------
<# grey><b>Example of use of the symbols "/*\\\" and "\*/"</b>
You have some formatted text that you want to display in formatted mode as soon as the program starts; and you don't want the program itself to be visible. The following will achieve this; the only cost is that you can't avoid displaying the original "/*\\\" at the top of the screen.
A benefit: you can switch between formatting and nonformatting mode while the program is running, and save your editings (along with the program) while the program is running; so you can be writing your text as you go along.
	/*\\
	\<b>Foo\</b> was \<# blue>here\<# black> today.
	\<# white> -- This colour tag makes the program text (below) invisible while in formatted-text mode.
	\*/
	window('A', 'M', '+');  // This is the program - a single step! It puts the display into formatted-text mode.
<# black>

===========================================================allow
//ARRAYS//
<just c><B>ARRAYS</B>

<just l><U>OVERVIEW</U>
Arrays have only one representational structure in the inner workings of the program. However they can be divided into two different types, on the basis of the number of dimensions (out of a possible 5) assigned to them.

<B>List Arrays</B> are simply collections of values. (They are represented internally as having a single dimension). They may be coordinates for graphing, for example, or they may be values that need to be processed in batches. In general, mathematical operations work with batch processing in the same way as with scalars. For example, sin(x) will return a scalar if x is scalar, or a list array if x is an array (of any type), the list being the sine of all elements in the array.

<B>Structured Arrays</B> differ only in having either two or three dimensions. For example, a row vector of length 6 would be represented as a 1x6 structure (or matrix), and a column vector would be represented as a 6x1 structure. Currently no more than three dimensions are allowed. The great majority of mathematical operations and system functions work on list and structured arrays identically; they differ only in operations specific to linear algebra (dealing with vectors and matrices).

Arrays can be created or destroyed, but <B>an existing array cannot be made empty or 'null'. </B>If you try emptying an arrray (e.g. by using the 'delete' function, stating the entire range of the array as what is to be deleted), you will be returned an array of size 1, content NaN. To most easily detect this, call the function 'empty(Arr)' which returns TRUE if array 'Arr' is to be regarded as empty, FALSE otherwise. (It is theoretically possible to generate an array consisting just of NaN by other means, e.g. "arr = data(NaN);" . But this is not likely to cause ambiguity problems to the user in real situations.) (Re function 'empty(.)': its argument can be scalar or any type and length of array; the function will return 'true' if all values throughout the variable are only NaN.)

<U>CREATING ARRAYS</U>
Arrays obviously must be assigned before they can be accessed. This can be done -

<bullet>Using the declaration '<B>array</B>': "array Arr1, Arr2, ..., Arr9;" This creates as many arrays as are mentioned, all having size 1 and content 0. (You use this mainly for clarity, e.g. to name all important arrays at the start of your program, giving them realistic sizes and content later).
<bullet>Using the void function '<B>dim(.)</B>': "dim(Arr1, 6)" creates a list array of six elements; "dim(Arr2, 3, 5)" creates a structured array, a 3x5 matrix. All elements of an array so created will be zero. You can dimension several arrays at once to the same dimensions: "dim(Arr1, Arr2, Arr3, 4)".
<bullet>Using the void function '<B>dimlike(.)</B>': "dimlike(Arr1, Arr2, ..., Model)" creates arrays Arr1 etc. with the dimensions of the last array Model.
<bullet>Using the nonvoid function <b>structure(.)</b>:  Has the advantage that the dimensions may be provided in array form.  Both "Mx = structure(4, 3)" and "Mx = structure(arr)" (where arr is the array [4, 3]) are equivalent to "dim(Mx, 4, 3)".
<bullet>Using the <b>concatenation operator '#'</b>: It can be used between any number of scalars and/or arrays, and will always result in a list array which contains their concatenated data.  It handles the same way as other arithmetic operators. Its hierarchical level is above that of logic operators but below that of all arithmetic operators, so that all arithmetic operations are done first in an assignment (for example, "a # b + c" is equivalent to "a # (b + c)" ). An example:
			<# blue>Arr = 1 # data(2, 3, 4) # 4+1;  <# magenta>// 'Arr' will be a list array consisting of: [1, 2, 3, 4, 5].<# black>
<bullet 35,>It can be used with structured arrays; e.g. if "Mx" is a matrix, <# blue>Mx # 1<# black> will result in a list array made up of all the data in Mx, with an extra 1 appended to the end. (The structure of Mx is irrelevant to the operator, and is not preserved in its output.)
<bullet 35,>If the first array met with in a term is a chars. array, the output will be a chars. array. For example:
			<# blue>Txt = "My age is " # str(101);  <# magenta>// Txt will be the chars. array "My age is 101".<# black>
<bullet 35,>You can use the shorthand "Arr #= n" to stand for  "Arr = Arr # n", in the same way as you can for arithmetic operators.
<bullet>Using one of the functions which return an array, common examples of which are:
			<B>data(.)</B>:  "Arr = data(1.1, 2.2, 3.3, 4.4, 5.5)" creates a list array of five elements and assigns these values to it.
			<B>rowvec(.),  colvec(.)</B>: similarly creates a row vector / column vector.
			<B>matrix(norows, nocols [, ... ])</B>' similarly creates a matrix.
			<B>ladder(.)</B>:  "Arr = ladder(11, 5, 6)" creates a list array of 11 elements in the arithmetic progression [5, 5.1, 5.2, ... 6]..
			<B>chain(.)</B> -- creates a list array built by replicating a given scalar or array until the desired length is reached.
			<B>fill(..)</B> -- fills an array according to a pattern; type in 'fill' and then key F1, for details.

<U>ADDRESSING ARRAY ELEMENTS</U>
You can refer to elements of an array using square brackets. For a 3x3 array 'Arr', Arr[0,0] (which can also be written 'Arr[0][0]') would be the first row, first column value. The whole first row would be Arr[0] - a one-dimensional array.

To get at a column of this array, you would need to use this notation: 'Arr[][2]', where the '[]' stands for 'all elements'. In other words, this represents all rows in column 2 of the matrix. This notation can be used with higher dimensioned arrays - 'Arr[1][][2][]' would return a particular matrix from a 4-dimensional array. (NB: all array indices are referred to the base 0, not 1; that is, the first row or column or list array element is '[0]', not '[1]'.) You can also set columns in this way: "Arr[][1] = data(1,2,3,4);" (if Arr is a structure with four rows).
More data about such array references is given at the end of this section.

To convert between an indexed address (i.e. the set of array indices used as above to address an element) and an absolute address (in computer memory, relative to the start of the array), use functions <b>offset</b>(.) and <b>indexed</b>(.) See menu item "Help | System Functions" for details.


<U>ARRAYS AND '=' SIGNS </U>
Consider that you have defined a 3x4 matrix 'Mx'.
\t<# blue>NewMx = Mx; <# magenta>// This will make NewMx an exact copy of Mx.
\t<# blue>Arr = Mx[1];  <# magenta>// Arr will become a list array, a copy of row 1.
\t<# blue>Arr = Mx[1][];  <# magenta>// Exactly the same effect. '[]' stands for 'every member of this dimension'.
\t<# blue>Arr = Mx[][2];  <# magenta>// Arr will be a list array which is a copy of column 2.
<# black>Note that if you specify a single location on the RHS, the LHS can be a scalar:
\t<# blue>x = Mx[1,0];

<# black>These all generate new structures on the left. But suppose we have already generated the structure on the left, and only want to fill part of it. Provided we have a match of total array size, we can do the following.
\t<# blue>AnotherMx[1] = Mx[2];  <# magenta>// Row 2 of Mx replaces row 1 of AnotherMx.
\t<# blue>AnotherMx[][1] = Mx[2];  <# magenta>// Row 2 of Mx replaces column 1 of AnotherMx.
\t<# blue>AnotherMx[][1] = Mx[][2];  <# magenta>// Column 2 of Mx replaces column 1 of AnotherMx.
\t<# blue>Arr[1] = Mx[2,2];  <# magenta>// data element Mx[2,2] becomes data element Arr[1].
<# black>
On both LHS and RHS, empty bracket sets '[]' can be omitted if they are at the end of a set of indices. For example, if 'Cub' was declared earlier as a cubic structure 2x3x4, the first of its two inner matrices could be represented as any of:  'Cub[0]'  or  'Cub[0][]'  or  'Cub[0][][]'. (This is only true where there is already a specified index; the bare name 'Cub' on the LHS of an equation does not have the same meaning as 'Cub[][][]', as is seen below in the section "Putting Data Into an Array".)

(Two technical points that may occasionally be useful to know: (1) Data is streamed across the '=' sign as pure data; that is, the LHS does not 'know' what the structure of the RHS is, and vice versa. (2) When data is read from the RHS structure for streaming, it is read across lower dimensions first; e.g. if a matrix, row 0 is read first, then row 1. If the RHS structure were 'Mx[][1]', row 0 would still be read first - but only one element of it would be extracted - then row 1, etc. Data streamed to the LHS is laid down in its array in the same manner.)


<U>REDEPLOYING AND DESTROYING ARRAYS</U>
Whenever you assign a preexisting array to a new array (as in all the above methods), the previous array data and structure is completely wiped out; only the recycled name remains. You can also destroy an array, using the void function 'kill': "kill(Arr);" will remove all trace of Arr, so that its name may be reused in later code for either a new array or a new scalar.

Note that <B>all assignments of one array to another produce complete copies</B>; In MonoMaths there are no data pointers. (Of course for every rule there is a workaround hack. If hack you must, see the 'User Functions' help section under 'Further Points'.)

You can <B>redimension an array</B> at any time, with data conservation. For example, suppose you have a list array Arr = [1,2,3,4,5,6,7,8]. The void function "redim(Arr, 6)" will cause Arr to have length 6, with data truncated: [1,2,3,4,5,6]. On the other hand, "redim(Arr,10)" will pad with zeroes to produce Arr = [1,2,3,4,5,6,7,8, 0, 0]. Again,  you might want to convert Arr into a structured array, with 2 rows and 4 columns: "redim(Arr,2,4) will do this. (Row 0 will be [1,2,3,4], and Row 1 [5,6,7,8].) You could redimension a structured array to be a list array, but this is not often necessary as nearly all operations work the same on both types. For example, sin(Arr) takes the sine of every element of Arr no matter how it is dimensioned.

You can also redimension arrays using two other special functions, <B>undim(..)</B> (which converts any no. of arrays to list arrays) and <B>redimlike(..)</B> (which redimensions given arrays to the dimensions of the final array argument). See under 'system functions' for their usage.


<U>PUTTING DATA INTO AN ARRAY</U>
Some methods have been dealt with as above - 'dim(.)' creates / recreates an array filled with zeroes, and 'data(.)' assigns specific values. (These values can be literals, or can be scalar or array variables; for example, "Arr1 = data(1, x, Arr2);" will create a list array starting with 1, followed by the value of scalar x, and then followed by all the values in Arr2.)

There is also the element-by-element approach: "Arr[1,2] = 4.5;". As mentioned, this can be used for separately filling rows and columns of matrices = "Arr[0] = data(1,2,3);" fills the first row of Arr, and "Arr[][0] = ..." fills the first column.

On this score, note the following code. First we create a 2x2x3 three-dimensional structure:
<# blue>\tcub = data(1,2,3,4,5,6,7,8,9,10,11,12);  redim(cub, 2,2,3);  
<# black>Then we create an empty matrix:
<# blue>\tdim(mx, 2, 3);
<# black>Note the different effect of these two assignments, one involving square brackets, the other not:
<# blue>\tmx[][] = cub[1]; <# magenta>// 'mx' will retain its structure, and will acquire data from 'cub'.
<# blue>\tmx = cub[1]; <# magenta>// 'mx' will be re-created as a list array, containing all the data in the matrix cub[1].
<# black>
Two special functions for filling <I>existing</I> arrays are 'ladder(..)' and 'fill(..)'. (Each has a different version - mentioned above under "Creating Arrays" - which instead creates a new array.)
<B>ladder(..)</B> fills the array with an arithmetic progression, and returns the interval between successive values:
\tdim(Arr, 5);   intl = ladder(Arr, 1, 2) --> Arr is [1,  1.25,  1.5,  1.75,  2] , and intl is 0.25.
<B>fill(..)</B> can be used to fill an array with constants, or with an arithmetic progression, or with any polynomially growing function.
\tfill(Arr, 3)  --> Arr has all elements set to 3: [3,3,3,3,3,3,3]. 
\tfill(Arr, 0, 1) --> [0,1,2,3,4,5,6] - i.e., evaluations of the polynomial (1.n + 0).
\tfill(Arr, 1, 0, 2) --> [1,  3,  9,  19,  33,  51,  73] - the polynomial being (2.n<^>2</^> + 0.n + 1).
It is evident that all arguments, from the second onwards, are coefficients of a polynomial (from lowest to highest power), and that the variable of the polynomial takes on values 0,1,2,... until the array is filled. There is no limit to the size of the polynomial.

<B>populate... through... using:</B> The above functions 'fill(.)' and 'ladder(.)' are fine for filling an array with data that increases linearly or according to a power series. But what if you want to fill a large array with nonlinear data? This is where the 'populate' syntax comes in. Using it, you can fill an array according to <I>any function</I>. The array may have any number of dimensions, or may be a list array. The procedure is briefly as follows. (For more details and for program examples, click on 'populate' in the Results Window.)

First develop a filling function (called 'Foo' in the example below), which has one argument for each dimension of the array to be filled (or 'populated'). (It may have subsequent independent arguments, but for an N-dimensional array the first N arguments of Foo must correspond to the dimensions.) Then you use one of the following two versions of the syntax to fill your structure. I will use a matrix - called 'Mx' - as the model:

(1) We have arrays 'rw', 'cl', with lengths equal respectively to the no. <i>rows</i> and no. <i>columns</i> that we will want in Mx. The following creates Mx, and then fills it by operating with Foo on every pair of values - each Mx[p,q] is filled by Foo(rw[p], cl[q]):
\t<# blue>populate Mx through rw, cl using Foo(rw, cl);<# black>
Note that the order of dimensions is the same as you would use mathematically to describe a matrix's dimensions: A "2x3 matrix" has 2 rows and 3 columns.

(2) Given <I>preexisting</I> array Mx, fill it with Foo(rw, cl). The 'rw' values will be evenly spaced between 0 and 4, and the 'cl' values between 0 and 10.
	<# blue>function Foo(x, y) { return x + y; };
	<# blue>dim(Mx, 5, 11);
	<# blue>populate Mx through (0, 4), (0, 10) using Foo; <# magenta>

<# black>Note that Foo can be used either with or without an argument list. If with,  then the first argument names will simply be ignored and overwritten; you could for example supply "Foo(x, y)" (where x and y have never been mentioned and will not be created)  without error. If without an arguments list, the program automatically supplies them. The main reason for you to supply an argument list (apart from style) would be where your function Foo needs further arguments. These can be safely written after the 'through'  arrays: "Foo(x, y, 20, a+1)".


You can <B>append data to an array</B> using 'data(..)' - e.g. 'aa = data(aa, 1.1, 2.2, 3.3)' extends the array, adding these three values onto the end;  'aa = data(aa,bb)' concatenates arrays aa and bb. You can also <B>copy part of an array</B> using 'copy(..)' and 'copyto(..)'. See the <I>System Functions</I> help section for details of these. (Also see functions 'between(..)' and 'span(..)'.)

You can use '++' and '--' for incrementing part or all of an array. For example, given a matrix called Mx, "Mx++;" will increment the whole matrix; "Mx[0]++;" will increment all elements in the first row; "Mx[][0]++;" will increment all elements in the first column. (You can use this form inside functions for the array as a whole - "sin(Mx++)" would work - but not for parts of an array - "sin(Mx[0]++)" would not work.)

<U>MATHEMATICAL OPERATIONS AND SYSTEM FUNCTIONS</U>
In what follows, 'x' always represents a scalar and 'Arr' an array (list type OR structured type). No account is taken of dimensionality; e.g. in a 3x3 matrix, element (1,1) would simply be the 5th. member of Arr. The one restriction is that arrays <I>must</I> be of the same length in all cases.

<B>Multiply:</B> x*Arr and Arr*x -- all elements of Arr are multiplied by x. Arr1*Arr2: returns an array in which each element of  Arr1 has been multiplied by the corresponding element of Arr2 (no account taken of dimensioning, if any). The result has the structure of Arr1.
<B>Divide:</B> x/Arr -- element Arr[i] becomes x/Arr[i].  Arr/x -- each element is divided by x. Arr1 / Arr2 -- returns an array in which each element of Arr1 is divided by the corresponding element of Arr2. The result has the structure of Arr1.
<B>Plus:</B> x+Arr and Arr+x:  the value x is added to each element of Arr. Arr1 + Arr2: returns an array in which each element of Arr1 has been added to the corresponding element of Arr2, irrespective of structure. The result has the structure of Arr1.
<B>Minus:</B> As for Plus.
<B>Power:</B> x^Arr -- the nth. element of the result is x raised to the nth. element of Arr. Arr^x -- all elements raised to x. Arr1^Arr2 - nth. element of the result is nth. element of Arr1 raised to the nth. element of Arr2. The result has the structure of Arr1.
<B>sum</B>(..) -- the sum of part / all the contents of the array (irrespective of its structure).
<B>distance</B>(..) -- Returns euclidean distance between arrays (given the right boolean arguments).
<B>dot(Arr1, Arr2)</B> -- the dot product of two vectors. (But no check is made on structure, so Arr1 and Arr2 can be of any dimensions, as long as they have the same length.)
<B>find</B>(..), <B>finds</B>(..) and <B>findall</B>(..) -- find first occurrence / find number of occurrences + positions of first and last / find all occurrences. Start point of search is specified for all three.

<U>MANIPULATIVE SYSTEM FUNCTIONS</U>
Refer to the "System Functions" section for details on these functions (or key F1 with the cursor at the function name). Except as otherwise stated, they are all nonvoid, returning a new array based on the first argument of the function (which is not itself altered).
<B>copy(.) and copyto(.)</B> return part of an array. (The first version copies a given extent from a given location; the second version copies all between two given locations.)
<B>select(Arr, array of indices)</B> returns a list array of values from Arr, selected using the supplied indices.
<B>evict(Arr, array of indices)</B> the converse; returns a list array of values from Arr, selecting all <I>except</I> those indicated by the supplied indices.
<B>poke(Arr, array of indices, array of values OR single scalar value)</B> -- the inverse: takes a list array of values and inserts them into Arr, using the supplied indices; OR takes a single value and inserts it as per supplied indices.
<B>insert(.)</B> inserts a second array into the input array, at a given point. If that point is beyond the end of the input array, the second array is appended to the input array. But this is done more efficiently by 'data()'.) 
<B>delete(.)</B> copies a given array with a section deleted.
<B>replace(.) and replaceto(.)</B> return a given array with part of its extent replaced by a given replacement (array or scalar).
<B>peck(.)</B> finds the first instance of some value and either removes or replaces that single instance of the value.
<B>substitute(.)</B> returns copy of input array, with all instances of a scalar or array (or within a certain range of values) replaced by a given scalar or array.
<B>expunge(.)</B> returns copy of input array, with all instances of a scalar or array value removed (without replacement).
<b>readtable(.)</b>given a look-up table array, and an input array of indices for it, returns the table values corresponding to the indices. 
<B>reverse(..)</B> and <B>reversed(..)</B> -- reverse array contents. The first form is void, reversing the array named in the argument.
<B>removedups(array)</B> -- returns a copy of the array with all duplications removed: 
<# blue>removedups(data(1,1,3,2,2,3,1));<# black> returns the array [1, 3, 2]. No reference to input structure; output always a list array.
<b>removeruns(array, ...)</b> -- returns a copy of the array with runs of value(s) replaced by a single value.
<B>intersection(two or more arrays)</B> -- returns a list array (nonchars. data) of all elements common to all arrays. 'empty(.)' returns 'true' if none. Duplicates removed.
<B>push(..)</B> and <B>pop(..)</B> -- Use the array as a stack: push data onto one end of the array and remove it from the other end (to keep length the same).
<B>cull(..)</B> and <B>cullbykey(..)</B> -- shorten the array by removing particular values.
<B>differences(..)</B> returns the differences between successive array elements.
<B>overlay(..)</B> returns an interaction (+, -, *, / or overwrite) between two list arrays or two matrices, but only in the region in which they overlap (you supply pointers to show where overlapping begins).
<B>fixedsize(.)</B> returns a copy of the array either padded or (optionally) truncated to a given length, with padding as needed.

<U> SYSTEM FUNCTIONS SPECIFIC TO MATRICES</U>
More details on these can be found in the <I>System Functions</I> help section. Here they are just mentioned:

<B>determinant( SquareMx [, CutOff])</B> -- produces the determinant of Mx (which must be square and at least 2x2).
<B>inverse(Mx [, CutOff])</B> -- Returns the inverse of the matrix, which must be square, and at least 2x2.
<B>transpose(Mx)</B>.
<B>mxmult(Mx1, Mx2)</B> -- true matrix multiplication.
<b>matrixop(Mx1, Operation, Arr)</b> -- operations between matrix and vector, or matrix and matrix.
<b>mxhalf(.)</b> -- reads from or writes to the upper or lower triangle of a matrix, ± the main diagonal.
<B>mxdiag(.)</B> -- returns / manipulates square matrix diagonal.
<B>shufflemx(..)</B>-- rearrange the order of rows or columns.
<B>selectrows / selectcols(Matrix, arrow of row / column nos.)</B> returns a matrix made up of the indicated rows or columns.
<B>pokerows / pokecols(matrix Destination, list array Row/ColNos, matrix Source)</B> -- the inverse: overwrites existing rows / cols with supplied new ones.
<B>insertrows(.),  insertcols(.)</B>.
<B>appendrows(.),  appendcols(.)</B>.
<B>deleterows(.),  deletecols(.)</B>.
<B>copyrows(.),  copycols(.),   copyrowsto(.),  copycolsto(.)</B>.
<B>copymx(.),  copymxto(.)</B> -- copies a submatrix of given matrix.
<B>replacerows(.),  replacecols(.)</B>.
<B>sumrows(.),  sumcols(.)</B>.
<B>prodrows(.),  prodcols(.)</B> -- products of all terms in each row / column.
<B>chainrows(.),  chaincols(.)</B> -- generate matrices with given no. of repetitions of an input row / column.
<B>findinmx(..)</B> -- find a value in a matrix and return the row and column of the find.
<b>removedups(mx, 'R')</b> -- remove duplicate rows;  <b>removedups(mx, 'C')</b> -- remove duplicate columns.
<B>push(.),  pop(.)</B> -- cause the array to act like a stack, rows being pushed onto / popped off the stack. (Not confined to matrices, but would usually be used with a matrix.)
<B>rowop / colop (..)</B> -- replaces a row / column with a multiple of any compatible row / column (unary version) or with an operation between two rows / columns, or even a row and a column (if a square matrix).


<U>DISPLAYING ARRAY VALUES</U>
Array values are not automatically displayed in the 'results' window (as large arrays would flood it with data that may not be wanted). To overcome this, insert the instruction 'write(Arr)'. You can have more than one argument, and can include explanatory text: 'write("Arr1 = ",Arr1, "; Arr2 = ", Arr2);'. (You can also use 'writeln(..)' which automatically inserts a line feed at the end). In either function you can insert line breaks either by including the character code 10 or the character sequence "\\n". These both produce two lines of text: "write("Array values are:", 10, Arr1);" and "write("Array values are: \\n", Arr1);", 

If instead you want the contents to be displayed in a message box, simply substitute the word 'show' for 'write' - e.g. 'show("Array values are:", 10, Arr1);'.

Matrices (and higher structures) can be displayed row by row using the function 'neat(.)' - "writlen(neat(Mx));". (Without this function, matrix data will be displayed as a continuous list of numbers, with semicolons separating the data from different rows.)

<U>FURTHER POINTS</U>
To find the <B>total size of an array</B> (i.e. the size of its total data content, irrespective of dimensioning) use the function 'size(Arr)'. (The value is always \> 0 for arrays, and always 0 for scalars.) Similarly you can find the <B>size of a dimension of an array</B> using 'size(Arr, n)' - n being 0 for the lowest dimension - or <B>retrieve all dimensions</B> with 'dims(Arr)', which returns an array of dimensions, element [0] corresponding to the lowest dimension.

A convenient way to <B>distinguish an array from a scalar</B> is to use the function 'isarray(xx)', which returns 1 if xx is an array and 0 if it is scalar.

 <B>Jagged arrays</B> - also called 'ragged arrays' - are two-dimensional arrays with rows of unequal length. They are not currently supported, though a work-around exists, for example to hold a set of unequal character strings; see system function 'jagger(.)' and fns. mentioned there.

<B>Structures returned by array references in square brackets</B>
Consider an array of dimensions 3x4x5 named "arr", in the following cases:
<bullet>If all possible indices are specified, the return is a scalar: " x = arr[1][2][1];"
<bullet>In all other cases, the return is an array - "brr = arr[1][2][ ];"
<bullet>Where lower dimensions are omitted, the outcome is exactly the same as if they were present and represented by empty brackets:  "arr[2]" is equivalent to "arr[2][ ][ ]".
<bullet>Where only one dimension is represented by empty brackets, the return is a list array; in all other cases, it is a structured array with as many dimensions as there are empty brackets. ("arr[ ][1][1]" would return a list array of length 3;  "arr[ ][1][ ]" would return a 3 x 5 matrix.) In the case of multiple dimensions, the original hierarchy of dimensions is preserved; for that reason, "arr[][1][]" returns a 3x5 matrix, not a 5x3 matrix.
<bullet>You can use square brackets with array expressions, provided they are enclosed in brackets: "x = (MyArr^2)[3];",  "brr[ ] = (Foo(a,b))[ ];" 

===========================================================
//LISTS//
<just c><B>USING THE SYSTEM LISTS</B>

<just l><B>System lists</B> are lists of data stored outside the variable space of your program; instead they live in the variable space of <I>MonoMaths</I> itself. (NB - 'system lists' and 'list arrays' are different entities; the use in both of the common descriptive word 'list' does not imply a functional link.)

Their uses include - (1) preserving data from one run for access during the next run; (2) overcoming the barrier of variable 'scope'; (3) acting as a stack for your data; (4) collecting data in trouble-shooting situations (e.g. to track values of some variable during a faulty loop).

(1)  <U>Persistence of data between runs</U>
Program variables from the last run are always eniolated at the beginning of the next run. Normally system lists are also, but if the last run contained the instruction "lists_preserve();", then the lists will survive into the immediate next run (but not beyond, unless you repeat the instruction in that next run). (Of course you can also preserve data by saving program variables to disk, using functions "save(.)", and reading them back in subsequent runs using "load(.)".)

(2) <U>Overcoming the barrier of scope</U>
Variables declared in the main program are inaccessible to all functions (unless passed as arguments); and variables declared in one function are inaccessible to code outside of that function. But lists are outside of this scope system, as they are not contained in the program's variable space. As a result, they can be written to and read from at any point in the code.

(3) <U>Use as a stack</U>
There are 'push' and 'pop' instructions which enable a list to be used like a stack.


The downside of using lists is that special functions are needed to write to and read from these lists, so that they are not as easy to handle as are array variables. Also there would be some cost (though not much) in speed. I have tried to make the system names self-obvious; in particular, all list functions which deal only with a single list begin with "list_", and all list functions intended to handle multiple lists begin with "lists_". 


<U>HANDLING LISTS</U>
No lists exist at the start of your program (unless you have caused them to persist from a previous run - see later). You create them as you need them, using the instruction 'list_new()' (no argument) or 'list_new(no. of lists)'. Once created they exist until the program ends, when all lists (normally) are destroyed. You can, if desired, destroy the lists during the run.

Lists are indexed from 0 up. Their elements are also numbered from 0 up, as with arrays. Their contained values are purely numerical; that is, there is no equivalent to array features such as dimensioning or 'character' status. A list can be empty (unlike an array), and indeed it is empty when you first create it.

<B>Creating, emptying and destroying lists:</B>
A new list is created as follows:
	<# blue>cnt = list_new();  <# magenta>// Nonvoid use returns the index of the new list. Note - no argument.
	<# blue>cnt = lists_new(5);  <# magenta>// Creates five new lists. Nonvoid use returns the index of the <I>first</I> new list.

<# black>Lists are emptied thus:
	<# blue> list_clear(5);  <# magenta>// Empties all data from list 5, freeing up its memory.
	<# blue> lists_clear(5,7);  <# magenta>// Empties all data from 7 lists, starting with list 5.
	<# blue> lists_clear_to(5,7);  <# magenta>// Empties all data from lists 5 through to 7.
	<# blue> lists_clear();  <# magenta>// Clears all data from ALL lists.

<# black>You can destroy all lists at once:
	<# blue> lists_kill();  <# magenta>// No harm done if there were no lists to kill.
<# black>or you can destroy all lists at and above a given list:
	<# blue> lists_kill(5);  <# magenta>// Preserves lists 0 to 4. No harm done if some or all lists are nonexistent.
<# black>However the program does not allow the existence of destroyed lists below existing lists; e.g. you cannot destroy list 5 while preserving list 6.

<# black>To preserve the lists for the next run (but only the next run - unless that run repeats the following), include the void function call <B>lists_preserve()</B> somewhere (anywhere) in your program. When called, this sets an internal flag which ensures persistence after the run ends. The function takes no argument.

If there  is any risk that the last program might have included this function call, it is prudent to commence a program using lists with "lists_kill();". It is safe to use this, even if there were no such persistent lists.

<# black><B>Appending data to lists:</B>
	<# blue>list_add(1, x);  <# magenta>// Appends scalar value 'x' to the end of list 1.
	<# blue>list_add(1, arr);  <# magenta>// Appends all values in array 'arr' to the end of list 1. Structure of 'arr' ignored.
	<# blue>newlen = list_add(1, arr);  <# magenta>// Nonvoid usage returns the new length of the list.

<# black><B>How many lists, and how big is a list?</B>
	<# blue>sz = lists_count(2);  <# magenta>// Returns the number of lists that exist (0, if none).
	<# blue>sz = list_size(2);  <# magenta>// Returns the size of list 2 (and therefore returns 0 if list 2 is empty). If list 2 does not yet exist, returns -1.

<# black><B>Reading from the list</B>
	<# blue>arr = list_read(1);  <# magenta>// Reads the entire list into arr (which will be created as a list array).
	<# blue>x = list_read(1, 0);  <# magenta>// Returns the first item ('item 0') from list 1 to a scalar variable.
	<# blue>arr = list_read(1, 2, 5);  <# magenta>// Returns 5 items, starting from item 2, and assigns them to 'arr'.
	<# blue>arr = list_read_to(1, 2, 5);  <# magenta>// Returns 4 items, starting with item 2 and ending with item 5, and assigns them to 'arr'.
<# black><B>NB!</B> If <I>either</I> the list does not yet exist <I>or</I> any part of the extent to be read has not yet been assigned a value, the program will crash (with an error message)!

<B>Inserting / altering / deleting data in a list:</B>
To insert data from one or more variables (scalar or array) at 'position' in the list, use this function:
	<# blue>list_insert(1, 3, x, arr);  <# magenta>// Inserts scalar x and contents of array arr at item 3.
<# black>If you want to overwrite data inside the list, use 'list_alter(..)', which takes exactly 3 arguments:
	<# blue>list_alter(1, 0, x);  <# magenta>// Overwrites data element 0 of list 1 with scalar value x.
	<# blue>list_alter(1, 0, arr);  <# magenta>// Overwrites from element 0 up with the contents of the array.
<# black><B>NB!</B> As with the reading functions, if <I>either</I> the list does not yet exist <I>or</I> any part of the extent to be overwritten has not yet been assigned a value, the program will crash (with an error message)!
To delete, use one of these two functions:
	<# blue>list_delete(0, 5, 2);  <# magenta>// Deletes data elements 5 and 6 from list 0, '2' being the extent to delete.
	<# blue>list_delete_to(0, 5, 6);  <# magenta>// Does the same, '6' being the last element to delete.

<# black><B>Operating on a data item in a list:</B>
The function is <B>list_opn(</B>ListNo, Index, Opn, Value); where Opn is an array with Opn[0] being one of '+', '-', '*', '/', '^', 'A', 'B', 'S' (A = absolute value; B = boolean evaluation; S = sign, with zero replaced by Value). The list is altered, and a copy of the new value is returned. (A fifth nonzero argument prevents the list from being altered.)

<B>Finding and culling data from a list:</B>
Find value(s) using either the two or the three argument version:
	<# blue>list_find(listno, x); <# magenta>// Returns first occurrence of value x, or -1 if none.
	<# blue>list_find(listno, x1, x2); <# magenta>// Returns first in range (inclusive), or -1 if none. Order of x1 and x2 irrelevant.
<# black>Cull all occurrences of value(s) using one of these two functions:
	<# blue>list_cull(listno, <any no. of scalars or arrays); <# magenta>// Removes all enumerated values from the list, returns final size.
	<# blue>list_cull_range(listno, x1, x2); <# magenta>// Removes all values between x1 and x2 (either can be the higher value). Returns final list size.

<# black><B>Initializing a whole list</B>
No special instruction needed here. The list must have been created; and if it has already held data, that data should be cleared away. Then you simply append the array that is to fill the list.
	<# blue>list_clear(3);  list_add(3, newdata); 

<# black><B>Retrieving one or more whole lists</B>
You can retrieve the entire contents of contiguous lists, or indeed of all lists, as a matrix by using the instruction "lists_read([pad byte], [first list no.][nol lists])". The longest list determines the number of columns in the matrix; the argument 'pad' (a one-character array, or a scalar value) gives the byte which will be used to pad out shorter rows.
	<# blue>mx = lists_read(' ', 1, 3);  <# magenta>// The matrix will have three rows, consisting of lists 1 to 3; the pad will be byte 32 (the unicode
			<# magenta>// of the space character). This would be appropriate where these lists held characters for display.
	<# blue>mx = lists_read(0);  <# magenta>// This retrieves <I>all</I>  lists, padding with byte 0.
	<# blue>mx = lists_read(0,1,1);  <# magenta>// Returns the same data as "arr = list_read(1)", but arranged as a matrix with one row.

<# black><B>Using a list as a stack</B>
This facility is served by two functions with the classic actions of pushing and popping.

<B>list_push(1, x)</B> Appends scalar value x to the end of list 1.
<B>list_push(1, arr)</B> Appends the values in array 'arr' to the end of list 1. Element [0] goes in first.
"list_push(.)" does return a value, occasionally useful; it is the size of the list <I>after</I> all the data has been appended.

<B>list_pop(x, 1)</B> Assigns the last data element of the list to 'x' AND removes it from the list.
<B>list_pop(arr, 1)</B> Assigns data elements to 'arr' until 'arr' is filled; AND removes these elements from the list. They go into 'arr' backwards. Suppose 'arr' has size 3; then arr[2] acquires the last value on the list. This ordering ensures that if you push an array onto the list and then later pop that data to a second array, the two arrays will have identical data.

"list_pop(.)" does return an important value, which is the size of the list <I>after</I> the pop has been done. If the pop was unsuccessful because there was not enough data on the list, -1 will be returned instead. (In that event, the shortfall of data to the variable will be replaced by zeroes.)

(NB - note that the value returned by the function "list_pop(.)" is <B>not</B> the value popped! This is a bit counter-intuitive, but necessary.)

<B>Duplications:</B> If you are not confused by all this, you can omit "_read" from all four functions using it. That is, the following pairs of names invoke the same function internally: <B>list(..)</B> and <B>list_read(..)</B>;  <B>list_to(..)</B> and <B>list_read_to(..)</B>;  <B>lists(..)</B> and <B>lists_read(..)</B>;  and <B>lists_to(..)</B> and <B>lists_read_to(..)</B>.

<B>Displaying lists after the run:</B> Use the menu item "Other | Display Values of System Lists". (You can display them during a run using 'writeln(list(2))' or 'show(list(2))'. )

========================================
//SYSTEM FUNCTIONS//
<just c><B>SYSTEM FUNCTIONS</B>

<just l>Wherever an argument is listed as <# blue><I>Variable</I><# black>, it can be either a scalar or an array. If it is an array, the operation will be carried out on each array element individually. Arguments in square brackets '[..]' are optional.
<B>abs</B>(<# blue>Variable<# black>) -- the absolute value: |Variable|.
<B>addplot</B>(<# blue>scalar GraphID, one or more scalars or arrays<# black>) -- Void. If graph g can be identified, then plots p1, p2... are added to the graph (if in existence). No error is raised if graph or plot IDs are not identifiable. Any number of plot IDs can be supplied, as any mixture of scalar or array values. You would use this function in conjunction with <B>killplot(.)</B> to gradually move a point or curve or shape across the graph surface. Suppose your graph displays plot p1, and that you wish to make the plot slightly different, as the next step in an animation. You would devise plot p2 as the slightly different version of p1, and then call 'killplot(p1);  addplot(g, p2);'. The function applies to both 2D and 3D graphs. Duplication is not a problem; an attempt to add a plot already present in the graph is simply ignored.
<B>allzero</B>(<# blue>Variable [, scalar Tolerance ] <# black>) -- returns a pseudoboolean scalar: 1 (true) if all elements of Variable are zero; otherwise 0 (false). If there is a 2nd. argument 'Tolerance' and it is positive, a 1 is returned if all elements in Variable have absolute values <= Tolerance. The complementary function is 'nozero(.)'.
<B>and</B>(<# blue>Variable1, Variable2 [, scalar Tolerance ] <# black>) -- returns an object with the structure of Variable1 (scalar allowed), assigning a boolean score to every pair of corresponding elements in Variable1 and Variable2. Where <I>both</I> elements in the pair are <I>nonzero</I>, the score is 1; otherwise, 0.
If there is a 3rd. argument 'Tolerance' and it is positive, a match is regarded as occurring if the absolute difference between the two elements is <= Tolerance.
Argument combinations allowed are: scalar-scalar;  array-array (of same size, not necessarily of same structure); array-scalar (in which case the scalar is replaced by a virtual array containing only that scalar value).
See also binary logic functions 'or(.)', 'xor(.)' and 'xorcomp(.)', and unary functions 'is(.)', 'not(.).
<b>appendrows</b> (<# blue>matrix InMatrix, scalar / array NewData [, scalar NoTimesToAdd]<# black> ) -- NOT void. Returns a copy of InMatrix with extra row(s) appended.
'NewData' can be: (1) a scalar, in which case it is converted internally to a single row of that value repeated. (2) a list array, in which case it must be divisible exactly by the row length of InMatrix; (3) a matrix, in which case it must have the same row length as InMatrix. 
'NoTimesToAdd' causes the above operation to be repeated that many times, the same row or set of rows being inserted each time. If it is \< 1, the returned matrix is a simple copy of InMatrix (with no error raised).
<b>appendcols</b> (<# blue>matrix InMatrix,  scalar / array NewData [, scalar NoTimesToAdd]<# black> ) -- NOT void. Returns a copy of InMatrix with extra column(s) appended.
'NewData' can be: (1) a scalar, in which case it is converted internally to a single column of that value repeated. (2) a list array, in which case it must be divisible exactly by the no. of rows of InMatrix; (3) a matrix, in which case it must have the same no. of rows as InMatrix. 
'NoTimesToAdd' causes the above operation to be repeated that many times, the same column or set of columns being inserted each time. If it is \< 1, the returned matrix is a simple copy of InMatrix (with no error raised).
<B>arccos</B>(<# blue> Variable [, bool ClipIfOverLimits ]<# black>) -- the inverse of <# blue>cos(..)<# black>. Returns angles in the range 0 to PI. If the boolean is 'true', any values outside +/- 1 will be trimmed back to these limits. (Use where numerical errors could produce an argument very slightly over / under the limits.)
<B>arcsin</B>(<# blue>Variable [, bool ClipIfOverLimits ]<# black>) -- the inverse of <# blue>sin(..)<# black>. Returns angles in the range -PI/2 to PI/2. If the boolean is 'true', any values outside +/- 1 will be trimmed back to these limits. (Use where numerical errors could produce an argument very slightly over / under the limits.) 
<B>arctan</B>(<# blue>array / scalars Numerator [,  Denominator ]<# black>) -- the inverse of <# blue>tan(..)<# black>. The one-argument version returns the arctangent as a value in the range -PI/2 to PI/2. The two argument version returns the angle in the correct quadrant (the numerator being taken as a Y increment and the denominator as an X increment), in the range -PI to PI. In both cases, if Numerator or Denominator is 0, POSINF or NEGINF, the geometrically correct angle is returned; this is not an error state. (If the value of [Numerator / Denominator] is indeterminate - e.g. both are 0 - then NAN is returned.)
In the two-argument version, both arguments must be of the same type (scalar or array), and if arrays, of the same length.
<B>asc</B>(<# blue>Array<# black>) -- returns the unicode value of the first element in Array; e.g. <# blue>n = asc('A');<# black> would return 65.
<b>aspect</b>(..) -- used in 3D graphing only. See the section "Graphing - Basic", towards the end of the text (where 3D graphing is dealt with).
<B>bestsquare</B>(<# blue>scalar Value<# black>) -- If Value is a scalar and rounds to 1 or more, the function returns an array of two factors which when multiplied equal Value, these factors being as near to each other in value as possible, the lower number coming first. Examples: 'bestsquare(48)' returns [6, 8] (rather than e.g. [4, 12]); 'bestsquare(144)' returns [12, 12]; 'bestsquare(17)' returns [1, 17]. If Value rounds to 0 or a negative integer, an array of length 1, value NaN is returned, and a call to 'empty(.)' returns TRUE.
<B>between</B>(<# blue>InArray, scalar StartPtr, scalar EndPtr<# black>) -- copies the subarray of InArray that lies BETWEEN StartPtr and EndPtr exclusive, producing a list array (i.e. not copying the structure of a structured array). E.g. for InArray = [10, 11, 12, 13, 14, 15], 'between(InArray,1, 4)' produces [12, 13]. If StartPtr is negative the returned subarray starts from InArray[0]. If EndPtr is beyond the end of the array, the returned array includes the end of InArray.  Where arguments would indicate a subarray of length 0 or negative length, the empty array (value NaN, size 1) is returned.  (See also functions 'copy', 'copyto', 'span'.)
<B>bin</B>(<# blue>scalar Value [, scalar GroupSize [, char. array Delimiter ] ]<# black>) -- the binary version of the number, for numbers up to the 8 hex digits 7FFF FFFF (i.e. 0 to 2,147,483,647). Negative numbers return complemented numbers; e.g. 'hex(-1)' returns a string of 32 '1's. Fractional numbers are rounded first (banker's rounding). 
'GroupSize', if present and >= 1, (a) causes left-padding of the string with '0' till its length is a multiple of GroupSize; and (b) if  Delimiter is supplied, divides the string up into packets of length GroupSize, separated by Delimiter.
Inverse function: 'unbin(.)'.
<B>binom</B>(<# blue>Scalar TopValue, Scalar BtmValue1 [, Scalar BtmValue2] <# black>) -- Returns the binomial coefficient(s). The two-argument value returns a <I>scalar</I> - the binomial coefficient (TopValue  BtmValue1); the three-argument value returns an <I>array</I> - all the coefficients from (TopValue  BtmValue1) to (TopValue  BtmValue2). Obvious limits apply: TopValue >= 0, BtmValue >= 0 and <= TopValue, and if supplied, BtmValue2 >= BtmValue1. In addition, the upper limit on TopValue is 170. (Use function <B>logbinom(.)</B> if you want to work with larger numbers.)
<B>bitop</B>(<# blue>array Operation, one or more Operands<# black>) -- bitwise operations. Only the first character of Operation is examined, which must be one of the following:  '&': bitwise AND;  '|': bitwise OR; '^': bitwise XOR; '1': 1's complement;  '2': 2's complement. Values are all rounded and converted to 64-bit integers before the operations happen. They must have less than 16 decimal digits; i.e. they must lie inside the limits +/- 1E15, or an error is raised. (Limits to the precision of .NET type 'double' dictates this.)
The function always returns a scalar value.
'Operands' may be any mix of arrays and scalars, with the following limitations:
(1) Unary operations ('1' and '2'): there may be only one value in Operands.
(2) Binary operations('&', '|' and '^'): there must be at least two values in Operands. The operation will chain through these in succession; for example, "bitop('&', a, b, c, d)" will produce bitwise (a & b & c & d).
Example code demonstrating all of the operations can be viewed by entering 'bitop' in the Assignments Window and then keying F1.
<B>bkmkcopy</B>(<# blue>array Source, scalar StartPtr, array OpenBkMk, array CloseBkMk<# black>) -- Looks in Source (structure ignored), from StartPtr onwards, for the two bookmarks. If both are found, returns what is between them as a list array. If nothing is between them, or if either is not found, returns an array of size 1, value NaN; and subsequent 'empty(.)' call returns 'true'.
<B>bkmkreplace</B>(<# blue>array Source, scalar StartPtr, array OpenBkMk, array CloseBkMk, array NewData [, bool RetainBkMks]<# black>) -- Looks in Source (structure ignored), from StartPtr onwards, for the two bookmarks. If both are found, Inserts NewData between them, overwriting any data that was there; if the final bool is not present or is 'false', the bookmarks themselves are also removed. If either bookmark is not found, returns a copy of the original data unedited (as a list array) - no insertion.
<b>blockfile</b>(<# blue>array FileName [, array DoWhat [, array AlternativeMessage ] ] <# black>) -- Blocks / unblocks the saving of the current content of the Assignments Window with the listed file names via menu options "File | Save" and "File | Save As" while the program is running. (The function has no effect on the system function "save(.)" operating within the same program.) The function exists for the case where the program removes its own text from the Assignments Window so that it can be used for other operations during the run; the danger is that you will automatically key "File | Save" to save whatever new material is in the Assignments Window, and in the process overwrite the program itself.
<i>FileName:</i>The full path and name. You can use standard abbreviations,  e.g. "~" for the personal home folder. If the name occurs alone, it is matched to the current directory (not recommended, as that can change during program runs as the result of other file I/O actions). If the name is invalid, no error is raised; simply what you thought you were blocking / unblocking won't get blocked / unblocked.
If you want to stop a file name from being used to save the file <i>anywhere</i> in any directory, prefix the name with "!". (You can also do this with a partial file path before the file name; that path and name could not be saved in any other directory.)
<i>DoWhat:</i> An array, only the first element of which is examined. This is case-sensitive, and should be one of:  'B' - block the file mentioned;  'U' - unblock the file mentioned, if it had earlier been blocked (no action, if not);  'A' - unblock all currently blocked files (if any) (in this case, FileName is not accessed, so could even be scalar);  '?' - just return a list all currently blocked files (if any) (again, FileName is not accessed, so could even be scalar).  Any other value of DoWhat raises an error. It can be omitted, in which case it defaults to 'B'.
<i>AlternativeMessage:</i> The automatic dialog box message for a blocked file event isn't a bad one; but if you would like to do your own, and DoWhat is 'B', then add in this third argument.
Note that this function does NOT prevent you saving a blocked file from within the program, via system function "save(.)". It only blocks saving via the "File" menu.
RETURNED: In all cases, a chars. array consisting of currently blocked file names delimited by '|'. If there are none, returns " " (i.e. an array of one space character). If some file has been assigned an alternative message (i.e. the argument AlternativeMessage was supplied), then that file name will be followed by '#' and the message.
Crashes occur only if DoWhat is scalar or unrecognized, or if FileName is scalar where it is actually used (DoWhat = 'B' or 'U').
<B>boardplacemt</B>(<# blue>scalar GraphID)<# black>  -- If the graph is identified, returns an array of size 4, giving size and position of the whole drawing board; [0] = left (pixels, from edge of screen); [1] = top;  [2] = width;  [3] = height. If graph not identified, returns the 'empty array' - size 1, value NaN.  The returned array can be used directly as the argument for a future call to 'placeboard(.)' for a new graph. (That function simply does nothing - and returns 'false' - if the array is the 'empty array'.)
One adjustment is made: Values returned by this function are integers (pixels), EXCEPT if either [0] or [1] should be 1 (pixel) it actually returns as 1.001. This is because the array returned by this function is often plugged into a call to 'placeboards(.)'; if so, then a top or left value of 1 would be interpreted as meaning 'full screen width / height', in which case the new graph would disappear beyond the screen.
NB - timing is important; if this is called much less than 1/4 of a second after programmatic resizing, it will return the values before the resizing. This time will obviously vary with different computers, so it may be safer to allow 1/2 second.
<B>boardresize</B>(<# blue>scalar GraphID, scalar NewWidth, scalar NewHeight<# black>) -- Void. Tries to reset the dimensions of the form (or window, if you prefer) which holds the graph. (Mono (Gdk component) will overrule or modify your arguments if it feels that it cannot comply with them.)  For either argument, a value \<= 1 is taken as a factor of screen width or height; values > 1 are taken as pixel dimensions. If the graph cannot be identified, or if arguments are zero or negative, nothing happens (but no error is raised). Note that Mono will interpret the case where NewWidth = NewHeight = 1.0 as a command to maximize the board.
See also <i>graphresize(.)</i>.
<B>boolstr</B>(<# blue>Any no. scalars and arrays TestValues [, chars. array TrueFalse]<# black>) -- returns an unpadded chars. list array (if TestValues is just one scalar) or 'jagged' matrix, column length being longer of the 'true' and 'false' string pair, padder being the space char. All values are tested for being 'true' (nonzero) or 'false'. The output string for these values is determined as follows...
TrueFalse = "T" or "TR" --> 'TRUE', 'FALSE';  "t" or "tr" --> 'true', 'false' (the defaults).
TrueFalse = "Tr" --> 'True', 'False';  "tR" --> 'tRUE', 'fALSE'.
There can be more characters after the first two, which will be ignored.
TrueFalse begins with '/':  
    "/string A/string B" --> 'string A', 'string B'   (Note - no stripping of blanks.)
    "/ string 1 " --> ' string 1 ', 'false' (default 'false', as no 2nd. string supplied.) 
<b>bracketlevel</b>(<# blue>array String, array Opener, array Closer, scalar Pointer<# black>) -- gives information about bracketting relative to element Pointer in array String.
<i>String</i> -- the array should contain unicode values; I don't know what would happen if you try using other values.
<i>Opener, Closer</i> -- only the first character is accessed. (A scalar would also do, if it were the corresponding unicode.) For regular brackets, these would be '(' and ')'; but they can be any characters you like (though obviously not both the same character).
<i>Pointer</i> -- this function is unforgiving; if Pointer does not point to an element of the array (i.e. is negative, or too large), the function crashes.
The RETURNED ARRAY always has length 3. The elements are deployed thus:
[0]  -- IF NO ERROR:  the bracketting nesting level. 0 = Outside of all brackets; 1 = inside single brackets, unnested; 2+, successively more nested bracket levels.
		E.g. in the string "00(11(22(33(44))))", each digit by a happy coincidence happens to be what [0] would contain if Pointer pointed to it.
[0] -- IF ERROR IN BRACKETTING: Always -1. Examples of arrays that would produce this (whatever the value of Pointer): "AA(BB" or "AA)BB" or "AA)BB(CC". In other words, bracketting must be logically correct throughout the whole string; this is important if you are testing just a substring of text, where your substring cuts across the correct bracketting of the original text.
When Pointer points to a bracket, the value of [0] will be the nesting level of the characters between it and its matching bracket. For example, in "(A)", Pointer of 0, 1 or 2 would return the same value 1. (the brackets can be empty; "()" would return [0] as 1 for Pointer of 0 or 1.)
Whether there is error or not, the next two are always filled. You cannot rely on their values, however, in the presence of errors.
[1] -- The position in String of the bracket AT or TO THE LEFT OF Pointer. Note that this finds the bracket at the current nesting level, hopping over any nested brackets along the way. For example, in this string - "(AA(BB(CC)DD)EE)", if Pointer points to either of the 'E's, then [1] will be 0, the position of the first bracket in the string.
[2] -- The position in String of the bracket AT or TO THE RIGHT OF Pointer. Again, this hops over any nested brackets along the way. In the string above, if Pointer pointed to one of the 'A's, the returned value would point to the final bracket in the string.
If there IS NO BRACKET to the left, [1] returns -1; likewise if none to the right, [2] returns -1.
Note that you can use this function just to test whether bracketting is legal and complete in some text; in that case you would only be interested in returned element [0].
<b>btnrelease()</b> -- Returns an array of size 15, providing data re the last release of the mouse button in the Assignments Window, PROVIDED that button was clicked over already selected text. (Due to the way Mono's TextView class is set up, this is the only situation in which a button release event can be readily detected.) Fields are made up as follows:
	[0] = button clicked (0 if none since user run startup OR since the last call to this function); left = 1; middle = 2; right = 3.
	[1] = time of this click in msecs. since start of 1 AD.
	[2] = time since last click, or same as [1] if this is the first click this run.
	[3], [4] currently unused, reserved for future timing entries.
	[5] = CNTRL down (TRUE or FALSE), [6] = ALT down.
			([7] supposedly is for SHIFT down, but is never detected as Mono's TextView hijacks SHIFT + mouse click.)
			Keys CNTRL and ALT may be down together, in which case both [5] and [6] will be TRUE.
	[8] to [10] unused; reserved for other modifier keys detection in the future, if necessary.
	[11, 12] = (X, Y) of click relative to the top of this window.
	[13, 14] = (X, Y) of click relative to the top of the screen.
Note that 
(a) At the start of a program run, all fields are zero.
(b) This function resets [0] in the internal buffer, but no other fields. So if [0] is nonzero, there has been a new click; if it is zero, the rest of the data is retained from the last click.
<B>cap</B>(<# blue>scalar / array InputValues, scalar CriticalValue, scalar Asymptote<# black>) -- returns a structure of the same type as InputValues in which every input value above CriticalValue is replaced with a smaller value, one which liese between CriticalValue and Asymptote. Invoke 'Hints' for more detail and a graphing example.
<b>captured</b>() -- When, after running some code, you put the cursor beside or in some array name and then press the F1 key, you get a display of that array's contents. One button in that window is marked "Capture". Click on this and the array details and data are saved in a file "Captured Array" in the program's directory. You can then operate on that array by starting up a new instance of MonoMaths and adding the line "arr = captured();" (the LHS name is immaterial). The LHS array has the same structure, chars. rating and data as the array that was captured.
The function also may take an array argument: <b>captured(array ShowWhere)</b>. Only the first letter of that array is significant. It allows for the publishing of information about the variable and its source. This information has two forms: a verbose form (easily humanly readable) and a concise form (only readable by geeks). If ShowWhere[0] is a capital letter, the verbose form is used; otherwise the concise form.
There are three English letters accepted for ShowWhere[0]. (If none of these, or if the argument is scalar, nothing is shown, though of course the function still returns the variable as explained above.)
<bullet>'R', 'r' -- publish the report in the Results Window.
<bullet>'D', 'd' -- display the report in a dialog box.
<bullet>'M', 'm' -- put the data into an internal buffer, which you can then access using function 'iomessage()'. (This is usually used for returning messages relating to file I/O operations.)  ( The related function 'iok()' would return 'true' if accessed, though that would be rather pointless to do.)
The <i>verbose</i> message is self-explanatory. The <i>concise</i> message is more arcane. An example of the concise message would be: "foo::/home/fred/MonoMaths/Temp/aaa.txt::1768::63543038048" - where 'foo' is the name of the variable as it was in the given program ("/home.../fooltxt"), and where '1768' is how long ago the data was saved, in seconds. The final large number is the actual time of the save, as Mono (and .NET also) codes it.
<B>ceiling</B>(<# blue>Variable [, scalar NoDecDigits]<# black>) -- If only one argument, gives the first integer which is at or greater than Variable. If a second argument is present, it gives the nearest number at or above Variable of that precision. E.g. 'ceiling(1.234,1)'  returns 1.3; 'ceiling(-1.234,1)'  returns -1.2.  Negative numbers are allowed: 'ceiling(5.7, -1)' returns 10.
NB:  Internal numerical handling errors can cause unexpected results; e.g. if x, the result of a division, should theoretically be 1 but in fact is 1.000...001 due to such errors, then  the theoretical value of ceiling(x) would be 1 but the actual value would be 2.
<B>chain</B>(<# blue>variable Segment, scalar OutputLength<# black>) -- produces a list array which replicates Segment until length OutputLength is reached. If OutputLength is ridiculous (0 or negative), returns scalar 0 instead. If Segment is an array, its structure is ignored, but its character status is passed on to the output array.
<B>chainrows</B>(<# blue>variable Row, scalar NoRows<# black>) -- nonvoid; produces a matrix of NoRows rows, all being copies of Row. If Row is scalar, the output matrix will be a column vector (as would also occur if Row were an array of length 1). The structure of Row is not referenced. An error is raised if NoRows < 1.
<B>chaincols</B>(<# blue>variable Column, scalar NoColumns<# black>) -- analogous to the above.
<B>charpoly</B>(<# blue>Matrix [, scalar virtZero]<# black>) -- returns the characteristic polynomial for an NxN square matrix (must be at least 2x2). The polynomial is returned as an array of length N+1, being coefficients in ascending order of power. The coefficient for the highest power is always +1. if 'virtZero' is supplied and is positive nonzero, polynomial elements with absolute value of this or less are equated to zero.
<B>chars</B>(<# blue>Any no. of arrays<# black>) -- The array is registered internally as representing a string of  chars. This has no effect whatever on any aspect of array behaviour other than how it is handled by  screen input/output functions ('write', 'writeln', 'show', and 'input'), which will convert its contents to unicode characters and display them. Try this code:
\t"arr = data(65,66,67);  writeln(arr);  chars(arr);  writeln(arr);"  The result will be two lines: "65, 66, 67" and "ABC". After the internal flag is set, 'write(.)' et al will interpret the array as a string of characters.
The function 'unchars(Arr)' returns the flag to the default state ('off'). Both functions can take any number of arguments. (Scalar arguments, if included, would not cause a crash; they would simply be ignored.)
<B>checkdirectory</B>(<# blue>DirectoryName [, bool AllowFileName] <# black>) -- returns TRUE if this directory exists AND if it is accessible; otherwise FALSE. (For example, in Ubuntu the root directory "/" will return false because MonoMaths does not have privileged access to it.) The 2nd. argument is important; if it is absent or FALSE, then the function looks for a terminal '/', and if it does not find one, it adds one. If TRUE, no such adding occurs; if there is anything after the last '/', it is taken as file name and so is ignored. (If it is in fact a directory name, it is still ignored, and the outcome will depend on whether its parent directory exists.)
Abbreviations allowed in DirectoryName: (a) "~/" --> user's personalized home folder, e.g. "/home/fred/";  (b) "./" refers to the current directory; (c) "../" refers to the parent of the current directory.
<b>chooseclr</b>(<# blue>array InputColour, array OutputType<# black>) -- Displays an interactive colour choosing dialog - the initial colour being as set by <i>InputColour</i> - and returns the final colour choice in the format set by <i>OutputType</i>. The dialog is exactly the same as you get with main menu item "Appearance | Colour Selector", so you may care to experiment with that first.

<i>InputColour:</i>  This can be one of:
<bullet>An array of size 3, values 0 to 255, which represents R, G, B values;
<bullet>A recognized colour name;
<bullet>Six hex digits as a string.
If InputColour is wrongly formatted the dialog box tells you so, but still allows you to make a new colour choice.

<i>OutputType:</i>  This must be EXACTLY one of these three words (case-sensitive):
<bullet>"hex" -- in which case the return will be a chars. array of length 6 - e.g. for red:  "FF0000".
<bullet>"bytes" -- the return is a nonchars. array, size 3; e.g. for red: [255, 0, 0].
<bullet>"verbose" -- e.g. for red, the return would be: "Chosen colour:  FF0000    (255, 0, 0)    'red'.     Text example: <# red>ABCDEFG<# black>".
CANCELLATION of the dialog, either by the CANCEL button or by corner icon closure, returns the 'empty' array [NaN], for which you test using function 'empty(.)'.
<B>choosefilename</B>(<# blue>DirectoryName [, scalar AllowMultipleFileChoice]<# black>) -- Opens a file dialog box at the given directory, and offers a choice of file (or of multiple files, if the second argument is present and TRUE). Returns a chars. array, the chosen file name (with its full path). If more than one file name was chosen, names are delimited by the character '#'. If no file is chosen (i.e. the user cancelled the file browser display), an array of one space is returned. No errors raised. DirectoryName: only text up to the last '/' is used; whatever follows is ignored, even if a valid directory name. If part of DirectoryName is invalid, the file browser opens at the latest valid part of the name. If the whole of DirectoryName is garbage, the browser opens where it wills.
Abbreviations allowed in DirectoryName: (a) "~/" --> user's personalized home folder, e.g. "/home/fred/";  (b) "./" refers to the current directory; (c) "../" refers to the parent of the current directory.
<B>clear</B>(<# blue>Var1, Var2, ...<# black>) -- void function, taking any number of arguments, which must be valid variable names. Whether the variable is scalar or an array, all of its data values are replaced by 0. No change is made to array structure. See also 'kill(.)'.
<B>clip</B>(<# blue>Scalar LowerLimit, Scalar UpperLimit, Variable Values<# black>) -- returns a copy of 'Values' (whether scalar or array), in which all values above UpperLimit are replaced by UpperLimit, and all values below LowerLimit are replaced by LowerLimit. If you want a lower limit but not an upper limit, replace UpperLimit by <I>any</I> array; e.g. "clip(-2, "none", arr);". Similarly replace lower limit by any array if you want only an upper limit.
<B>clipabs</B>(<# blue>Scalar LowerLimit, Scalar UpperLimit, Variable Values<# black>) -- similar to the above. returns a copy of 'Values' (whether scalar or array), in which all values with absolute value above UpperLimit are replaced by  <& 177>UpperLimit, and all with absolute values below LowerLimit - including zero itself - are replaced by <& 177>LowerLimit. (The signs of UpperLimit and LowerLimit are ignored; their absolute values are used.) If you want a lower limit but not an upper limit, replace UpperLimit by <I>any</I> array; e.g. "clip(-2, "none", arr);". Similarly replace lower limit by any array if you want only an upper limit.
<B>clipcull</B>(<# blue>Scalar LowerLimit, Scalar UpperLimit, Array Values [, bool CullValuesAtLimits ]<# black>) -- returns a copy of 'Values' in which all values above UpperLimit and below LowerLimit are removed. If you want a lower limit but not an upper limit, replace UpperLimit by <I>any</I> array; e.g. "clipcull(-2, "none", arr);". Similarly replace lower limit by any array if you want only an upper limit. If the final argument is supplied and is nonzero, values at LowerLimit and at UpperLimit will be
culled; the default is that they remain. If the theoretical result of this function would be an empty array, instead an array of size 1, value NaN is returned, and a call to 'empty(.)' would return 'true'.
<B>clipcullabs</B>(<# blue>Scalar LowerLimit, Scalar UpperLimit, Array Values [, bool CullValuesAtLimits ]<# black>) -- exactly as for <i>clipcull(.)</i>, except that array elements are culled if their <i>absolute</i> value is greater than the absolute values of the supplied limits.
<B>clipboard</B>(<# blue>variable Dummy [, variable DataToStore ]<# black>) -- The first argument is not analysed, but we suggest "get" (one-argument version) and "set" (two-argument version).
The <i>one-argument form</i> simply retrieves any character string stored on the clipboard, as a chars. array: <# blue>ss = clipboard("get")<# black>. (If there is nothing there, the "empty" array is returned - an array of length 1, value NaN, which returns true to function 'empty').
The <i>two-argument form</i> is VOID; it puts the second argument into the clipboard. If that argument is a chars. array, it is stored directly as a string; if a numerical array or scalar, it is first converted to a string (arrays using the delimiter ", ") and then stored.
<b>cluster(<# blue>char array Action,  matrix Map,  bool IncludeDiagonallyTouchingBoxes, ...<# black>)</b>.  Non-void; returns a structure of the same type and chars. rating as 'Map'. Detects either a single cluster or all clusters of some given value within Map. See Hints for details and examples (i.e. key F1 on 'cluster' in the Assignments Window).
<B>cofactor</B>(<# blue>SquareMatrix, scalar PivotRow, scalar PivotColumn [, scalar DontApplySign]<# black>) -- returns the cofactor of the input matrix; that is, the determinant of the submatrix made by removing the indicated column and row; the determinant is then multiplied by (-1)^(PivotRow + PivotColumn). If the final argument is present and nonzero, this multiplication does not happen (that is, the 'minor' of the matrix is returned, not the 'cofactor'). SquareMatrix must be at least 2x2.
<B>colop</B>(<# blue>matrix Mx, scalar ColNo, scalar Coeff1, array isRowOrCol1, scalar RCNo1 [, array Sign, scalar Coeff2, array isRowOrCol2, scalar RCNo2] <# black>) -- VOID. Replaces the column ColNo in the Matrix with data, derived as follows. Suppose Coeff1 is 10, isRowOrCol1 is 'C' (for 'column'), RCNo1 is 2 (for column no. 2). Then for the 5-argument version, we would replace Mx[ ][ColNo] with 10*Mx[ ][2]. Continuing on with the 9-argument version, Suppose Coeff2 is 100, isRowOrCol2 is 'R', and RCNo2 is 3. (This would have to be a square matrix, if we are combining a row and a column.) Finally, suppose 'Sign' is '-'. Then column Mx[ ][ColNo] would be overwritten by:  10*Mx[ ][2]  -  100*Mx[3].
\t<I>isRowOrCol1</I>:  Only the first char. is examined. 'R','r' tells us that RCNo1 is a row no; 'C','c' that it is a column no. Any other value - e.g. a space ' ' - will generate a row or column of appropriate length but containing all ones; in effect, you will be replacing every value in Mx[ ][ColNo] with Coeff1. This is fairly pointless for the first term, but more useful for the second term, where for example you want Mx[ ][ColNo] to be replaced by (Coeff1 * column1 + a constant, Coeff2). If you use this option, then you can use any value for RCNo1 (or RCNo2), as it is not accessed.
\t<I>Sign:</I>:  Only recognized ones are " + - * / "; any other crashes. There is no test, in the case of division, for zero in the divisor; you have to precheck that in the rare situation where you would want to use this sign.
\tThere is no adjustment for errors in arguments; any error of any sort will crash.
<B>colvec</B>(<# blue>One or more variables or literals<# black>) -- returns a column vector which contains whatever data is between the brackets. For example, 'Arr = colvec(1.23, "ABC", x)' - where 'x' is a scalar holding value 2.34 - will return column vector [1.23, 65, 66, 67, 2.34]. If one element of the list is itself an array, all its elements will be inserted into Arr. Note that you can include characters and character strings between single or double quotes; the unicode value (converted to an integer) will go into the LHS array. <I>Related functions taking the same arguments:</I> 'rowvec(..)' returns a row vector; 'data(..)' returns a list array; and 'matrix(NoRows, NoCols [, ...] )' returns a matrix.
<b>commandline(<# blue>bool AsListArray<# black>)</b> -- retrieves the command line arguments. If the argument is TRUE, the different elements of the command line (as parsed by C#) are concatenated with a space between them; the result should look the same as the original command line, except for removal of duplicated spaces. If the argument is FALSE, the string array result of C# parsing is passed on to you as a jagged matrix (the pad character being the space). If doing so, realize that what are to MonoMaths single command line elements (like "top = 20;") will be broken up into separate 'arguments' by C#, which sees the space as a delimiter (so successive matrix rows would contain "top", "=", "20;").
To find out how command lines should be formatted for MonoMaths, put 'command' into the Assignments Window and click F1.
<B>compare</B>(<# blue>Array1, Array2 [, Scalar CutOff [, Scalar FirstPtr [, Scalar Extent] ] ]<# black>) -- compares two arrays, and returns an array of length 9, holding statistics re the differences. No notice is taken of array structure; only the data is compared. If CutOff is supplied, any difference below that level will be ignored in the calculation of all parameters.
If the last two pointers are missing, the extent used for comparison will be the length of the shorter of the two arrays. If one or both extent arguments are supplied, they must indicate a range which is contained in both arrays.
\t<B>Statistics:</B> In what follows, the ith. divergence is calculated as Array1[i] - Array2[i]. Also, all elements except [0] below apply only to differences within the extent as defined above.
Returned array elements: [0] is the difference in array lengths (first - second); [1] points to the first divergence; [2] points to the last divergence (both are -1, if no differences); [3] is the maximum positive difference; [4] is the maximum negative difference; [5] is the maximum absolute difference; [6] is the average difference; [7] is the average <I>absolute</I> difference; and [8] is the root-mean-square of differences.
<B>compareto</B>(<# blue>Array1, Array2, Scalar CutOff, Scalar FirstPtr, Scalar LastPtr<# black>) -- differs from the above only in that all arguments must be supplied, and in that the last argument states the last position in the extent.
<B>complex</B>(<# blue>Array1,  Var2,  Array Operation, Array PolRect [, scalar VirtualZero]<# black>) -- Do a complex mathematics binary operation between two variables. 
A word first about complex numbers: There is no special complex format in <I>MonoMaths</I>; instead, in functions dealing with complex numbers, every element of an input or output array with an even index (i.e. element [2n], n zero or integer) is 'real', and every element with an odd index ([2n+1]) is 'imaginary'. So to represent the array [1+j.2,  3 - j.4,  - 5 + j.6]  you would use the array [1, 2, 3, -4, -5, 6]. This is true if the array is regarded as being in 'rect' form. If instead it is regarded as being in 'polar' form, then elements [2n] represent absolute values and [2n+1] represent phase angles.
For this function, Array1 is such an array, and Var2 is one of: a scalar; an array of size 2, hence representing a single complex number; or an array of the same size as Array1. 'Operation' is an array with at least one element (no other is accessed); Operation[0] must be one of: '+', '-', '*', '/', '^'. It is the binary operation which applies between Array1 and Var2. Finally, PolRect is an array which describes whether variables are in polar form (i.e. element [2n] is an absolute value, [2n+1] is an angle) or rectangular form (each complex number being ([2n] + j.[2n+1]). PolRect entries can be either 'P' (or 'p') for 'polar', and 'R' (or 'r') for 'rectangular'. This array must have length of at least 3 (only the first 3 are accessed). [0] applies to Array1, [1] applies to Var2, [2] applies to the format of the output array of this function.
If Var2 is an array of the same size as Array1, then the operation is carried out separately between each matching pair of complex numbers in the two arrays. If Var2 is a single complex number (i.e. an array of size 2), every complex number in Array1 is operated on with the one complex value in Var2. If Var2 is scalar, say of value 'x', the effect is exactly the same as if it were the complex number 'x + j.0' (or if in polar form, 'x angle 0'.).
Finally, the argument VirtualZero is a small value - for example, 1e-10; any element in any input or output array of the function which has an absolute value smaller than this is converted to exactly 0. This should usually be used, especially if PolRect forces internal conversions between rect. and polar forms.
Here is a single example; others may be found by entering 'complex' in the assignments window and then keying F1.
<# blue>cxarr1 = data(1, 2, 3, 4);     cxarr2 = data(0.1, 0.2, 0.3, 0.4);
<# blue>cxarr3 = complex(cxarr1, cxarr2, '+', 'RRR');  <# magenta>// all arrays are in rect. form.
<# black>The output array will be: [1.1,  2.2,   3.3,  4.4].
See also functions <B>rect(.)</B> and <B>rect(.)</B>, which convert between polar and rect. forms, and <B>merge(.)</B>, which builds a complex array from two variables, one representing the 'real' values and one the corresponding 'imaginary' values.
<I>Errors that crash:</I> (1) In an array imputed to be 'polar' by PolRect, if a [2n] value is negative. 
(2) Attempt to divide by a complex number with absolute value 0. (3) If the operation is '^' and Var2 has any nonzero imaginary component[s].
<B>convolution</B>(<# blue>array Fn1, array Fn2, scalar XStep<# black>) -- computes the convolution of the two discrete functions represented by arrays Fn1 and Fn2 (which must have equal length). Suppose that the horizontal axis of the functions' graph is scaled in x. And suppose that the scaling of this X axis is such that for element Fn1[0], the value of x is Xmin, and for the last element of Fn1 the value of x is Xmax. Then the continuous equivalent of the convolution calculated here is
\t<& 8747><v>Xmin<^>X</^>  Fn1(u)<B>.</B>Fn2(X - u) du,
where 'X' takes every value from Xmin to Xmax. As a consequence, the returned convolution array will have the same length as Fn1 and Fn2.
'XStep' is the difference{ (X at Fn1[n+1]) - (X at Fn1[n]) }.
<B>copy</B>(<# blue>Array, Scalar (start point), [Scalar (extent)]<# black>) -- copies an extent of an array, producing a list array (i.e. not copying the structure of a structured array). If 'extent' is missing, the rest of the array is copied. E.g. for Arr = [0, 2, 4, 6, 8, 10, 12], 'copy(Arr,2,3)' produces [4, 6, 8], while 'copy(Arr,4)' produces [8, 10, 12].  <I>Silly arguments:</I>  see next function ("copyto(.)").  See also 'copyto(.)' and 'between(.)'.
<B>copyto</B>(<# blue>Array, Scalar (start point), Scalar (end point)<# black>) -- copies the argument array from start point to end point inclusive, producing a list array (i.e. not copying the structure of a structured array). E.g. for Arr = [0, 2, 4, 6, 8, 10, 12], 'copyto(Arr,2,3)' produces [4, 6]. It is not an error for 'end point' to be beyond the end of the string; it is internally backsized to the end of the string.
<I>Silly arguments for the above two functions:</I>  It is safe to make 'extent' (or 'end point') oversized, as it will be automatically downsized to include the rest of the array. Also, a negative start point is reset to 0 (the beginning of the array). After these adjustments, any situation which would return a sensible array does so (as just explained). But if it would logically return an empty array (e.g. crossed pointers, or extent <= 0), it in fact returns an array of size 1 and content NaN, and a call to system function 'empty(.)' will return true:
\t<# blue>subarr = copy(arr, 5, x);   if (empty(subarr ) ){ show("Oopsie!");  exit; }; <# magenta>// True, if x <= 0.<# black>
  See also 'copy(.)' and 'between(.)'.
<B>copymx</B>(<# blue>Matrix, Scalar  FirstRow, Scalar  FirstColumn [, Scalar NoRows [, Scalar NoColumns] ]<# black>) -- returns a submatrix copied from Matrix. Unlike with function "copy(.)", there is no adjustment of arguments; they must be consistent with the dimensions of Matrix. If NoRows is omitted, all rows to the end of Matrix will be included; likewise if NoCols is omitted, all columns to the last column of Matrix will be included.
<B>copymxto</B>(<# blue>Matrix, Scalar  FirstRow, Scalar  FirstColumn, Scalar LastRow, Scalar LastColumn<# black>) -- returns a submatrix copied from Matrix. Unlike with function "copyto(.)", there is no adjustment of arguments; they must be consistent with the dimensions of Matrix.
<B>copyrows, copycols</B>(<# blue>Matrix, Scalar  FirstRow/Column), [Scalar Extent]<# black>) -- copies designated rows / columns from Matrix into a new matrix of appropriate size, which is returned. Unlike with function "copy(.)", there is no adjustment of arguments; they must be consistent with the dimensions of Matrix. If Extent is omitted, all rows / columns from FirstRow/Column will be copied.
<B>copyrowsto, copycolsto</B>(<# blue>Matrix, Scalar  FirstRow/Column, Scalar LastRow/Column<# black>) -- differs from the above only in that the final argument is not an extent but instead states the last row or column to be copied. As above, there is zero tolerance of argument mismatches.
<B>copyshape(..)</B> -- function for duplicating an existing shape plot. Enter the function name into the Assignments Window and key F1 for details.
<B>correlation</B>(<# blue>array Fn1, array Fn2, scalar XStep, variable XOffset [,FirstIndex [, LastIndex ] ]<# black>) -- computes the correlation integral for discretized functions Fn1 and Fn2; that is, 
\t<& 8747><v>a<^>b</^>  Fn1(x)<B>.</B>Fn2(x + XOffset) dx 
(Note the '+' sign. You must adjust the sign of XOffset if you want a minus sign there.)
Fn1 and Fn2 must be arrays, though not necessarily of the same length. (The algorithm regards Fn2 as having an infinite extent of indices from minus infinity to plus infinity, all array values for out-of-range indices being zero.) XStep is the approximation to 'dx' of the above integral, being the X-axis distance between Fn1[n] and Fn1[n+1]. If XOffset is scalar, a scalar value is returned; if XOffset is an array, an array is returned, with correlation value [n] corresponding to XOffset[n].
'FirstIndex' and 'LastIndex': Normally the range of integration will be over the full extent of Fn1. (In the integral shown above, 'a' is the X-value of Fn1[0], 'b' the X-value of Fn1[last element].) If a smaller range of Fn1 is to be accessed, either or both of these may be set appropriately; but realize that they are <I>indexes</I> of Fn1, not X-axis scaled values. If either is supplied but is out of range for Fn1, it will be adjusted back to the start / end of Fn1. These two arguments do not raise errors; e.g. FirstIndex > LastIndex will simply return a correlation of 0.
<B>cos</B>(<# blue>Variable<# black>) -- the cosine of the variable (which is taken as being in radians). Inverse function: <# blue>arccos(..)<# black>.
<b>count</b>(<# blue>array Subject, array/scalar CountThis [, scalar StartHere [, EndHere ] ]<# black>) -- returns the number of instances of "CountThis" either in the whole of Subject (where there are just two arguments) or in the subarray of Subject which lies between pointers StartHere and EndHere inclusive.
Pointers out of range are adjusted back to the appropriate limit.
If timing is critical and "CountThis" is a single value, enter it as a scalar rather than as a one-valued array, as the search algorithm is then significantly faster.
<B>crash</B>(<# blue> One or more variables or literals <# black>) -- Raises an error, causing the program to crash. The error message (which is the function's arguments) is displayed in the Results Window. The arguments are handled exactly as for display functions such as <B>write(..)</B>.
<B>cull</B>(<# blue>Input Array, Unwanted Value [, Where To Cull]<# black>) -- removes all instances of 'Unwanted Value' from the indicated part of the array; the array is shortened by their removal. 'Where To Cull" determines which section of the array will be attacked: "R" or "r" for the 'right' (or high) end, "L" or "l" for the left end, "T" or "t" for both ends, and anything else (e.g. "A" and "a") for the whole array. Omission of the last argument also attacks the whole array.
'Unwanted Value' can be scalar or array; if array, the first element is taken as the unwanted value (the rest being ignored). 'Where To Cull' must be an array; again, only the first element is examined, so you can use longer versions - e.g. 'trim'.
The 'characters' rating of Input Array is transferred to the output array.
<I>NB: empty arrays are not allowed</I> anywhere in <I>MonoMaths</I>. If this function would logically generate an empty array, then instead it returns an array of length 1 and value NaN. A call to function 'empty(.)' will also return TRUE in this case.
Examples:
	<# blue>InArr = "###the##cat###";
	<# blue>writeln( cull(InArr, '#') );  <# magenta>// --> "thecat"
	<# blue>writeln( cull(InArr, '#', 'A') );  <# magenta>// --> "thecat"
	<# blue>writeln( cull(InArr, '#', 'L') );  <# magenta>// --> "the##cat###"
	<# blue>writeln( cull(InArr, '#', 'R') );  <# magenta>// --> "###the##cat"
	<# blue>writeln( cull(InArr, '#', 'T') );  <# magenta>// --> "the##cat"
	<# blue>InArr = "###";  writeln(cull(InArr, '#') );  <# magenta>// --> "NaN"
<# black>
<B>cullbykey</B>(<# blue>array Victim, array Key<# black>) -- Given any array Victim, and a second array Key of the same length, return all the values of Victim except for any values Victim[i] for which Key[i] is FALSE (i.e. exactly zero). If all elements of Key are FALSE, returns an array of size 1, value NaN, and a call to function 'empty(.)' will return TRUE.
<B>currentdirectory</B>(<# blue>array DirectoryName OR scalar Dummy<# black>) -- If the array is a scalar (any value), simply returns the current directory as a chars. array. If a valid directory name, sets the current directory to that name, and the function also returns that name. (This directory will then be the opening directory for e.g. loading and saving of files.) If an invalid directory name, no internal setting occurs, and an error message is returned. (You can distinguish between an error message and a returned path name in that the path name always begins with '/', and the error message always begins with a space character -- unicode 32.) 
Note that no abbreviations are allowed in DirectoryName; it must be a complete file path. If it does not already end in '/', a terminal '/' will be added before testing.
<b>cursorposn(</b><# blue> array Window [, scalar NewPosn ] <# black>)  -- Returns the current cursor position in the window specified (which must be 'A' for the Assignments Window, or 'R' for the Results Window; any other value will cause a return of -1). If NewPosn is \< 0, no movement occurs. If beyond the end of the text, it is reset to be at the end of text. (If you want to be sure that the cursor will move to the end of text, set NewPosn to something impossibly large, like MAXREAL). If this function has moved the cursor, the return value is its final position.
<b>cursordata(</b><# blue> [ bool Verbose ] <# black>)  -- Returns the text at the cursor, and optionally some more data. 
<i>Verbose</i> absent or FALSE:  Returns the text at the cursor as a list array, chars. rating. If there was a selection, then selected text is returned. If there was no selection, then a string of eligible characters (i.e. A..Z, a..z, 0..9, '_') is sought either touching or containing the cursor. If found, that string is returned; if not found (e.g. only space or punctuation marks on either side of the cursor), then a single space is returned (but never the 'empty' array).
<i>Verbose</i> present and TRUE: Returns a chars. array exactly as above, but with the following four extra elements at the end:
	[MAXREAL]  [pointer to first char. of the word, relative to the start of all text]  [ponter to last char. of the word]  [1, if there had been a selection; otherwise 0].
If no word could be found, the whole returned array is:  [SPACE] [MAXREAL] [-1] [-1] [0].
<B>curvefit</B>(<# blue>Array of X values, Array of Y values, Degree of fit polynomial<# black>) -- Fit a polynomial curve to a set of data, using the least squares method. An array of polynomial coefficients is returned (as usual, in ascending order of degree of term). Constraints: Degree must be 1 (for a straight line) or higher. The two arrays must be equal in length, and represent at least (Degree+1) points (no upper limit). NB: The points must be sorted such that X values are in ascending order, and no X values are duplicated.
<B>data</B>(<# blue>One or more variables or literals<# black>) -- returns a list array which contains whatever data is between the brackets. For example, 'Arr = data(1.23, "ABC", x)' - where 'x' is a scalar holding value 2.34 - will result in an array [1.23, 65, 66, 67, 2.34]. If one element of the list is itself an array, all its elements will be inserted into Arr. Note that you can include characters and character strings between single or double quotes; the unicode value (converted to an integer) will go into the LHS array. <I>Related functions taking the same arguments:</I> 'rowvec(..)' take the same arguments, but returns a row vector; 'colvec(..)' returns a column vector; and 'matrix(NoRows, NoCols [, ...] )' returns a matrix.
If instead of raw data you want to enter displayable text, use function <B>text(..)</B>.
<B>datetime</B>() -- returns an array of size 10 with the following information, taken from the computer clock at the moment when it is called: [0] = year (4-digit version); [1] = month (January = 1); [2] = calendar day of month; [3] = hour of day (0 to 23); [4] = minute of the hour; [5] = second of the minute; [6] = milllisecond of the second;  [7]  = day of week (0 is Sunday, 6 is Saturday); [8] = day of year (Jan 1st is 1); [9] = msecs. since start of 1 AD.
<B>dec</B>(<# blue>Variable<# black>) -- NOT void; both decrements the variable and returns the decremented value. (The value is rounded first.)
<B>decide</B>(<# blue>Three to six arrays, followed optionally by up to four scalars<# black>) -- Displays a box asking for a decision, and offering one to four buttons for a response. The arguments: (Heading Text, Body Text, Button1 Text [, Button2 Text [, Button3 Text [, Button4 Text ] ] ]   [, scalar Width [, scalar Height [, scalar Left [, scalar Top ] ] ] ). 'Left' and 'Top' apply to the top left corner; if they are missing, the box is centred on the screen. If any scalar is < 1, it is taken as being a fraction of screen width or height (as appropriate). Buttons appear from left to right in the order given.  Returned: 0 for corner icon closure; otherwise button no., from 1 up, in the order given.
An example:
\t<# blue> cntr = 1;
\t<# blue> while (true)
\t<# blue>{\theading = "LOOPING THE LOOP";   body = text("This is the ", nth(cntr), " loop.  Keep going?");
\t<# blue>\tn = decide(heading, body, "GO ON", "STOP"); <# magenta>// Keep the button texts short!
\t<# blue>if (n != 1)  break;  else cntr++;
\t<# blue>}
<# black>You may use a small number of markup tags in the Body Text; they must be strictly paired with their cancelling tags. These are: \<b> ... \</b>, \<u> ... \</u>, \<i> ... \</i>, \<^> ... \</^> (for superscript), \<v> ... \</v> (subscript).  (These are translated internally into Pango tags - which you would have to google, for details. You can actually use any other Pango tags, but I do not list them here.) 
<# black>
To set the size of the dialog box to other than the default, use function <b>setbox</b>.
<B>defrac</B>(<# blue>Variable<# black>) -- The whole part of the number. 'defrac(1.23)' and 'defrac(-1.23)' return respectively 1 and -1. (Caution: numbers between 0 and -1 return '0', not '-0'; i.e. in this interval, the sign of the no. and its defrac are not the same.) See also 'frac(..)'.
<b>defluff</b>(<# blue>NAMED variable Subject,  scalar VirtualZero<# black>) -- a VOID function. All elements in Subject which have an absolute value less than or equal to VirtualZero will be replaced by zero.
An error is raised if Subject is not a named variable.
If VirtualZero is zero or negative, no changes occur to Subject. Also if Subject is a constant, no error is raised, but also nothing happens.
<B>deg</B>(<# blue>Variable<# black>) -- converts the variable from radians to degrees. No cutoff values; for example, deg(4*PI) will return 720, deg(-4*PI) will return -720.
<B>delete</B>(<# blue>array Original,  scalar FromPtr [,  scalar Extent]<# black>) -- returns a list array which is a copy of Original, but with all data excised from FromPtr for extent Extent. (If that would mean all data was excised, instead the return is an array of size 1, value NaN; and a call to 'empty(.)' would return TRUE.)
If Extent is missing, all of the array from FromPtr onwards is omitted from the copy.  
If Extent exceeds the array length, all of the array from FromPtr onwards is removed. Negative or zero Extent, or FromPtr beyond the end, all return an unaltered copy of Original. If FromPtr is negative, behaviour is as if Original had a virtual extention with negative indices; that is, FromPtr of -n and Extent of n+k has the same effect as FromPtr of 0 and Extent of k.
The output array retains the "characters" setting of the input array, but is always a list array.
<B>deleteto</B>(<# blue>array Original,  scalar FromPtr,  scalar ToPtr<# black>) -- returns a list array which is a copy of Original, but with all data excised from FromPtr to ToPtr inclusive. (If that would mean all data was excised, instead the return is an array of size 1, value NaN; and a call to 'empty(.)' would return TRUE.) 
If ToPtr exceeds the array length, all of the array from FromPtr onwards is removed. If ToPtr is less than FromPtr, an unaltered copy of Original is returned. If FromPtr is negative, it is reset to 0.
The output array retains the "characters" setting of the input array, but is always a list array.
<B>deleterows</B>(<# blue>Matrix, Scalar FromRow, Scalar Extent<# black>)  OR  <B>deleterows</B>(<# blue>Matrix, Array WhichRows<# black>) -- returns a copy of Matrix, but with the indicated rows removed. (If all rows are marked for deletion, a list array of size 1, value NaN, is returned, and an immediate call to function 'empty(.)' returns 'true'.) In the first case, an extent of contiguous rows is to be removed; in the second case, particular rows anywhere within the matrix.
Faulty 2nd. and 3rd. arguments do not raise errors. If  Extent <= 0, no deletion occurs. If FromRow is negative, rows from 0 to row (FromRow + Extent - 1) will be deleted. If FromRow is beyond the end of the matrix, nothing is deleted. In the second version, values out of range and duplicate values are simply ignored.
<B>deletecols</B>(<# blue>Matrix, Scalar FromCol, Scalar Extent<# black>) OR <B>deletecols</B>(<# blue>Matrix, Array WhichColumns<# black>) -- returns a copy of Matrix, but with the indicated columns removed. Behaves exactly as for 'deleterows(.)'.
<B>determinant</B>(<# blue>Square Matrix [, Scalar]<# black>) -- finds the determinant of the matrix. Warning! Don't go much larger than a 10x10 matrix or you might hang the computer. Experimentation will help find how high you can go with your computer. If you add in a second argument, it is the value below which tiny amounts are regarded as zero (for example, 1e-5). (Internal rounding errors will usually produce a tiny determinant where a zero determinant would be expected.)
<B>differences</B>(<# blue>array Arr<# black>) -- returns a list array consisting of the differences between successive elements of Arr, and therefore of length one less than the length of Arr. As an example, if Arr is [ 1, 10, 100, 1000 ], the returned array would be [ 9, 90, 900 ]. (If Arr has length 1, the 'empty' array [ NaN ] is returned.) 
<B>diffpoly</B>(<# blue>Array <the polynomial><# black>) -- produces the polynomial which is the input polynomial differentiated; e.g. if the input array is [1, -2, 3], representing 3X^2 - 2X + 1, the function will produce [-2, 6], representing 6X - 2.
<B>dim</B>(<# blue><one or more arrays>, <one or more scalars><# black>) -- void; creates the arrays (or re-creates them, if they were created earlier), and fills them with zeroes. One scalar argument produces a <I>list array</I>: "dim(Arr,10)". Two or more produce <I>structured arrays</I> - "dim(Arr,1,4)" produces a row vector, "dim(Arr,4,1)" a column vector, "dim(Arr,3,3)" a matrix. Up to 5 dimensions are allowed. The scalar arguments are rounded before use.
<B>dimlike</B>(<# blue><one or more arrays>, array Model<# black>) -- void; creates the earlier arrays (or re-creates them, if they were created earlier), and fills them with zeroes. Each will have the dimensions of the final array Model, which must already have been declared.
<B>dims</B>(<# blue>Variable [, scalar IncludeZeroDims]<# black>) -- Returns an array holding the dimensions of the array (element [0] being the lowest dimension). If there is a nonzero second argument, all five allowed dimensions will be included, unused upper dimensions being represented as 0; otherwise, only nonzero dimensions are returned. Scalars return an array of length 1, content 0 (second argument ignored); this never occurs with an array.
<B>distance</B>(<# blue><Variable1, Variable2 [, bool DontTakeSqRoot [, bool DontTakeMean ] ]<# black>) -- If just two arguments, returns the root-mean-square of differences. Either the squaring or the taking of the mean can be avoided by including the relevant argument and setting it to TRUE.
Different deployments of the first two arguments give different results. Here are examples of the allowed argument structures. For simplicity, assume that the 3rd. and 4th. arguments are TRUE, so that only sums of squares are returned.
<u>Case 1:</u>  <# blue>scalar x1, scalar x2<# black>:  A scalar is returned, with value (X1 - X2)<^>2</^>.
<u>Case 2:</u>  <# blue>scalar x, array A<# black>: A scalar is returned, with value {  (X - A[0])<^>2</^>  +   (X - A[1])<^>2</^> + ... } (through all the values in A).
<u>Case 3:</u>  <# blue>array A, array B (same lengths)<# black>: A scalar is returned: {  (A[0] - B[0])<^>2</^>  +   (A[1] - B[1])<^>2</^> + ... } (through all the values in A and B).
<u>Case 4:</u>  <# blue>array A, matrix M<# black>: the length of M's columns must be the same as the total length of A. An array is returned - call it 'Result' - such that for each row of M there is a value;  Result[i] = {  (A[0] - M[i, 0])<^>2</^>  +   (A[1] - M[i, 1])<^>2</^> + ... } (through all the values in A and M[i]).
<b>distpoints</b>(<# blue>X1Values [, Y1Values [, Z1Values ] ],  X2Values [, Y2Values [, Z2Values ] ]  [,  bool DontTakeSquareRoot] <# black>) -- (All arguments are arrays, even if they only represent a single point.)  X1... represent coordinates of one set of points in 1-, 2- or 3-dimensional space; X2... represent coordinates of another set of points in the same space. The returned matrix will have dimensions (no. points in first set  <b>X</b>  no. points in second set). For 1 dimension, values will be signed, as result[i,j] = X2Values[j] - X1Values[i]; and DontTakeSquareRoot, if present, is ignored. For 2 or 3 dimensions the Euclidean distance applies; the square root is taken unless there is a final scalar arg and it is TRUE.
<b>distmutual</b>(<# blue>XValues [, YValues [, ZValues ] ]    [, bool DontTakeSquareRoot [, bool FillWholeMatrix] ]<# black> ) -- caters for points in 1, 2 or 3 dimensions. Returns a matrix of mutual distances. If there are N points, its size will be NxN. Normally only the top/right triangle of the matrix is filled, the other triangle being all zeroes. If the final argument is TRUE, then the lower triangle is also filled. In all cases, of course, the main diagonal consists of zeroes.
For 2 or 3 dimensions, the distance between point i and j (j > i) is placed into the returned matrix as element[i, j]. The distance is the square root of the sum of the squares of the coordinate differences, i.e. the Euclidean distance. If 'DontTakeSqRoot' is present and true, the sum of the squares is returned instead. If 'FillWholeMatrix' is true, the lower triangle will be exactly equivalent to the upper triangle (result[i,j] = result[j,i]). 
For 1 dimension, simple subtraction is used, element [i,j]  (j > i)  being Xvalues[j] - Xvalues[i]. If 'FillWholeMatrix' is true, the lower triangle values will be of opposite sign: result[i,j] = ‒result[j,i].
<B>divmod(X,Y)</B> -- If X is scalar, returns the list array [X div Y,  X mod Y]. If X is an array of data length L, returns a matrix of L rows, row i being [ X[i] div Y,  X[i] mod Y ]. The sign of X is preserved, if Y is positive.
<B>div</B>(<# blue>Variable, Scalar<# black>) -- div(x,y) gives the integral part of the result of division. Values are rounded before division. (The sign of the result is as would be expected for the division, if y is positive.)
<B>divmod</B>(<# blue>Variable X, Scalar Y<# black>) --  If X is scalar, returns the list array [X div Y,  X mod Y]. If X is an array of data length L, returns a matrix of L rows, row i being [ X[i] div Y,  X[i] mod Y ]. The sign of X is preserved, if Y is positive.
<B>dot</B>(<# blue>Array, Array<# black>) -- returns a scalar, the dot product of the structures (i.e. the sum of the term-by-term multiplication of the arrays). The arrays must have the same length; however their dimensioning is irrelevant, not being referenced by the function. 
<B>downsample</B>(<# blue>Array, Scalar DownsamplingRate[, Scalar StartPtr[, Scalar EndPtr]]<# black>) -- Suppose StartPtr and EndPtr are left out. Then what happens is this: the first element and then every (DownsamplingRate)th. element is retained. E.g. for input array [0,1,2,3,4,5,6,7] and rate 3, the return is [0,3,6]. If StartPtr is > 0, then all before it is retained untouched, and the retaining count starts at StartPtr.  (For the above, with StartPtr 2, the return would be: [0,1;  2, 5].)  Also, all values after EndPtr (if supplied) are retained.
The structure of Array is ignored; its data is treated as if it were a list array.
StartPtr can be negative, in which case downsampling notionally starts from that negative index, even though the input array is not referenced till its index has incremented to 0. This is useful if you want the downsampled array to start with Array[p] (where 0 < p < downrate) rather than with Array[0]. To achieve this, set StartPtr to (p - downrate).
Excessive EndPtr is trimmed back to the end of the input array. Crossed pointers is an error, as is a rate below 1 (though 1 is allowed, trivially returning the array untouched).
<b>empty(scalar / array Subject)</b> returns TRUE if every value in Subject is NaN. For a scalar, that means that it is NaN; for an array of any length and structure, it means that all elements in the array are NaN.
<B>equal</B>(<# blue>Array1, Array2,  scalar / array HowFar<# black>) -- If the two arrays are exactly equal for the indicated extent, then TRUE is returned; otherwise FALSE. No other information is given.
The extent for comparison is indicated as follows.
<bullet>If HowFar is scalar, it is the extent of comparison, taken from the starts of the arrays. For example, the two arrays "abcd" and "abcx" would return TRUE for HowFar = 3 but False for HowFar = 4. If HowFar is negative or zero, or if it exceeds the length of Array1, then it is set to the length of Array1.
<bullet>If HowFar is an array, then it is sought in Array1 (only). If found, the extent will be the length of data in Array1 to before the find. For example, if HowFar is "?", and Array1 is "abc?d", then TRUE would be returned for Array2 = "abcx". 
<B>errortrap(..), errormsg(..), errorcnt(..)</B> -- With rare exceptions, errors arising from system function calls during runtime crash your program. You can prevent this (in nearly all cases) with error trapping. Errors in a passage of code between error trap ON and error trap OFF will be recorded, but the code will try to soldier on despite the errors (no doubt leading to more errors). You can afterwards (or during) find out how many errors occurred by calling 'errorcnt()'. The cumulated error messages (separated by paragraph breaks) can be read using 'errormsg()'. (If no errors, errormsg() returns an array consisting of a single space " ").
\tNB - only errors raised by MonoMaths will be trapped; errors detected  instead by .NET will NOT be trapped. Also, note that if a system function detects an error, it will return a scalar of the value which you supplied as an argument in errortrap(.) - as by the variable 'oopsie' in the example:
\t<# blue>oopsie = 1.23e101; <# magenta>// any improbable no. will do. (Avoid zero, as
\t<# magenta>//   assignments from erratic fns. will acquire the value of 'oopsie' - 
\t<# magenta>//   division by zero may then occur in subsequent code!) 
\t<# magenta>// TURN ERROR TRAPPING ON:
\t<# blue>errortrap('on', oopsie); <# magenta>// you don't need to access 'oopsie' again.
\t<# blue>x = sqrt(-1); <# magenta>// Oops! 'sqrt' can't handle the square root of a negative no.
\t<# magenta>//   Error recorded, and the RHS 'x' will take on the value of your 'oopsie'. 
\t<# blue>dim(arr,3);  arr[4]=9; <# magenta>// Oops! Array index is out of range.
\t<# magenta>// RETRIEVE ERROR DATA: We can only get this data here, as this data 
\t<# magenta>//  will be erased after the "errortrap('off')" call below.
\t<# blue>writeln("No. of errors = ", errorcnt());<# magenta>// errorcnt() --> a scalar no.
\t<# blue>writeln("The errors were:",10, errormsg());<# magenta>// errormsg() --> array of chars.
\t<# magenta>// TURN ERROR TRAPPING OFF:
\t<# blue>errortrap('off');
\t<# magenta>// errorcnt() would now return '0', and errormsg() would return "".<# black>

\tThe display will read:
	<# blue>No. of errors = 2
	The errors were:
	Error 1: 'sqrt': negative argument not allowed
	Error 2: receiving array has an oversized dimension<# black>

<B>evalpoly</B>(<# blue>Array <the polynomial>, Variable X<# black>) -- Evaluate the polynomial represented by the first argument, using the 'X' (independent variable) value(s) of the second argument. Case 1 - 'X' is scalar: returns a scalar evaluation for this real number. Case 2 - 'X' is an Nx2 matrix: returns an Nx2  matrix, which are N complex evaluations for the set of N input complex numbers. Case 3 - 'X' is any other sort of array: it is regarded as a list of real numbers, and an equally large list of evaluations is returned.  
\t The <I>polynomial</I> is coded as a list array, with the highest degree coefficient coming last. E.g. for the quadratic '7X^2 - 3X + 2', the polynomial array would be: 'polly = data(2, -3, 7);'. A single <I>complex number</I> is represented as a 1x2 matrix, [0,0] being the real component and [0,1] the imaginary component.
<B>even</B>(<# blue>Variable [, Scalar: divisor]<# black>) -- A quasi-boolean function, returning 1 for TRUE and 0 for FALSE. Arguments are rounded before testing. Case 1 - no 2nd. argument: If the first value (rounded - should be very close to integral) is even, 1 is returned; otherwise 0 is returned. Case 2 - a divisor is supplied (which must be a positive integer, 2 or higher): returns 1 if it exactly divides the argument, or 0 otherwise.
<B>evict</B>(<# blue>SourceArray, IndicesArray<# black>) -- returns a list array consisting of all entries in SourceArray <I>except</I> those indicated in IndicesArray. (Hence it is the converse of <i>select(.)</i>.) The second argument lists the selected indices of SourceArray. The structure of SourceArray is important; sets of values in IndicesArray must constitute valid indices for its locations. For example, if SourceArray is an MxN matrix, with rows m (0 <= m < M) and columns n (0 <= n < N), then the format would be: <# blue>arr = select(SourceArray, data(m1, n1, m2, n2, ...) );<# black> this would return a list array: [SourceArray[m1,n1],  SourceArray[m2,n2], ...). The structure of IndicesArray is ignored; it would usually be a list array, but for the above example could also be a matrix with two columns, column 0 for M values and column 1 for N values, as the internal data strip would then have the same values in the same order as would the corresponding list array version of IndicesArray.
It is possible for IndicesArray to refer to every entry in SourceArray; in this case, the function returns the 'empty' array of size 1, content NaN; and a subsequent call to function 'empty(.)' would return TRUE.

<b>exec(.)</b> -- runs an application in much the same way as you would do from the terminal command line. It has two forms, which differ only in the way in which the arguments are presented.
<u>Form 1</u>: <B>exec</B>(<# blue>array CommandLineEntry [, scalar WaitMsecs ] ]<# black>) -- The whole command, as you would enter it at the command prompt in a terminal, is contained in the chars. array <i>CommandLineEntry</i>.  There are no checks; everything before the first space is regarded as being the application name ( + path, if no environment variable stored for it), and everything after as the subsequent argument list.
<u>Form 2</u>: <B>exec</B>(<# blue>array FileName [, any no. of arrays Arguments [, scalar WaitMsecs ] ]<# black>) -- The file name this time is subject to checks. Each array that follows will become a command line argument, a space being inserted between consecutive arguments.
The <i>return</i> from the function depends on <# blue>WaitMsecs<# black>. If this is absent, the return is always 0, and the function does not wait around till the called process finishes. (This is appropriate especially where you are invoking another application which you want to persist.) If it is present and set to a value that rounds to greater than zero, then the function will wait around for the process to end for this length of time before giving up. Two returns are possible, if this argument is supplied (and is greater than zero): (1) If the process ends before time is up, then the returned value will be whatever exit code that process generated; (2) if the process did not end by then, this function gives up waiting and returns 999.
Only one abbreviation is allowed (and then only in Form 2), namely "~/" - for personalized home directory. If this is found <i>anywhere</i> within <i>any</i> argument, the home directory will be substituted for the abbreviation. If for some odd reason you don't want "~/" to be substituted in this way, precede it with a backslash (which will be removed by the function).
For the particular case where you want to <b>start another MonoMaths instance</b>, 'FileName' is just the word "mono", and the first argument is the path and file name of MonoMaths (e.g. "~/MonoMaths/MonoMaths.exe"). Omit <i>WaitMsecs</i> (as you want the instance to persist), and supply further arguments as follows:
(1) Just to open the instance: no further arguments.
(2) To dictate window sizes, and / or load or run a program in that instance, first set up a command line of arguments that would work if entered into a terminal (see the hint for "command" for this), and then enclose the whole command line in quote marks, inside the 'exec' function. Here is an example, which runs program "zzz.txt" in the new instance after resetting the size of the instance:
(a) The command line version (which would work in a terminal, or in a desktop link):
	<# blue>mono /home/jon/MonoMaths/MonoMaths.exe  L=0.115;T=0;W=0.75;H=0.94; run = `~/MonoMaths/Scripts/zzz.txt`<# black>
(b) The 'exec' version, developed from this:
	<# blue>exec("mono /home/jon/MonoMaths/MonoMaths.exe  L=0.115;T=0;W=0.75;H=0.94; run = `~/MonoMaths/Scripts/zzz.txt`");<# black>
Other useful functions: where you want to end an instance, <i>kill_on_exit()</i> (followed by 'exit') and (more drastic but more certain) <i>smash()</i>.
See also <i>run(.)</i>.
<b>exit_plus</b>(<# blue>array DoWhat [, FileName [, bool FormattedTextMode ] ]<# black>) -- causes the program to exit, but then invokes some extra stuff. 
<u>Action 1 -- simulate menu item "File | New" after the exit</u>
<i>DoWhat</i> is <# blue>"new"<# black> (case-insensitive). No other arguments accessed. NB - <i>No warning dialog box</i> appears to warn you if the prior Assignments Window text has unsaved changes, before it is cleared away.
<u>Action 2 -- simulate menu item "File | Load" after the exit</u>
As for 'action 1', <i>no warning dialog box</i> appears to warn you that the current text is unsaved and about to be overwritten.
<i>DoWhat</i> is <# blue>"load"<# black> (again, case-insensitive).
<i>FileName</i> behaves as with e.g. function 'load'. The abbreviation '~/' for personal home folder is allowed. If no path, path is assumed to be current directory. If a path but no file name, a file dialog box opens at the given folder. If FileName is empty (just spaces), or is scalar, the file dialog box opens at the current folder.
<i>FormattedTextMode</i>  -- if present and nonzero, the text will be displayed in formatted form, as if menu item "Appearance | Toggle Markup System" had been effected.
<b>Errors:</b> -- The current program ends in all cases, errors or not. However the existing program's text remains in the Assignments Window, if there is an error. Errors: (a) faulty DoWhat; (b) DoWhat is 'load', but there is only this one argument; (c) faulty or inaccessible file FileName.
If there was a dialog box, but the user cancelled out of it, then the existing text remains on view, and the appropriate message goes into the Results Window.
<B>exp</B>(<# blue>Variable<# black>) -- the exponential constant 2.71828... raised to the given power (or powers, if the argument is an array).
<B>expunge</B>(<# blue>InArray,  scalar or array Target [, scalar FromPtr [, scalar Extent]]<# black>) -- returns a copy of InArray in which all instances of Target have been removed which lie wholly within the limits set by FromPtr and Extent (or within the whole string, if they are absent). Always returns a list array. If the function call would logically remove all of InArray, the return is the 'empty' array - that is, an array of size 1, content NaN; subsequent call to "empty(returnedArray)" then returns TRUE. Error results from negative FromPtr or Extent; otherwise combinations of FromPtr and Extent which don't define extents of InArray will not raise an error, but will simply return InArray (as a list array).
<B>fact</B>(<# blue>Variable [, Scalar]<# black>) -- 'fact(n)' gives factorial n; 'fact(n,p)' gives factorial n divided by factorial p. Both n and p must lie between 0 and 169, with p < n. If fractional, they are rounded (see 'round(..)' re same).  ('fact(0)' evaluates to 1.) See also <# blue>logfact(..)<# black>.
<B>factors</B>(<# blue>value(s) contained in one or more variables<# black>) -- (1) <I>Single value:</I> 'factors(n)' returns a list array containing the prime factors of n, if n >= 2; otherwise NaN. Examples: 'factors(7)' returns 7 (in an array of size 1);  'factors(8)' returns '2, 2, 3' (in an array of size 3); 'factors(0)' or 'factors(-4)' returns an array of size 1, value NaN, which would return TRUE from a call to 'empty(.)'.  (2) <I>More than one value:</I> returns the factors <I>common</I> to all elements, or NaN (in an array of size 1) if none. 'factors(4,8,24)' returns '2,2'; 'factors(4,5)' returns 'NaN'.
<B>fft</B>(..) -- Fast Fourier transform; see <B>fourier(.)'</B>.
<b>filesize</b>(<# blue>PathAndName<# black>) -- Returns the file size, or -1 if unsuccessful (the file does not exist). Allowed standard abbreviations at the start of FileName: (a) "~/" --> user's personalized home folder, e.g. "/home/fred/";  (b) "./" refers to the current directory; (c) "../" refers to the parent of the current directory.
<B>fill</B>(<# blue>[Named Array,] <one or more scalars><# black>) -- fills an array with values according to a pattern. Can be void - 'fill(Arr,1,2);' - or nonvoid - 'Arr1 = fill(20,1,2)' (but not both: 'Arr1 = fill(Arr2,..)' fails.) The pattern is polynomial. Consider the polynomial 'A + B.n + C.n^2 + D.n^3 + ...'. The arguments represent these coefficients - 'fill(Arr, A,B,C,D,...)'. The values provided are the evaluations of the polynomial for n=0,1,2,3,... In the void case, n continues until all data space has been filled. In the nonvoid case, <I>the first argument is a size</I>, so that in the above example, Arr1 is (re)created with a size of 20, and n ranges from 0 to 19.
\tThe nonvoid form creates a list array. The void form does not alter the dimensional structure of the array passed to it, but the array must be entire, not e.g. a row; "fill(Mx[0], ...)" will not raise an error, but it will also not change the existing content of Mx.
\tNote that this function can be used to fill an array with a constant value - 'fill(Arr,10)' fills the array with '10' - or a linearly increasing set of values - 'fill(Arr,0,1)' fills the Arr with [0,1,2,3,...]).
<B>filter</B>(<# blue>InArray, scalar WindowWidth, scalar StepSize, array Mode<# black>) -- Non-void. A window is moved across the input array, to interact with it. The window will be linear if InArray is a list array, a square window if InArray is a matrix, or a cubic window if InArray has 3 dimensions. The window starts with its lowest element at the lowest element of InArray. If one thinks of InArray as represented by unit boxes in a 1D, 2D or 3D Cartesian system, the window moves along the positive X direction in jumps of StepSize until it can go no further (it is not allowed to overlap the right edge). Then if InArr has more than one dimension, it moves up the Y axis by the same StepSize, and repeats the process. And if it has three dimensions, then after completing one face of the cube the window moves to the lowest X and Y positions of the next face along the Z axis, with the Z coordinate advanced by StepSize.
The nature of the interaction depends on argument Mode. This is a new function, and so far only two modes are recognized:
<bullet>"average" -- the output datum is the average of all the data in the window.
<bullet>"maximum" -- the output datum is the maximum of all values in the window.
The <b><# blue>returned structure<# black></b> has the same dimensionality as InArray, but is smaller (except when both WindowWidth and StepSize are 1). In this structure, one value is entered for each position of the window.
<B>find</B>(<# blue>ArrayToSearch, scalar StartPtr, ...<# black>) -- Search the array for a given value or sequence, and return the index of the first find at or after StartPtr; or return -1, if no find. The structure of ArrayToSearch is ignored; the index is an absolute address in ArrayToSearch's data strip. (You can use function "address(..)" to translate this address into array coordinates.)
There are three possible forms: <# blue>find(ArrayToSearch, StartPtr, scalar Value)<# black> searches for the exact value; <# blue>find(ArrayToSearch, StartPtr, scalar LoValue, scalar HiValue)<# black> searches for the first value lying between (or at one of) the two limits - which, by the way, may be in any order (high limit before low limit is permitted). <# blue>find(ArrayToSearch, StartPtr, array Sought)<# black> looks for the first occurrence of the complete sequence of exact values in array Sought.
<B>finds</B>(<# blue>ArrayToSearch, scalar StartPtr, ...<# black>) -- Arguments exactly as for <B>find(..)</B>. The only difference between the two functions is what is returned; this function always returns an array of size 3: [0] is the number of finds (starting from StartPtr), [1] the position of the first find (or -1, if none), and [2] the position of the last find (-1, if none).
<B>findall</B>(<# blue>ArrayToSearch, scalar StartPtr, ...<# black>) -- Arguments exactly as for <B>find(..)</B>. The only difference between this and the above two functions is what is returned. This function returns an array made up of the indices of all finds. (You can create a parallel array of their values using the function 'select(.)'.) If there are no finds, an array of size 1 is returned, with [0] set to -1.
<B>findbrackets</B>(<# blue>Text, scalar Pointer, scalar or array Opener, scalar or array Closer<# black>) -- Intended for text, and only works properly if all relevant values can be coded to UFT8 characters. Opener represents one character, typically an opening bracket; if Opener is an array, only Opener[0] is accessed. Similarly, Closer represents one character, typically a closing bracket. Pointer is a position in Text. The return is always an array of length 2, [0] = position of the opener corresponding to the nesting level at Pointer; [1] = position of the corresponding closer. If either is not found, its element is -1. If Pointer points to an instance of Opener, returned [0] will be Pointer; likewise if Pointer points to an instance of Closer, returned [1] will be Pointer.
<b>finddup</b>(<# blue>array Subject,  bool OfEarlierValue  [,  scalar FirstIndex  [,  scalar LastIndex ]  ]<# black> ) -- If 'OfEarlierValue' is TRUE, then the function finds the <b>first</b> value in Subject which is the same as some value <b>earlier</b> in Subject. If FALSE, then the function finds the first value in Subject which is the same as some <b>later</b> value in Subject.
The last two arguments define the extent of 'Subject' which is scanned; if omitted, the whole array is scanned. The only corrections of these pointers are: (1) Negative 'FirstIndex' is corrected to 0;  (2) 'LastIndex' beyond the end of Subject is corrected back to its last element.
RETURNED: Always an array of size 3:  {  Index of the found element,   Index of the element which it matched,   Value of the matched element }.
<b>findany</b>(<# blue>ArrayToSearch, scalar StartPtr,  array TargetSet [, scalar / array Delimiter ]<# black>) -- TargetSet holds a set of targets to be sought. The return is always an array of size 2. In all cases, if none of the targets is found the return is [-1, -1].
The structure of ArrayToSearch is ignored; the index is an absolute address in ArrayToSearch's data strip. (You can use function "indexed(..)" to translate this address into array coordinates.)
StartPtr must not be negative - if it is, the function crashes.
For the remaining arguments, there are <b>two versions</b>:
<i>The three-argument version:</i>  Each value within TargetSet will be searched for in turn. Of those found, the one with the smallest index in ArrayToSearch will be the find returned. The return is: [index in ArrayToSearch;  index in TargetSet of the find]. For example, if ArrayToSearch is "12345" and TargetSet is "592", the return is: [1, 2], as the target which appears earliest is TargetSet[2], and it occurs at ArrayToSearch[1].
<i>The four-argument version:</i>  TargetSet is a delimited set of targets; the delimiter is given in the 4th. argument. The delimiter is always just one value; if Delimiter is passed as an array, only its first element is taken as the delimiter.
To give examples: Suppose the delimiter is '|'. Then a TargetSet "AA|B|CCC" will result in separate searches for "AA", "B" and "CCC".
The return is: [index in ArrayToSearch;  the number of the target within TargetSet (to base 0) ]. For example, if ArrayToSearch were "12AA34CCC", and TargetSet as just given, then the return would be [2, 0]: the find "AA" is subarray 0 within TargetSet, and it is found at ArrayToSearch[2].
Note that TargetSet must not begin or end with a delimiter, and no two delimiters must touch. Hence, these are illegal: "|AA|BB", "AA|BB|", "AA||BB".
<B>findinmx</B>(<# blue>Matrix,  scalar/array Sought,  bool FirstFindOnly  [, FirstRow [, LastRow ] ]<# black>) -- finds a value or a sequence within the ROWS of the matrix. (If a sequence, it must be fully contained within a row, to register a 'find'; it cannot cross into the next row.)
If "FirstFindOnly" is FALSE, then ALL finds will be returned.
The default for "StartRow" is 0, and for "LastRow" is the index of the last row of Matrix.
RETURNED: A matrix of two rows; row[0] records the row(s) of the find(s), row[1] records the column(s) of the find(s). If there are no finds, then a 2x1 matrix is returned, both values being -1.
(No equivalent function for searching columns is planned, as the time taken by the adapted function would not be significantly less than could be obtained by simply transposing the matrix and then applying this function.)
<b>findsegmt</b>( <# blue>array <b>InArray</b>,  array / scalar <b>Delimiter</b>,  array / scalar <b>Target</b> [, bool <b>FullLengthMatchOnly</b> [, scalar <b>StartSegment</b> [, scalar <b>MaxNoFinds</b> ] ] ]<# black> ) -- finds one or more segments in InArray which match 'Target'. By 'segment' is meant a subarray of InArray which is delimited by Delimiter; it can be empty. For more detail, key F1 on 'segment'. <# red>This function is obsolete and will shortly be removed from MiniMaths.<# black>
 Points re the arguments:
<bullet><b>InArray</b> can be any array; if structured, its structure will be ignored.
<bullet><b>Delimiter</b> is a single value. If supplied as an array, only the first element of the array will be used as the delimiter.
<bullet><b>Target</b> is the sequence which you want some segment to match.
<bullet><b>FullLengthMatchOnly</b> -- If omitted, or is TRUE, then the segment must exactly match the target for a find to be recorded. If present and FALSE, then any segment that <i>begins</i> with Target will be taken as a match.
<bullet><b>StartSegment</b> -- Normally the search occurs across the whole of InArray. If this is present, the search only begins from this segment. (NB! 'StartSegment' is a <i>segment</i> index, not an array index.) If StartSegment is negative, it is corrected to 0; if too large, simply no finds will be recorded.
<bullet><b>MaxNoFinds</b> -- Normally only one find is recorded - the first segment which matches Target. If MaxNoFinds is set to a positive integer, multiple finds will be recorded, up to that count. To return all finds, set MaxNoFinds to 0 or a negative value; or else make it larger than any possible number of finds.
<u>RETURNED:</u>  An array of length (3 x the no. of matching segments found), or the array [-1, -1, -1] if no finds.
For each find, there are three values: [segment index,  location in InArray of the first element in the segment,  locn. in InArray of last element in the segment]. For example, if the segment "BB" is a find within an InArray of "AA|BB|CC", then the three values for this find would be [1, 3, 4].
<i>Special case:</i>  You want to find an <b>empty segment</b>. In that case you should set Target to NaN (either as a scalar or as a single-valued array). The form of the find will be different: [segment index, location in InArray of the <i>delimiter</i> to the left, location of the delimiter to the right. For example, if InArray is "AA||BB", and Target is NaN, then the central empty segment will be found, and will be represented as the three values [1, 2, 3].
If the find is the first segment, then the second value will be -1 (as if there were a virtual left delimiter at InArray index -1).
If the find is the last segment, then the third value will be the length of InArray (as if there were a virtual right delimiter just beyond the end of InArray).
So if InArray is "||", Target is NaN, and MaxNoFinds is -1, the returned array will be: [0, -1, 0,    1, 0, 1,    2, 1, 2].
<b>fixangle</b>(<# blue>Angle [, MinimumAngle ] <# black>) -- non-void; returns an angle adjusted so as to lie between MinimumAngle and MinimumAngle + 2π. If MinimumAngle is omitted, the range defaults to 0 to 2π. The only other commonly used minimum angle is -π (but you can use any value you like).
<B>firfilter</B>(<# blue>array InArray,  array / scalar ImpulseResponse [, scalar Delay [,  scalar LeftPadder [, scalar RightPadder ]]]<# black>) -- applies a finite impulse response ("FIR") filter to an input signal InArray. See the Hints file for details (key F1 on the function name in the Assignments Window).
<B>fixedsize</B>(<# blue>array InData, scalar Extent,  array/scalar Padder [, bool PadAtStart [, bool TruncateIfTooLong [, array TruncationSign ] ] ]<# black>) -- Nonvoid. If InData has a length shorter than Extent, the returned copy (always a list array) will be padded out to that length using 'Padder'. The padding by default goes at the end of the array, but if 'PadAtStart' is present and TRUE, it goes on the front instead. If InData has a length greater than Extent, the remaining arguments decide what happens. If 'TruncateIfTooLong' is absent or zero, InData is returned as is. Otherwise it is truncated back to length Extent (which must be at least 1 to avoid a crash). The final argument, if present, adds an indicator of truncation. E.g. if it were "..", InData were "ABCDEFG", and Extent were 5, the output would be "ABC.."; whereas if the final argument were missing, the output would be "ABCDE".    
<B>floor</B>(<# blue>Variable [, scalar NoDecDigits]<# black>) -- If only one argument, gives the nearest integer on the side of zero. (It returns Variable unchanged, if it is integral). If a second argument, it gives the nearest number of that precision on the side of zero. ('floor(1.234,1)'  returns 1.2; 'floor(-1.234,1)'  returns -1.3.) Negative numbers are allowed: 'floor(15.7, -1)' returns 10. 
NB:  Internal numerical handling errors can be disastrous, as e.g. 'floor(-1e-20)' is -1, not 0. At times it might be better to use e.g. 'floor(z + 0.001)'.
<B>footer</B>(<# blue>Array of chars.<# black>) -- text to appear below a 2D or 3D graph. See help menu item <I>Graphing - Basic</I> for details on its use..
<B>fourier</B>(<# blue>Array [, bool ForwardTransform]<# black>) and <B>fft</B>(<# blue>Array [, bool ForwardTransform]<# black>) -- Both provide the discrete Fourier transform for the array; 'fourier(.)' calculates the transform term by term; 'fft(.)' uses a 'fast Fourier transform' algorithm (the 'Cooley-Tukey' version).
The array may be a list array (representing all real values) or a matrix for which the lowest dimension is 2 (interpretion: an array of complex numbers; column 0 holds the real values and column 1 the corresponding imaginary values). Structures of more than 2 dimensions are also valid, as long as the lowest dimension has size 2.)
If ForwardTransform is TRUE, OR if it is omitted, the forward transform occurs; otherwise the inverse transform. (The forward transform uses a negative index for the exponential, and has no universal multiplier; the inverse transform uses a positive index and a universal multiplier of 1/N). 
The returned value is <I>always</I> a set of complex numbers. In the case of <# blue>fourier(.)<# black> it holds the same number of values as the input argument; in the case of <# blue>fft(.)<# black> it may be larger, as explained below. Unless the input was a list array (all real values), the output object will have exactly the same structure as the input object.
<u>fourier(.)  v.  fft(.)</u>: They give the same result if the input data holds 2<^>N</^> values (real or complex), where N is an integer; if N is otherwise, then in the case of <# blue>fft(.)<# black> the argument is padded with terminal zero values until the next length that is an exact power of 2. <# blue>fft(.)<# black> is faster for all but the smallest arguments, and hugely faster as argument size increases. The main reason for using <# blue>fourier(.)<# black> is where you don't want the argument to be padded upwards when N is not an integral power of 2. Another distinction: If 'Array' is complex, then the two functions may return different structures; the output of <# blue>fourier(.)<# black> has the same dimensional structure as the input object, whereas for <# blue>fft(.)<# black> it will always be a matrix. (Necessarily so, because the automatic padding with zeroes, where carried out, would cause a structural mismatch.)
<B>frac</B>(<# blue>Variable<# black>) -- The fractional part of the number. 'frac(1.23)' and 'frac(-1.23)' both return positive 0.23. See also 'defrac(..)'.
<B>fromzero</B>(<# blue>Variable [, scalar NoDecDigits]<# black>) -- If only one argument, gives the first integer which is at or further from zero than Variable. If a second argument is present, it gives the nearest number further from zero of that precision (or Variable itself, if Variable has that precision). E.g. 'fromzero(1.234,1)'  returns 1.3; 'fromzero(-1.234,1)'  returns -1.3. Negative numbers are allowed: 'fromzero(5.7, -1)' returns 10.  See also 'tozero(.)', 'floor(.)', 'ceiling(.)'.
NB:  Internal numerical handling errors can cause unexpected results; e.g. if x, the result of a division, should theoretically be 1 but in fact is 1.000...001 due to such errors, then  the theoretical value of fromzero(x) would be 1 but the actual value would be 2.
<B>func1</B>(<# blue>arguments<# black>), <B>func2</B>(<# blue>arguments<# black>) and <B>setfunc</B>(<# blue>scalar WhichFunc, array FnName [, bool DontCrashIfNameNotFound [, bool OnlyCheckForUserFns] ]<# black>) -- Functions 'func1(.)' and 'func2(.)' can each stand for any system or user function; the function which each represents is set by a prior call to 'setfunc(.)', which takes the name of the function as an argument. To see how it is used, see help menu item <I>Anonymous Functions</I>.
<B>gauss</B>(<# blue>scalar or array Value, scalar Mean, scalar SD, scalar CurvePeak, bool IsInverse<# black>) -- Consider a Gaussian curve plotted in the XY plane. (a) If IsInverse is 'false' (0), Value is the X value and the returned scalar is the Y value. (b) If 'true', Value is the Y value, and the returned scalar is the X value (on the positive side of Mean). If CurvePeak is <= 0 the classical peak of 1 / [ sqrt(2*<| p>) * SD] is used (--> area under curve = 1). Errors do not crash, but return the value -1e100. The returned scalar / array is of the same form and structure as 'Value'.
<B>gclick</B>(<# blue>scalar graphID<# black>) -- See Help menu item <I>Graphing - Interactive</I>.
<b>getsegmt</b>( <# blue>array <b>InArray</b>,  array / scalar <b>Delimiter</b>,  scalar <b>WhichSegment</b><# black> ) -- Returns the indicated segment. If it is an empty segment, the return will be the array [NaN]. (By 'segment' is meant a subarray of InArray which is delimited by Delimiter; it can be empty. For more detail, key F1 on 'segment'.) <# red>This function is obsolete and will shortly be removed from MiniMaths.<# black>
<bullet><b>InArray</b> can be any array; if structured, its structure will be ignored.
<bullet><b>Delimiter</b> is a single value. If supplied as an array, only the first element of the array will be used as the delimiter.
<bullet><b>WhichSegment</b>: The first segment is numbered segment 0. <b>The function crashes</b> if WhichSegment does not refer to a valid segment; in other words, if WhichSegment is negative, or is \> 1 + number of delimiters present in InArray.
<b>getval</b>(<# blue>Alias [, segment address]<# black>) -- retrieves the value of an aliassed variable, or (if an array) of a segment of it. (For an explanation of aliassing, key F1 with the cursor on this function name, or just on 'alias'.)
In the case of scalars, <# blue>getval(N)<# black> will return the value currently in the scalar being accessed.
For arrays, <# blue>getval(N)<# black> will return a copy of the whole array, including its structure and characters rating.
To get just a segment of the array, use <# blue>getval(N, <address>)<# black>, where 'address' is  what you would put between square brackets if using the unaliassed variable. As an example, suppose that N is the alias for a matrix Mx'. The following will all return the same data:
<bullet><# blue>x = getval(N, 1, 2)<# black>	  and  <# blue>x = Mx[1,2]<# black>. ('x' will be a scalar.)
<bullet><# blue>xx = getval(N, 1)<# black>	  and  <# blue>xx = Mx[1]<# black>. ('xx' will be an array, one row of Mx.)
Where you want the whole of a column, and would use empty square brackets "[]" to indicate this, you instead use -1 (but no other negative number) - or MINREAL. These are equivalent:
<bullet><# blue>xx = getval(N, -1, 1)<# black>	  and  <# blue>xx = Mx[][1]<# black>. ('xx' will be an array, one column of Mx.)
<bullet><# blue>xx = getval(N, -1, -1)<# black>  and  <# blue>xx = Mx[][]<# black>. ('xx' will be assigned the whole of Mx.)
<B>gfixedvisible</B>(<# blue>GraphID, MenuText, Action<# black>) -- turns graph main menu items on and off - See Help menu item <I>Graphing - Interactive</I> for more details on the use of this function.
<B>graph(..), graph3d(..)</B> -- used in 2D / 3D graphing: see Help menu item <I>Graphing - Basic</I>.
<b>graphcolours</b>(<# blue>graphID [, PlottingSurfaceColour [, HairlinesColour [, BorderColour [, FrameColour [, TextAtHairlinesColour [, AxisLabelTextColour]..]<# black>)</b> -- If any or all of these are arrays holding valid colour data, the corresponding graph components have their colour changed; if any are scalar or absent, the existing colour remains as is. (An invalid array results in black.) 'BorderColour' is the colour of the perimeter line around the plotting surface; 'FrameColour' is the colour of the region outside the perimeter, where scale information is printed.
RETURNS a 6 x 3 matrix; the six rows correspond to the six arguments above, and the columns are the R, G and B values of the colour. If all you want to do is to read the existing colours without altering them, you would call "graphcolours(G)". No errors raised in any situation.
<B>graphcopy</B>(<# blue>scalar OriginalGraphID, bool UseStartupDimensions<# black> ) -- Draws a copy of the original graph, but without any plots. The graph ID is returned (or 0, if the original graph was not identified). If <i>UseStartupDimensions</i> is TRUE, the new graph will be sized according to the dimensions of the old graph <i>when it was created</i>. (In the case of 3D graphs, it will also revert to the original graph's startup cage orientation.) If you want to reproduce any changes to that size (as produced by dragging the old graph's margins, or by funtion 'graphresize(.)'), set this argument to FALSE. (In this case, be warned that if there is less than around 0.1 seconds between a call to 'graphresize(.)' on the original graph and a call to this function, the new graph will not reflect that graph-resize operation. I have tried various tricks to overcome this quirk of the underlying Gtk drawing system, but have so far failed.)
<B>graphkey</B>(<# blue>scalar graphID<# black> ) -- detects keypresses when the graphing board has focus. See help menu item <I>Graphing - Interactive</I>.
<B>graphresize</B> (<# blue>scalar graphID, scalar HorizPixels, scalar VertPixels<# black> ) -- Void. <i>Attempts</i>  to set exact pixel dimensions for the graph perimeter. However Mono's Gtk# has a mind of its own, and does not always exactly observe the values you provide, especially if they are impossible values.
The two arguments can be replaced by a single array argument of size 2.
No error is raised; if the graph does not exist, simply nothing happens.
See also <i>boardresize(.)</i>.
<B>graphvisible</B>(<# blue>scalar GraphID [, bool NewVisibility ] )<# black>  -- Always returns the final visible status of the graph as 'true' or 'false'. If <# blue>NewVisibility<# black> is present, then 'true' forces the graph to be visible, 'false' forces invisibility. If no graph <# blue>GraphID<# black> exists, the function returns 'false' (with no indication that the graph does not exist).
<B>grid / gridx / gridy / gridz</B>(<# blue>...<# black>) -- Used in graphing to set axis extents and hairline placements - see Help menu item <I>Graphing - Basic</I> for details on the use of these functions.
<B>gxmenu(..), gxvisible(..), gxclick(..)</B> -- handlers for user-generated on-graph menus. See help menu item <I>Graphing - Interactive</I>.
<B>header</B>(<# blue>Array<# black>]) -- Used in both 2D and 3D graphing to provide a heading for the graph display - See Help menu item <I>Graphing - Basic</I> for details on its use.
<b>hex</b>(<# blue>Scalar / Array Values [, scalar MinimumDigits ]<# black>) -- The hex version of the value(s), with up to 16 hex digits per vaue. (Larger numbers default to hex '8000 0000 0000 0000'). Fractional parts of the number are ignored. Negative numbers return complemented numbers; e.g. 'hex(-1)' returns a string of 16 'F's. If there is a second argument, it forces the least number of digits (with zero padding at the start, if necessary). E.g.: 'hex(1e6)' --> 'F4240';  'hex(1e6,2)' --> the same;  'hex(1e6,7)' --> '00F4240'.
Where 'Values' is an array, the precision (if present) applies to each value. Values are concatenated into the string; e.g
	<# blue>ss = hex(  data(1, 2, 3), 2);  <# magenta>// 'ss' will end up as the string "010203".<# black>
<B>homedirectory</B>(<# blue>dummy<# black>) -- Returns the current user's personalized home directory, e.g. "/home/fred/".
<b>hotkeysoff</b>(<# blue>scalar GraphID<# black>) -- If the graph exists, this function turns off all of its hot key accelerators (although the short cuts will still be published on the graph menus). There is no way of turning them back on.
<B>hsl</B>(<# blue>Colour argument<# black>) -- Returns an array of size 3, being the HSL values (all in the range 0 to 1) corresponding to a given colour. The colour argument - as for the colour argument of the 'plot(.)' function - may be: (a) a chars. array representing a colour name (see 'plot(.)' for allowed names); (b) a non-character array of length 3 or 4, representing an RGB colour ([0] red, [1] green, [2] blue; [3] ignored); (c) a scalar, the modulo 10 of which is used to access a palette of ten set colours (see the 'clrindex(.)' function for enumeration). An improper argument returns Black (i.e. the array [0, 0, 0]).
The returned array is made up thus: [0] is Hue, [1] is Saturation, [2] is Luminescence.
Note, when interpreting results, that (a) Hue 0 = Hue 1, due to rap-around of the colour system; and (b) with grey, Hue is indeterminate (though a value is returned here).
<B>hsl_to_rgb</B>(<# blue>HSL array<# black>) -- Given an array HSL of length three, with all values in the range 0 to 1, returns an array of size three, being the corresponding RGB colour values. Erratic argument returns black - the array [0, 0, 0].
<B>hypot</B>(<# blue><Variable1, Variable2 [, DontTakeSqRoot]<# black>) -- Returns the square root of the sum of squares of the two variables. If both are scalars, this is tantamount to returning the hypotenuse of a triangle with the given sides: hence the name. In this case, a scalar is returned. In all other cases an array is returned. If both arguments are arrays (which must be of the same size), each term of the returned array is the square root of the sum of the squares of the corresponding input array elements. If only one is an array, the same scalar is pitted against each element of the input array. In all cases, if there is a third argument and it is anything but 0, no square root will be taken.
<B>inc</B>(<# blue>Variable<# black>) -- NOT void; both increments the variable and returns the incremented value. The value is rounded first.
<B>indexed</B>(<# blue>array Struct,  scalar / array OffsetAddresses [,  bool  LowToLow ]<# black>) -- converts one or more offset array addresses to indexed array addresses. (The last element of a 4 x 3 matrix has offset address 11; this function would return the indexed address [3,2] for that value.)
<i>Struct</i> is either -
<bullet>A 2D or higher order structure (currently MonoMaths only allows up to 3 dimensions). In this case no data is accessed; the argument is used purely to supply dimensional sizing.
<bullet>A list array. In this case its elements are taken as the dimensions of a hypothetical structure of any number of dimensions, Struct[0] corresponding to the highest address. E.g. if modelling a 6-dimensional structure of dimensions 6x5x4x3x2x1, Struct would be the array [6, 5, 4, 3, 2, 1].
<i>OffsetAddresses:</i>  if scalar, then this single offset address will return a <i>list array</i>, which is the indexed address. If an array, then each element is converted to an indexed address, and the return is a matrix for which the number of rows is the number of offset addresses, i.e. the length of array OffsetAddresses.
<i>LowToLow:</i>  If this argument is omitted or FALSE, then the order of parts of the indexed address will be such that the lowest dimension is recorded in the highest element. For example, given a 5x4x3 structure (5 tiers, 4 rows, 3 columns), the last offset address, which is 59, would provide the output array [4, 3, 2]. (Indeed you would refer to this last element in your code as "Mx[4, 3, 2]".)  If you don't like this, reverse the order by making this 3rd. argument TRUE; in which case the returned array would be [2, 3, 4].
The inverse function is <# blue>offset(.)<# black>.
<b>ini_data</b>(<# blue>optional array SearchTarget<# black>) -- The INI file consists of paragraphs which are all in the form: "some_property=some_value". Of all the LHS's of these assignment statements, those which contain Target are selected. This subset, along with their RHS values, are then returned in the form of a delimited list array. The delimiter is always MAXINT32. For each property there will be two delimited subarrays: the property, the delimiter, the value. The same delimiter separates separate property-value pairs.
Where a value is a string (e.g. a file name), its subarray will consist of the unicodes of the string. Where the value is numerical (an integer or a real number), as a single numerical value, not as a string version of the number. Where the value is a colour, the colour is given as three successive numerical values, being the R, G and B bytes of the colour.
If there were no finds, the return is data(32) - the space unicode.
If there is no argument, or if it is scalar, then all properties within the INI file which have assigned values will be returned.
Remember that you will have to convert subarrays using 'chars(.)', if they are meant to be interpreted as strings.
To see an example of its use, key F1 with the cursor on the function's name in the Assignments window.
<b>inject </b>(<# blue>[ scalar / array <b>DataToInsert</b> ],   char. array  <b>VarNames</b><# black>) -- 'VarNames' is a delimited list of variable names; the data of DataToInsert (or internally created data, if the argument is absent) is inserted serially into variables referenced in 'VarNames'. There are lots of ifs and buts - see the Hint (key F1 on the name) for a full description and copious examples.
<B>insert</B>(<# blue>InputArray, Scalar AtPtr,  scalar/array InsertThis<# black>) -- returns a list array which is  a copy of the data of InputArray with 'InsertThis' inserted at AtPtr.
If AtPtr is less than 0 or more than the length of InputArray, a simple copy of the data of InputArray is returned. (If AtPtr = the length of InputArray, the effect is to append the data.)
The returned array is always a list array, but retains the 'characters' rating of InputArray.
<b>insertrows</b> (<# blue>matrix InMatrix, scalar AtWhichRow,  scalar / array NewData [, scalar NoTimesToAdd]<# black> ) -- NOT void. Returns a copy of InMatrix with extra row(s) inserted.
'AtWhichRow' will be the row at which the added material will start; the preexisting row there in InMatrix will be pushed down, along with its later rows. If AtWhichRow is out of range (i.e. does not refer to an existing row of InMatrix) an error is raised.
'NewData' can be: (1) a scalar, in which case it is converted internally to a single row of that value repeated. (2) a list array, in which case it must be divisible exactly by the row length of InMatrix; (3) a matrix, in which case it must have the same row length as InMatrix. 
'NoTimesToAdd' causes the above operation to be repeated that many times, the same row or set of rows being inserted each time. If it is \< 1, the returned matrix is a simple copy of InMatrix (with no error raised).
<b>insertcols</b> (<# blue>matrix InMatrix, scalar AtWhichCol,  scalar / array NewData [, scalar NoTimesToAdd]<# black> ) -- NOT void. Returns a copy of InMatrix with extra column(s) inserted.
'AtWhichCol' will be the column at which the added material will start; the preexisting column there in InMatrix will be pushed to the right, along with its later columns. If AtWhichCol is out of range (i.e. does not refer to an existing column of InMatrix) an error is raised.
'NewData' can be: (1) a scalar, in which case it is converted internally to a single column of that value repeated. (2) a list array, in which case it must be divisible exactly by the no. of rows of InMatrix; (3) a matrix, in which case it must have the same no. of rows as InMatrix. 
'NoTimesToAdd' causes the above operation to be repeated that many times, the same column or set of columns being inserted each time. If it is \< 1, the returned matrix is a simple copy of InMatrix (with no error raised).
<b>insert_image</b>(<# blue>array FilePathName, scalar Width, scalar Height, array LocationCue<# black>) -- inserts an image at a bookmarked location in the Assignments Window.
<i>FilePathName:</i>  The usual abbreviations, notably "~/" for home directory, can be used.
<i>Width, Height:</i>  If either is less than 10 (e.g. 0, or any negative value), both values are ignored, and the image's natural size is used. Otherwise these will define the dimensions of the image in the Assignments Window.
<i>LocationCue</i>:  This is some string which is sitting where you want the image to go. The image will replace the cue text. Usually you would make it occupy a separate line of text. If you want the image inset from the left edge, use tabs or spaces to the left of the cue string. NB - best to build the string from two parts in your 'insert_image' call, otherwise the picture might end up in the middle of your call to 'insert_image'! E.g. if your cue is "[image1]",  then the argument should be built like this: "LocnCue = text('[', 'image1]');"
<i>Returned:</i>  Always a chars. array. If all went well (and you can see the image), the returned array has length 1, a space character ' '. If not, you won't see an image, and the returned array will tell you why (length always greater than 1).
The only error that crashes the program is where FilePathName is scalar or contains no printable characters.
<B>intcurve</B>(<# blue>Array (integrand), Scalar (low end of range), Scalar (high end of range) [, Scalar (const. of integration)]<# black>) -- Returns a matrix which contains X and Y values for plotting the integral curve of the integrand curve. Uses Simpson's rule for numerical integration (which in effect fits quadratic curves between points). The integrand array MUST have an odd number of values, at least 3. If there is a 4th. argument, it is simply added to every value in the returned array as an offset.
\tThe 0th. row of the returned mx is the X values corresponding to the Y values in the 1st. row.

Example:
<# magenta>	// Plot a curve of y = sin(x) from 0 to 2PI:
<# blue>	NoPoints = 101;  
	xx = ladder(NoPoints, 0, 2*PI);
	yy = sin(xx);
	p1 = plot(yy,xx); <# magenta>// the integrand curve (which will be black)
	// Integrate, and plot the curve of the integral (which will be green):
<# blue>	mx = intcurve(yy, 0, 2*PI, -1); <# magenta>// offset of -1 is to balance the curve around the X axis (looks nicer).
<# blue>	p2 = plot(mx[1], mx[0],   '.', 3, "green",  '_', 1, "green" );
<# magenta>	// Graph the two curves:
<# blue>	g = graph(p1, p2); <# magenta>// plot both curves on the one graph.
<# magenta>	// A little embellishment, for the optics...
<# blue>	grid(g, 0, 2*PI, 4,    -1, 1, 2);
	scalefudgex(g, 1/PI, " π", true, true); <# magenta>// convert scale from simple numerals to multiples of PI.
<# black>
<B>integral</B>(<# blue>Array (integrand), Scalar (low end of range), Scalar (high end of range) <# black>) -- Produces the definite integral between the given limits. Uses Simpson's rule for numerical integration (which in effect fits quadratic curves between points). The integrand array MUST have an odd number of values, at least 3.  Example:
\t<# blue>yvalues = fill(21, 0, 0, 1/sqr(20)); <# magenta>// creates 21 values for y=x^2, from x=0 to x=1.
\t<# blue>area = integral(yvalues, 0, 1); <# magenta>// area under the curve y = x^2 from x=0 to x=1<# black>
<b>interpolate(<# blue>(<# blue>scalar / array PseudoIndexes,  list array RefArray<# black>)</b>. For each value p in PseudoIndexes the function interpolates between RefArray[ floor(p) ] and RefArray[ ceiling(p) ]. If p is an integer and within the range of RefArray's indexes, then the function simply returns RefArray[p]. If p is outside the index range of RefArray, extrapolation occurs using the two nearest end values of RefArray.
The function's return will be of the same form as PseudoIndexes - scalar, list array or structured array.
There are no restrictions on the ordering of either array, and duplications are allowed.
See also function 'readtable'.
<B>intersection</B>(<# blue>at least two arrays<# black>) -- Returns a list array containing all values common to all arrays (structure and chars. rating ignored). Duplicates removed. If no such values, returns an array of size 1, content NaN; and a call to 'empty(.)' returns 'true'.
<B>inverse(</B>(<# blue>Matrix<# black>) -- Returns the inverse of the matrix, which must be square, and at least 2x2. If the matrix is singular (and therefore cannot provide an inverse), the function instead returns an array of size 1 (value NaN); a call to 'empty(.)' would return 'true'.
<B>iofile</B>(<# blue>scalar Dummy or array WhichPart<# black>) -- Always returns a chars. array. Where a file load or save operation has successfully occurred, this will be the file name of that operation, and will remain so until the next such operation. Where such an operation fails, instead this will return an array of length 1, the space character (32). The space character is also returned if there has not yet been such an operation since the run began. <i>Argument:</i>  If a scalar argument, the whole file path and name is returned. If an array, its first character is checked; if 'P' or 'p', only the path is returned (terminated by the character '/'); if 'N' or 'n', only the name is returned; anything else defaults to returning the full path and name.
<B>iok</B>(<# blue>arg. ignored<# black>) -- If the last call to a MonoMaths disk I/O function was successful, this returns TRUE (1); otherwise FALSE (0). The internal flag used by this function remains unchanged by calls to 'iok()'; it is only reset by the next disk I/O function call. Functions that currently set this flag are: 'load' and 'save'. Disk functions which only provide information about files (such as 'filesize') do not reset the flag. To find out why a disk I/O function failed, call...
<B>iomessage</B>(<# blue>arg. ignored<# black>) -- Normally this is reset to an empty array (a single space, unicode 32) if a disk I/O operation is successful; though it sometimes contains information in this case (see 'load('A', ...)' with the function 'ExpectPrefix' true, for an example; in that case an array argument can be used to select part of the information). Where iok() is set to 'false' by an error state, this returns the error message, <i>unless</i> the user had aborted the function at a dialog box (e.g. asking for a file name); in that case it will be 'empty' (one space). For example, suppose you want to show an error message after a failed disk I/O operation, but only if it was evoked by a genuine error, not by a cancellation; the code would be:  "if (!iok()  &&  iomessage() != ' ') writeln("ERROR: ",  iomessage());".
Repeated calls will return the same message until the next disk I/O function resets its internal value.
<B>is</B>(<# blue>Variable [, scalar Tolerance ] <# black>) -- If no 2nd. argument, returns a copy of Variable in which all nonzero elements are replaced by 1. If 'Tolerance' is supplied and > 0,  elements are replaced by 1 if  they are > Tolerance, otherwise they are replaced by 0. The complementary function is 'not(.)'. See also binary logic functions 'and(.)', 'or(.)', 'xor(.)' and 'xorcomp(.)'; and functions 'matches(.)', 'mismatches(.)'.
<B>isarray</B>(<# blue>Variable<# black>) -- evaluates to 0 for a scalar argument and 1 for an array argument.
<B>isgraph</B>(<# blue>scalar GraphID<# black>) -- if the graph exists, evaluates to 2 (for 2D) or 3 (for 3D). Otherwise returns 0, so can be used like a boolean in conditional statements.
<b>isintegral</b>(<# blue>scalar / array X [,  scalar Y ]<# black>) -- If X is above or below the nearest integer by more than Y (which must be positive), returns FALSE; otherwise TRUE. If Y is not supplied (or is zero or negative), a default value of 1e-10 is used. If X is an array, each value is treated separately, the return being a boolean array of the same structure as X.
<b>isnan</b>(<# blue>a single variable<# black>) -- returns TRUE for each value which is set to NaN. Returns a scalar if a scalar argument, otherwise an array of the same structure as the argument. This function is necessary because "(x == NaN).." will always return false, even when x has been set to NaN. (This is inherent in the underlying C# language in which MonoMaths is written.) 
<B>isplot</B>(<# blue>scalar PlotID<# black>) -- if the plot exists, evaluates to 2 (for 2D) or 3 (for 3D). Otherwise returns 0, so can be used like a boolean in conditional statements.
<B>jag</B>(<# blue>Matrix, array Operation [, array NewRow, scalar RowNo [, scalar Length [, scalar Filler ]]]<# black>) -- <# red>*** DEPRECATED *** - will be removed soon; use function 'jagger(.)' instead.<# black> -- Returns a copy of Matrix with a new row inserted. What happens is determined by argument <I>Operation</I>, of which only the first character is examined. 'I' or 'i' causes insertion; 'O' or 'o' (the letter, not the numeral zero) causes overwriting; 'A' or 'a' causes appending. With the new row in situ, the <I>whole matrix</I>, row by row, will be padded or amputated as for 'jagger(.)', using Length and Filler in the same way (if supplied).
If Operation is 'A' or 'a', then RowNo, if present, is completely ignored. In all other cases RowNo must be present and must refer to an existing row, or the function crashes.
<I>New row length:</I> This is set by the Length argument, if it is present and rounds to 1 or greater; otherwise by default the new row length is whichever is greater: the length of existing matrix rows or the length of NewRow. Where a row (old or new) is shorter than the new row length, it is padded (see below). Where it is longer than the new row length, it is truncated.
<I>Filler:</I> If this value is not supplied, the padding value defaults to zero. If you want to pad with a character - say, a dash - you can obtain its scalar value using the function 'asc': <B>asc('-')</B>.
<I>Hint:</I> 'Matrix' can, in fact, be a list array, in which case it is handled as if it were a 1xN matrix (i.e. a row vector). You can build a jagged matrix from scratch using 'jag(.)', by supplying 'Matrix' the first time as a list array. An example:
\t<# blue>arr = "the cat";
\t<# blue>brr = "sat on the mat";
\t<# blue>crr = "and spat";
\t<# blue>mx1 = jag(arr, 'A', brr,-1, -1, asc('.'));
\t<# blue>mx2 = jag(mx1, 'A', crr,-1, -1, asc('.'));
<# black>This produces the 3-row matrix:
\t<# green>the cat.......
\t<# green>sat on the mat
\t<# green>and spat......
<# black>
<B>jagger</B>(<# blue>array Subject, array Operation, scalar / array NewRow, [, scalar RowNo [, scalar Length [, scalar Padder ] ] ] )<# black>) -- Requires that 'Subject' be predefined, as it will be directly altered by this function. If it is a list array it will be recreated as a matrix with one row, using the supplied data NewRow. If it is already a matrix it will remain so, and the only data that will be altered is what you have decreed to be altered. 
What happens is determined by argument <I>Operation</I>, of which only the first character is examined. 'I' or 'i' causes insertion; 'O' or 'o' (the letter, not the numeral zero) causes overwriting; 'A' or 'a' causes appending. With the new row in situ, the <I>whole matrix</I>, row by row, will if necessary be padded or amputated as described below.
The RETURN of the function is an array of size 3, reflecting the final state of Subject: { No. of rows,  Row length,  Padder }.
Running through the modes:
<bullet><i>Operation 'A':</i>  Appends a row. <i>RowNo</i> need not be supplied; if it is it is completely ignored. If 'Subject' is a list array, its contents are lost and it is converted to a one-row matrix, <i>NewRow</i> being that row.
<bullet><i>Operation 'I':</i>  Inserts a row, pushing rows upwards to make way for it.  <i>RowNo</i> must be supplied, and must be the number of an existing row. If 'Subject' is a list array, its contents are lost and it is converted to a one-row matrix, <i>NewRow</i> being that row. (RowNo is ignored in this case, even though a value must be supplied.)
<bullet><i>Operation 'O':</i>  Overwrites a row completely (all of the original row is lost, no matter how short NewRow is). <i>RowNo</i> must be supplied, but <i>for this mode only</i> it may be beyond the end of the existing matrix. If so, the new last row will be row RowNo; if necessary, empty rows (i.e. consisting of the pad value only) are interposed between the end of the existing matrix and this new row.
If <i>NewRow</i> is scalar it will be treated as if it were an array of length 1, holding this value. (Typically you would use it to add / insert an empty row, in which case NewRow would be the scalar pad value.)
<I>Final matrix row length:</I> This is set by the Length argument, if it is present and rounds to 1 or greater; otherwise by default the new row length is whichever is greater: the length of existing matrix rows or the length of NewRow. Where a row (old or new) is shorter than the new row length, it is padded (see below). Where it is longer than the new row length, it is truncated.
<I>Padder:</I> If this value is not supplied, the padding value defaults to zero.
If Subject enters as a list array, it takes the 'chars' rating of <i>NewRow</i>. Otherwise it preserves its prior 'chars' rating.
See also function <b>split(.)</b>, which produces a jagged matrix from a delimited string.

<B>join</B>(<# blue>matrix Matrix, array or scalar Delimiter, array or scalar Padder [,  array or scalar EmptyRowCue ] )<# black>) -- Paste the rows of Matrix together, delimited by 'Delimiter'. (The first and last elements of the returned array are never Delimiter.)
<bullet><i>Matrix:</i>  If is a list array, will be regarded internally as a 1xN matrix.
<bullet><i>Delimiter:</i>  If an array, the entire contents of the array becomes the delimiter.
<bullet><i>Padder:</i>  Never optional (as it is in the above functions). If an array, only its first element is used.
<bullet><i>EmptyRowCue:</i>  If this argument is omitted, rows consisting only of Padder will be ignored; if the whole of Matrix is the Padder, then the 'empty' array [ NaN ] will be returned. If this argument is present, rows consisting only of Padder will be replaced in the output by this argument (which may, if an array, have any length).
<B>keydown</B>(<# blue>bool ReturnCharArray<# black>) -- If a key is currently being held down, this returns information re that key. If ReturnCharArray is TRUE, that information is a key name (e.g. "Cntrl") or, if MonoMaths has not yet assigned a key name, '#' followed by the key value. (For printable keys, the key value is the unicode value.) If the argument is FALSE, instead the function returns the key value as a scalar. If no key is currently down, returns 'null' (if ReturnCharArray is true) or 0. To get much more detailed information on this function, enter 'keydown' into the Assignments Window and key F1.
<B>keyed</B>(<# blue>[ named array RefArray [,  scalar HistoryLength ] ]<# black>) -- RETURNS a boolean and MODIFIES RefArray (if supplied). The boolean return is 'true' if a key or keys have been keyed since the last call to this function (or since the beginning of the program, if no previous call). The call to <i>keyed(.)</i> resets an internal buffer, so that a subsequent call to the function (with no keyings in between) will return 'false'.
If you use the function without arguments (or with any scalar first argument), that is all that happens. If you proved a named array RefArray, you will get back information about key presses in that array. How that information is returned depends upon:
<bullet><i>HistoryLength.</i>  If this is ≤ 1, you will get back details of the last key combination pressed. (This might be a single key, or a combination like  control-alt-shift X.) Otherwise you get back information on as many past key presses as you specify, up to the capacity of the buffer to remember key presses. (Bear in mind that the relevant buffer can only hold up to 12 single key presses and fewer key combinations.)  If HistoryLength is absent or ≤ 1, the final form of RefArray is a list array. If HistoryLength is \>1, RefArray will be a jagged matrix; every row will end in 0 (whether chars. array or not), and shorter rows will be padded out with further zeroes. The most recent key press or combination will be in the lowest row. (If HistoryLength exceeds the number of keypresses stored, the excess upper rows will consist only of zeroes.)
<bullet><i>The characters rating of RefArray.</i>  If RefArray is a chars. array, the information will be returned in characters form (like "Alt Cntrl Shift V"); if not, in numerical form ( [86, 65505, 65507, 65511]  for the same key combination).
Key combinations are sorted, as the above examples show. If RefArray is not a characters array, they are sorted in ascending order, as shown above. If RefArray is a chars. array, they are sorted in descending order before being submitted to the internal routine which converts numerical codes into key names. Also, Latin letter keys are converted to upper case (as with the 'V' above).
<B>keyname</B>(<# blue>scalar/array KeyValues [,  char. array Delimiter ]<# black>) -- Translates one or more key values (as returned by function <# blue>keydown(false)<# black>) to key names. Returns a char. array. If there is more than one value in KeyValues, the default delimiter is a single space (i.e. where there is no second argument, or where that argument is scalar).
<B>kill</B>(<# blue>Var1, Var2, ...<# black>) -- void function, taking any number of arguments, which must be valid variable names. Each variable is eniolated, and its name becomes available for reuse as either an array or scalar. Intended uses: (a) demolish huge arrays, no longer needed; (b) in a loop which repeatedly assigns a function to a variable, and that function may on different occasions return a scalar or an array. If you don't kill the assignee after use, the next loop will expect it to be dedicated as the variable type of the last function return, and so a crash will result if the function returns the other type. 
See also function 'clear(..)'.
<B>killplot</B>(<# blue>any no. of plot identifiers<# black>) -- void function which removes the identified plots from memory, including removing them from any currently displayed graphs that have plotted them. Applies to both 2D and 3D plots. If PlotID does not correspond to an existing plot, nothing happens (and no error is raised). The plot identifiers may be separate scalars, or maybe packed together in an array (or any combination of scalars and arrays).
<B>killgraphs</B>( <# blue>scalar / array GraphIDs, array DoWhatWithPlots )<# black>. Void; kills the listed graphs. If 'GraphIDs' is exactly the array "all" (or at least begins with this), it will kill all graphs.
<i>DoWhatWithPlots:</i>  Only the first character is checked. These are the options:
<bullet>'!' = kill all plots, whether or not other graphs are using them. No trace of the plots is left in memory; however the display of existing graphs will not be altered. (In such displays, you are looking at a drawing made in the past from the plot, not at the plot itself. If the graph were redrawn or copied, killed plots would not be reproduced in the new instance.).
<bullet>'?' = query plots, to see if some other graph is using them. If so, let them live; otherwise eniolate them. (In the case where GraphID is "all", this has the same effect as '!', as you would logically expect.)
<bullet>'-' (or anything else, for  that matter) = don't kill any plots.
Some further points to note:
<bullet>If speed is the essence (as during an animation), be aware that '?' is much slower than either of the other two options.
<bullet>If you call <# blue>lastclosed()<# black> after killing graphs, it will always return 0. The purpose of 'lastclosed()' is to communicate to the program that the user has closed a graph, usually by clicking the corner icon, so that it can take appropriate action (e.g. close down the program); if the program itself has just closed certain graphs using 'killgraphs', it does not need help from a function like 'lastclosed' to tell it what it has just closed! Moreover, if you have just killed one set of graphs and plan to then draw another set, you would want 'lastclosed' to return 0 during the existence of the new set, till one of them is closed.
<B>kill_on_exit</B>() -- After this void function has been processed, the next program exit will also result in the closure of the MonoMaths instance. That exit may be through the explicit instruction "exit;" or through the completion of all main program code. It has no effect if the program ends prematurely  through an error, or by use of the 'crash(.)' instruction. The function was created for use where one instance of MonoMaths invokes a second instance using the 'exec(.)' instruction, so that the second instance can be made to close when its usefulness to the first instance has expired. (In this setting it is important for 'kill_on_exit()' to fail in the presence of unforeseen errors that crash the program.)
<B>label</B>(<# blue>One or more variables or literals<# black>) -- Nonvoid. Read or alter the text of any of:
<bullet>Labels: the Assignments Window label ('A'), the Results Window label ('R') or the Comments label, bottom left of the display ('C');
<bullet>The main window title (until the next file I/O operation overwrites it): ('T').
The first value of the aggregated argument must be the unicode of one of these four letters, and defines which window component is to be accessed. The remaining text determines what happens next.
If there is no remaining text (e.g. <# blue>ss = label('C');<# black>), the current contents of the window component is returned. (In all other cases, including errors, a single space is returned.)
Otherwise the remaining text replaces current label contents, <i>with provisos</i> (which apply to labels, not to the main window title):
<bullet>If the remaining text is <i>exactly</i> the string "_DEFAULT_", the label will receive its default text (i.e. text as at startup);
<bullet>If the remaining text is exactly "_DEFAULT_" followed by any text (e.g. "yak"), the label receives the default text followed by 'yak'.
Note that when the program ends, the top two labels are always reset, though the Comments label retains its set data. When a new program starts, all three labels are reset to their defaults. File I/O operations always overwrite any setting of the main window title.
<B>labelx / labely / labelz</B>(<# blue>...<# black>) -- Used in both 2D and 3D graphing to provide axis scale descriptions - see Help menu item <I>Graphing - Basic</I> for details on their use.

<B>ladder</B>(<# blue> Variable, Scalar FirstValue, Scalar LastValue [, scalar ConformInterval ]<# black> ) -- provides an array whose entries are an arithmetic progression from FirstValue to LastValue. It comes <B>in three forms</B>, none being void.  FirstValue may be equal to or less than LastValue.
<u>Form 1</u>
Format:  <# blue>NewArray = ladder(ArraySize, FirstValue, LastValue)<# black> -- returns an array of the stated size. E.g.
	<# blue>arr = ladder(5, 10, 11);  <# magenta>//  this returns the array { 10,  10.25,  10.5,  10.75, 11 }<# black>
<u>Form 2</u>
Format:  <# blue>Interval = ladder(NamedArray, FirstValue, LastValue)<# black> -- this time 'NamedArray' is exactly that, and has been predefined. Its prior values will be lost, though not its structure. Its new values will be equally spaced between FirstValue and LastValue.
	<# blue>dim(arr, 5);
	<# blue>intvl = ladder(arr, 10, 11);  <# magenta>//  'arr' will now be { 10,  10.25,  10.5,  10.75, 11 }; and 'intvl' will be set to 0.25.<# black>
Note that the above two forms have exactly three arguments. The final form has exactly four arguments, all being scalar.
<u>Form 3</u>
Format:  <# blue>NewArray = ladder(Interval, FirstValue, LastValue, bool ConformInterval)<# black> -- This builds an array starting from FirstValue and adding Interval to successive values. There are two versions:
<bullet>ConformInterval is TRUE:  In this case the interval is, if necessary, adjusted so as to be an exact multiple of (LastValue - FirstValue). In this case, LastValue is guaranteed to be included.
	<# blue>Arr = ladder(3, 10, 20, true);  <# magenta>// No. segments = (20 - 10) / 3 ≈ 3.33. This is rounded to 3, giving a new interval 3.33...
		<# magenta>// The returned array becomes  { 10,  13.33...,  16.66...,  20 }.<# black>
<bullet>ConformInterval is FALSE: The interval stays as is, and values are added successively to the array up to the last value which <i>does not exceed</i> LastValue. (In the case of decreasing values, to the last value which is not below LastValue.)
	<# blue>Arr = ladder(3, 10, 20, false);  <# magenta>// This returns  { 10,  13,  16,  19  }<# black>
With this second version, even if theoretically the interval is an exact divisor of (HighValue - LowValue), there is a risk that systematic numerical error will occasionally cause HighValue to be excluded. If this is a critical problem for your application, make HighValue a tad higher - e.g. 20.0001 instead of 20.
<B>Warning!</B> This function is particularly vulnerable to numerical errors, so do not use exact equality tests. E.g. if we define "xx = ladder(101, -2, 2)", xx[70] should be 0.8; but the test "if (xx[i] == 0.8)..." will register 'false' for i = 70, because of a numerical error residue: xx[70] is computed as (0.8 + 2.2...E-16).

<B>ladderclr</B>(<# blue>Scalar NoColours, Array/Scalar FirstColour, Array/Scalar LastColour [, array HoldWhatConstant [, bool ColoursAreHSL [, scalar DistortionFactor ] ] ]<# black>) -- analogous to the first form of 'ladder(.)'; it returns a range of 'NoColours' colours which grade from FirstColour to LastColour; the form of the return is a matrix (NoColours x 3), the rows being R, G, B values respectively. The two input colours may be a literal name ("sky blue"), or an array of size 3 (R, G, B values between 0 and 255), or a hex value (e.g. "0xff8800"), or the integer version of this hex number.
<i>HoldWhatConstant:</i>  Grading of colours is done internally using HSL forms of supplied colours; in some cases (see hints for when - i.e. enter the word 'ladderclr' and key F1) you may want to force one or two of the H, S and L components to stay the same as for the FirstColour; in that case, make this argument consist of one or two of the letters H,S,L (or h,s,l). (Any third or later value in the array is ignored, as is any other letter than these three.)
<i>ColoursAreHSL:</i>  The arguments are normally taken as being RGB colours in one of the abovementioned forms; but if this argument is present and TRUE, and the colours are arrays of size 3, then they will be accepted as HSL values instead.
<i>DistortionFactor:</i>  A tweaking factor; it affects how quickly colours change between the two extreme colours. The default is 1. Lower positive values (e.g. 0.5) cause more rapid change over the first few colours, and little difference in the last few colours; Higher positive values (e.g. 2) have the opposite effect. (Values of 0 or below are ignored, and the default is used.)
Where impossible colour arguments are supplied, (a) in the case of RGB arguments, names etc., the default colour black is used; (b) in the case of HSL arguments - for which all values must lie in the range 0 to 1 - overlimit values are taken back to the nearest of 0 or 1.
The only crashing errors:  (1) NoColours rounds to less than 2;   (2) an HSL argument is not of length 3.
 <B>last</B>(<# blue>Array [, scalar Which] <# black>) -- returns one of the last values in the array, whatever its structure. If Which is absent or 0, returns the last value; if either +1 or -1, the last-but-one value; and so on for higher absolute values of Which. If  | Which |  >= array length, raises an error.
<B>lastclosed()</B> -- holds the ID of the last graph to be closed, or 0 if none closed since startup or since the last use of this function. A call to this function resets the internal flag after returning the graph ID, so that a subsequent call would return 0. 
<b>lettercase</b>(<# blue>array TheString,  array Model<# black>) -- returns a copy of TheString with letter case changed in accordance with Model. Only specific values of Model are valid; nonvalid Model results in the returned string being just a copy of TheString (no error raised). Allowed values:
	"A"			All letters made upper case.
	"a"			All letters made lower case.
	"Aa"			The very first letter is capitalized; all other letters are lower case, irrespective of punctuation.
	"Aa_Aa"		Every word starts with a capital, the remaining letters of each word being lower case.
	"Aa<b>.</b>Aa"		The first word starts with a capital, as do words following '<b>.</b>', '<b>?</b>' and '<b>!</b>'. All other letters are lower case.
------------------------------------------------
<U>LIST FUNCTIONS</U>
<B>list_new()</B> -- no argument. Creates a new list, and returns the new total number of lists (NOT the index of the new list, which is one less than this number).

<B>lists_new(scalar HowMany)</B> -- Creates the stated number of new lists, and returns the new total number of lists.

<B>list_add(list index, one or more scalars or arrays)</B> -- appends all supplied data to the end of the given list. Crashes if the list was not created (using 'list(s)_new(.)' ). Returns the new length of the list.

<B>list_read(list index)</B> OR <B>list (list index)</B> -- returns the whole list as an array. NB - crashes if the list is empty, even if the list has been created by 'list_new()'.
<B>list_read(list index, position)</B> OR <B>list(list index, position)</B> -- returns a <I>scalar</I>. NB - crashes if 'position' is beyond the end of the list.
<B>list_read(list index, position, extent)</B> OR <B>list (list index, position, extent)</B> -- returns an extent of a list as an array. NB - crashes if any part of the extent is beyond the end of the list.
<B>list_read_to(list index, first position, last position)</B> OR <B>list _to(list index, first position, last position)</B>  -- returns an extent of a list as an array, between and including the two positions. NB - crashes if any part of the extent is beyond the end of the list.
<B>lists_read(padding value,  first list,  no. of lists [, fixed length] )</B> OR <B>lists (padding value,  first list,  no. of lists [, fixed length] )</B> -- retrieves a set of contiguous lists and returns them as a <B>matrix</B>, with one row per list. The length of the list is normally set by the longest list; the end of shorter lists are then padded to full length by appending as many 'padding value' bytes as needed. If the fourth argument is supplied, this overrides this system; list copies will then either be amputated or padded, in order to achieve 'fixed length'. The padding value may be a scalar or an array variable. If an array, only the first element is used; the rest of the array is ignored. The function crashes if any of the lists in the range do not exist.
<B>lists_read_to(padding value,  first list,  last list [, fixed length] )</B> OR <B>lists_ to(padding value,  first list,  last list [, fixed length] )</B> -- behaves exactly as above, except for the different way of fixing the range of lists to be copied.

<B>lists_count()</B> -- returns the number of created lists (0, if none).

<B>list_size(list index)</B> -- returns the size of the given list (0 if empty; -1, if the list does not exist).

<B>list_alter(list index, position, data)</B> -- 'data' is a single variable, array or scalar. List data is overwritten with the contents of the variable, starting at 'position', and extending for the length of the variable. NB - crashes if any part of the extent is beyond the end of the list. Void function.

<B>list_insert(list index, position, one or more variables)</B> -- the content of all of the 'variables' is inserted into the list at 'position' (which must be a valid position in the list). Returns the new size of the list.

<B>list_delete(list index, position [, extent])</B> -- delete list items. If 'extent' missing, deletes all to end of list. If supplied, must not exceed end of list. Returns the new size of the list.
<B>list_delete_to(list index, first position, last position)</B> -- delete list items over the given range (which must exist). Returns the new size of the list.

<B>list_opn(ListIndex, Position, array Operation, scalar Value [, scalar DontChangeList ])</B> -- carries out the operation "List[position] . Operation .  Value", and returns the result. If there is no fifth argument, or if it is present and nonzero, then this value also replaces the old value in the list. Only  Operation[0] is examined; it must be one of these: " + - * / ^ A B S " (small letters allowed). 'A' = absolute value; 'B; = boolean evaluation (replace nonzero values by 1); 'S' = sign (replace with +1, -1, or, if list value is 0, replace with Value). For the unary operations 'A' and 'B' Value is irrelevant, but it cannot be omitted. As usual, it crashes if the list or its index do not exist. It also crashes for division by 0 or by power opns. that would return a complex number.

<B>list_find(list index, scalars value1[, value2])</B> -- finds the first instance of value1 (two argument form) or of any value between value1 and value2 inclusive (three argument version). The order of value1 and value2 is irrelevant. Returns -1 if no find.
<b>list_find(list index, array Sequence)</b> -- finds the first instance of the array Sequence within the list; returns -1 if no find.

<B>list_cull(list Index, any number of scalars or arrays)</B> -- removes all values represented from the list (which may end up empty as a result) and returns final size.
<B>list_cull_range(list Index, value1, value2)</B> -- removes all values within the range (inclusive). The order of value1 and value2 is irrelevant. Returns final list size.

<B>list_clear(list no.)</B> -- empties the given list, <I>but</I> does not destroy it. (You can put new data into it in the usual way, with 'list_add(.)'. ) NB - crashes if the list has not yet been created. Void function.
<B>lists_clear(first list, extent)</B> -- empties all lists in the stated range. NB - crashes if any list in the extent has not yet been created. Void function.
<B>lists_clear_to(first list, last list)</B> -- empties all lists in the stated range. NB - crashes if any list in the extent has not yet been created. Void function.

<B>lists_kill(from list no.)</B> -- destroys <I>all</I> lists from the given list upward. (It is not possible to have destroyed lists with existing lists beyond them.) It is safe to use this function even if there are no lists in existence. If you use it without an argument it will destroy all lists (since an empty argument translates internally as the argument 0). Negative 'from' list destroys all (as if it were 0); and if the 'from' list does not exist (too high), nothing happens.  Void function.

<B>lists_preserve()</B> -- If program focus comes across this function call anywhere throughout the program, an internal flag is set which ensures that the lists remain intact and accessible during the next program run, even if it is a different program. (Unless that next program also calls the function, the lists will not persist beyond its run.) Void function.

<B>list_push(list index, data)</B> -- pushes the contents of a single variable (scalar or array) onto the end of the given list, as if it were a stack. Returns the new size of the list. With arrays, the data in the list is in the same order as in the array. NB - crashes if the list does not exist.

<B>list_pop(list index, variable)</B> -- inserts the appropriate length of data into the variable (which must be a previously declared variable, not an expression). If an array, it will contain data in the same order as in the list. The list is shortened by the removal of this data, as with a stack. The function returns the new size of the list.
\tIf the size of the list would not permit complete filling of the variable, nothing happens to either the list or the variable (it retains its preexisting data), but the function returns a negative number, which is the shortfall of space as a negative number. (In the case of trying to pop a scalar from an empty list, it would therefore return -1.) The function only crashes if either the list or the variable does not exist. 
-----------------------------------
<B>ln</B>(<# blue>Variable<# black>) -- the logarithm of n to base e = 2.71828...
<b>load</b>(<# blue>array Mode, array FileName [, ... <# black>) -- loads data from a disk file. Arguments vary across the five different modes, the mode being set by the first argument, 'Mode'. Only its first element is tested. This should be one of: 'T'(ext), 'B'(bytes), 'A'(rray), 'F'(ormatted), 'D'(irectory name). ('Mode' is case insensitive, and can even be scalar - the unicode of a valid letter.)
<i>FileName:</i> If no file path precedes the name, the current data path will be used. Shortcut "~/" is allowed for the user's personal home directory. If 'FileName' is empty (spaces only) or begins with '?', a dialog box will open for user choice of file. Also if 'FileName' is a directory (and so ends in '/'), a dialog box will open at that directory.
Leading and trailing spaces are trimmed from 'FileName', together with unicode 0, so that a row from a jagged array (as, for example, is produced by function 'split(.)') can be used as is.
The ARGUMENTS for the different modes are as follows:
<i>load</i>(<# blue>'T', array FileName<# black>) -- assumes the file is a text file, and returns a chars. array accordingly. (There is some built-in protection against impossible codes, but it would be possible to crash this function by sending it certain values that cannot be decoded into UTF8 characters; so use the function sensibly.)
<i>load</i>(<# blue>'B', array FileName<# black>) -- loads any file as a sequence of bytes; the returned array has one byte value per element.
<i>load</i>(<# blue>'A', array FileName [,  bool ExpectPrefix ]<# black>) -- Used where an array has been encoded using Mono's underlying encodement scheme for 'double' values; this code uses 8 bytes per value, that is, per element of the array. This file would usually have gotten onto your disk by your earlier use of <i>save('A', ...)</i>. If 'ExpectPrefix' is present and true, the function will expect to find a prefix listing the array's name, dimensions and chars. rating, together with a time stamp (no. seconds since start of 1AD) preceding the data. This prefix will have been put there by your setting an equivalent boolean when you saved the file using 'save('A', ...)'. You can read it from function <i>iomessage()</i>, which will return the original variable's name (or description - see <i>save('A', ... )</i> for details), then two colons, then the date stamp as a string; e.g. "MyArray::63441222019". (If a nameless array (i.e. an array expression) was saved, the string will simply be e.g. "::63441222019".)  To get just one part of this, <i>iomessage("name")</i> returns just the name (or the empty array, where saved array was nameless); and <i>iomessage("time")</i> returns the date stamp part (still as a string).
The 'save(.)' function allows you to save a <i>description</i> in place of the original array name. If that option was taken, then that description will replace "MyArray" above; that description will be returned by the call to <i>iomessage("name")</i>.
<i>load</i>(<# blue>'F', array FileName,  array VarNameInFile<# black>) -- Returns data that was saved in a specially formatted but human-readable form by function 'save('F', ...)'. Such a file may contain more than one variable; but <i>load('F', ...)</i> will only return data for the variable in the file which corresponds to argument VarNameInFile. This file format is verbose, and so not practical for large arrays; but it has the advantage that it alone allows for scalars to be saved. (This is the one situation in which function 'load' will return a scalar.) (For the curious, the formatting system is detailed at the end of the Help section 'Data I/O and Display'; but such knowledge is not required to use 'load('F', ...)' and 'save('F', ...).)
<i>load</i>(<# blue>'D', array FilePath<# black>) -- Use this where you want to browse for the name of a directory, starting from the given one, but don't want to actually load a file. (<i>FilePath</i> may also be a full file name, or one of some abbreviations - see below under 'FileName'.) The full path of the directory last displayed in the file dialog will be returned.
<i>ERRORS:</i> The function crashes only if the arguments are illegitimate in form - e.g. a scalar where an array is expected, or an improper 'Mode' argument (like 'X'). Where the load fails - e.g. a file or path does not exist, or access is blocked - you find out by calling the two functions <i>iok()</i> and <i>iomessage()</i>, which retain their values until the next disk file operation. The 'load(.)' function itself returns the empty array (length 1, value NaN); but instead of testing for this, you should always use the functions just mentioned.
<i>MORE ON functions <b>iok(), iomessage()</b></i>  in relation to 'load(.)':
 There are 3 main situations:
<bullet><i>Successful load:</i>  <b>iok()</b> returns TRUE and <b>iomessage()</b> returns a single space (unicode 32). <b>iofile()</b> returns the full path and name of the file. (Note that with mode 'D', no file gets loaded, so <i>iofile()</i> is not set.)
<bullet><i>Error occurred:</i>  the directory, the file or the variable within the file were not available. <b>iok()</b> returns FALSE, and <b>iomessage()</b> tells why. The Function <i>load(.)</i> returns the 'empty' array (size 1, value NaN); but it makes much more sense to test <i>iok()</i> than to test the returned value from <i>load(.)</i>.
<bullet><i>User cancellation from a file dialog:</i>  <b>iok()</b> is FALSE, BUT the iomessage() output consists only of a single space. (In all error cases, the message begins with other than a space.)
These further situations occur for "load('A', FileName [, ExpectPrefix] )":
<bullet>If 'ExpectPrefix' is present and 'true', but no prefix could be identified (or it is corrupted):  <b>iok()</b> returns 'false', and <b>iomessage()</b> provides the details; BUT all the data of the file is still returned by the function (rather than just the empty array, as with other errors).
<bullet>if 'ExpectPrefix' is absent or 'false', but in fact the file does have a prefix: What happens is a matter of luck. If the file size - with its prefix included - is exactly divisible by 8, then no error will be detected (how could it be?). In other cases the function will fail, your iomessage() informing you that the file data must be corrupted as its size is not divisible by 8. 
How can you know whether a file holds a prefix or not? There is a way of finding out. See the Hints file entry (by typing 'load' into the Assignments Window and clicking F1).
OTHER USEFUL FILE FUNCTIONS include "choosefilename", "currentdirectory", "homedirectory", "checkdirectory", "filesize".

<B>log</B>(<# blue>Variable [, Variable]<# black>) -- 'log(n)' gives the logarithm of n to base 10; 'log(n,p)' gives the logarithm of n to base p (p must be > 0). In both cases, n must be greater than 0.
<B>logbinom</B>(<# blue>Scalar TopValue, Scalar BtmValue1 [, Scalar BtmValue2] <# black>) -- Returns the logarithm (to base 10) of the binomial coefficient(s). The two-argument value returns a <I>scalar</I> - log of the binomial coefficient (TopValue  BtmValue1); the three-argument value returns an <I>array</I> - log of all the coefficients from (TopValue  BtmValue1) to (TopValue  BtmValue2). Obvious limits apply: TopValue >= 0, BtmValue >= 0 and <= TopValue, and if supplied, BtmValue2 >= BtmValue1. The upper limit on TopValue is hex no. 0x7FFF FFFF, which is 2,147,483,647. For TopValue 170 or below you may prefer to use the non-logarithmic function <B>binom(.)</B> instead.
<B>logfact</B>(<# blue>Variable [, Variable]<# black>) -- 'logfact(n)' gives the log to base 10 of factorial n; 'fact(n,p)' gives in effect logfact(n) divided by logfact(p). Both n and p must lie between 1 and 2,147,483,647 (which is hex no 7FFF FFFF), with p < n. If fractional, they are rounded (see 'round(..)' re same).See also <# blue>fact(..)<# black>. Re accuracy: The error in the log approximation used is extremely good from 3 up (1/50,000,000 at 3; undetectable from 11 up). It is poor for 2, so the algorithm simply calculates log10(2) for this.
<B>lookup</B>(<# blue>VarName (spelled out in a chars. array) [, ResponseIfNotFound, ResponsIfNotAssigned ]<# black>) -- Suppose there is a <I>main program</I> variable "Var1" (of any type). If it has already been assigned a value, you can read that value from anywhere else in the program, whether in the main program or inside a user function, and assign it to another variable using <# blue>xx = lookup('Var1');"<# black>. ('xx' will be an exact copy, and so may accordingly be scalar or an array.) Note that "lookup(Var1)" won't work; the argument must be the name of the variable spelled out between quote marks.
<I>Error responses</I> depend on how many arguments you supply.
 -- One argument - the program crashes, with the appropriate error message.
 -- Three arguments - No crash; if the name can't be idenified, the second argument is returned; if it can but has not yet been assigned a value, the third argument is returned. (If you supply two arguments the second will be ignored; the response will be as for one argument.)
This function allows the user to nominate a variable during runtime, via a dialog box, e.g. to examine its value. 
<b>lop</b>(<# blue>Array,  scalar HowMany [, scalar MinimumLength ]<# black>) -- returns a copy of the data of Array (ignoring its structure) with HowMany elements removed from the end. If MinimumLength is present and ≥ 1, the data will not be lopped shorter than that. Otherwise it is possible to remove all elements, in which case the 'empty' array [NaN] is returned. The 'chars' rating of Array is transferred to the returned array.  No errors raised by inappropriate arguments; negative scalars taken as 0.
<b>mainmenu</b>(<# blue>MenuTitles [, bool MakeVisible ]<# black>) -- reads or alters the visibility status of the main menu item(s).
The one-argument version simply reads visibility. MenuTitles must be a single title, case-sensitive, no spaces: "<# blue>vis_state = mainmenu("File")<# black>". RETURNED: +1, if menu visible; 0, if invisible; -1 if the menu could not be identified.
The two-argument version changes the status (and then returns it, using the same coding as above). In this case you can use more than one menu title, delimited by '|' (but with no intervening spaces). SPECIAL CASE: If MenuTitles is exactly the word "ALL", then all main menus will be made visible / invisible together.
Where any one of the list of menu titles is unidentifiable, -1 will be returned; nevertheless those that could be identified will have their visibility adjusted.
Submenus cannot be affected by this function. Note that all menus return to full visibility after the program ends.
<B>matches</B>(<# blue>Variable1, Variable2 [, scalar Tolerance ] <# black>) -- returns an object with the structure of Variable1 (scalar allowed), scoring every match between a Variable1 element and the corresponding Variable2 element. Where there is a match, a '1' occurs in the returned structure; where no match, a '0'.
If there is a 3rd. argument 'Tolerance' and it is positive, a match is regarded as occurring if the absolute difference between the two elements is <= Tolerance.
Argument combinations allowed are: scalar-scalar;  array-array (of same size, not necessarily of same structure); array-scalar (where the scalar is replaced by a virtual array in which every element has that scalar value).
The complementary function is 'mismatches(.)'. 
<B>matrix</B>(<# blue>NoRows, NoCols [, One or more variables]<# black>) -- creates a matrix of the given size, filled with data from the remaining argument(s) if supplied (otherwise all elements remain zero). Data in the third argument is cycled through until all locations in the returned matrix have been filled, row by row. For example,
		 <# blue>matrix(2, 3, 99)<# black> returns a matrix in which every element is 99;
		 <# blue>matrix(4, 3, 10, 20, 30)<# black> returns a matrix consisting of four rows, each being [10, 20, 30];
		 <# blue>matrix(2, 2,  10, 20, 30, 40, 50, 60)<# black> returns the matrix [10, 20;  30, 40], extra supplied values being ignored.

<B>matrixop</B>(<# blue>matrix <b>SubjectMx</b>,  char. array <b>Operation</b>,   vector or list array <b>Imposed</b> <# black>) -- the purpose of the function is to carry out:
<bullet>A standard arithmetic operation between a matrix and a vector - e.g. to add the contents of a row vector to every row of some matrix;
<bullet>A nonstandard operation, either between a matrix and a vector, or between two matrices of equal total size.
The <b>return</b> is always a matrix of the same dimensions as SubjectMx.
The arguments:
<bullet><b>SubjectMx</b> is any matrix consistent with the operation;
<bullet><b>Operation</b>: Only the first element is read; it must be one of the following. (The operation is always carried out in this order: [SubjectMx element] Opn [Imposed element].)
<bullet 50,➯>"+",  "-",  "*",  "/",  "^";
<bullet 50,➯>"M" -- whichever of the two elements is greater will replace the corresponding element in the returned matrix.
<bullet 50,➯>"m" -- whichever of the two elements is less will replace the corresponding element in the returned matrix.
<bullet><b>Imposed</b> is one of:
<bullet 50,➯>a row vector, its length being the row length of SubjectMx; 
<bullet 50,➯>a column vector, its length being the column length of SubjectMx.
<bullet 50,➯>any structure (other than a vector) which has the same total size as SubjectMx. 
Although it is possible to use the arithmetical operations between two matrices, that is not the intended purpose of this function. Doing so would be much slower than a direct operation.
Examples are shown in the 'Hints' file (key F1 with cursor on 'matrixop').

<B>max / maxat</B>(<# blue>One or more variables<# black>) -- Finds the maximum value within the list of scalars and arrays. For example, if scalar x = 25 and Arr = [5,10,20,30], then 'max(15, x, Arr)' will return 30. The second form 'max<B>at</B>(..)' returns an array of 3 elements, with the following meaning: element [0] is the max value (as returned by the 'max(..)' form); element [1] is the number of the argument which holds it (<I>the first being 0</I>, not 1); and element[2] is its position in that structure (0 for scalars, 0 upwards for arrays). Hence, 'maxat(15, x, Arr)' for the above variables will return [0] = 30, [1] = 2, [2] = 3.  ('maxat(10)' would return [10, 0, 0].)
<B>maxabs / maxabsat</B>(<# blue>One or more variables<# black>) -- Exactly as for max(.) / maxat(.), except that the maximum <I>absolute</I> value is sought. Note that for both functions, the value which is returned is the original signed value, not its absolute value.
<b>menus</b>  --  For the extra main menu item, see 'xmenu'; for the extra graph menu item, see 'gxmenu'; to change visibility of graph fixed menus, see 'gfixedvisible'.
<B>merge</B>(<# blue>two or more arrays 'Arr1, Arr2, ...',  (optionally) two or more scalars 'Extent1, Extent2, ...' ) <# black> -- Returns an array which contains the interleaved data from the argument arrays. The arrays are rotated through continuously in the hunt for data; at each access of the ith. Array, 'Arri', the amount of data extracted for merging will be 'Extenti'. (If that argument is not there, it defaults to 1.) 
The arrays do NOT have to be the same length. Merging continues until a point where one of the arrays, during its turn, has run out of data.
An Extent may be zero (or negative), in which case its corresponding array will simply be ignored in the merging process. However if ALL Extents are zero (or negative) an error will be raised.
The 'chars' rating of the output array is the same as that of the first argument, Arr1.
<u>Example 1:</u>   (No Extents are supplied, so extents default to 1)
	<# blue>Arr1 = data(1, 2, 3);    Arr2 = data(4,5,6);    Arr3 = data(7,8,9);
	Result = merge(Arr1, Arr2, Arr3);  <# magenta>// produces the array { 1, 4, 7, 2, 5, 8, 3, 6, 9 }.<# black>
	<# blue>writeln(Result);<# black>
<u>Examples 2 and 3:</u>
	<# blue>Arr1 = data(1, 2, 3, 4, 5, 6, 7, 8, 9);    Arr2 = data(10, 20, 30, 40, 50);    Arr3 = data(100, 200, 300, 400, 500);
	brr = merge(Arr1, Arr2, Arr3, 3, 2, 1); <# magenta>// Runs out of data halfway through processing Arr2 for the 3rd. time.
	<# blue>writeln(brr);  <# magenta>// The output:  { 1, 2, 3, 10, 20, 100, 4, 5, 6, 30, 40, 200, 7, 8, 9, 50 }
	<# blue>crr = merge(Arr1, Arr2, Arr3, 3, 0, 1); <# magenta>// the same output as you would get with "merge(Arr1, Arr3, 3, 1)"
	<# blue>writeln(crr);  <# magenta>//The output: { 1, 2, 3, 100, 4, 5, 6, 200, 7, 8, 9, 300 }<# black>
The inverse of this function is <B>unmerge(.)</B>.
<b>mesh</b>(<# blue>array XCuts,  array YCuts [, array ZCuts ]<# black>) -- Given a 2D or 3D graph with axis cuts corresponding to the argument arrays, produces a matrix with the coordinates of every hairline intersection. The return is a matrix with as many rows as there are arguments; the first row holds X coordinates, the second row Y coordinates, etc. The order of adressing intersections is from the bottom left corner, across horizontally and then up vertically, row by row, till the top right corner is reached. If this is a 3D graph, these were all for the frontmost plane; the order is repeated for successive planes further back.
<B>min / minat</B>(<# blue>One or more variables<# black>) -- Finds the minimum value within the list of scalars and arrays. For example, if scalar x = 25 and Arr = [5,10,20,30], then 'min(15, x, Arr)' will return 5. The second form 'min<B>at</B>(..)' returns an array of 3 elements, with the following meaning: element [0] is the min value (as returned by the 'min(..)' form); element [1] is the number of the argument which holds it (<I>the first being 0</I>, not 1); and element[2] is its position in that structure (0 for scalars, 0 upwards for arrays). Hence, 'minat(15, x, Arr)' for the above variables will return [0] = 5, [1] = 2, [2] = 0.  ('minat(10)' would return [10, 0, 0].)
<B>minabs / minabsat</B>(<# blue>One or more variables<# black>) -- Exactly as for min(.) / minat(.), except that the minimum <I>absolute</I> value is sought. Note that for both functions, the value which is returned is the original signed value, not its absolute value.
<B>mismatches</B>(<# blue>Variable1, Variable2 [, scalar Tolerance ] <# black>) -- returns an object with the structure of Variable1 (scalar allowed), scoring every match between a Variable1 element and the corresponding Variable2 element. Where the elements are equal, a '0' occurs in the returned structure; where they are not equal, a '1'.
If there is a 3rd. argument 'Tolerance' and it is positive, elements are regarded as being 'equal' if the absolute difference between them is <= Tolerance.
Argument combinations allowed are: scalar-scalar;  array-array (of same size, not necessarily of same structure); array-scalar (where the scalar is replaced by a virtual array in which every element has that scalar value).
The complementary function is 'matches(.)'. 
<B>mod</B>(<# blue>Variable, Variable<# black>) -- mod(x,y) is equivalent to x mod |y| (sign of x preserved). The arguments are rounded, and the result is integral.
<B>moments</B>(<# blue>DataArray [, WithKurtosis]<# black>) -- Returns an array of size 5 (no kurtosis) or 6 (with kurtosis); element [0] is the mean of the data in DataArray; element [1] is the standard deviation and element [2] is the variance, calculated in the statistician's way by dividing the sum of the squares by (size of DataArray)-1; elements [3] and [4] are the same, but using a divisor of just DataArray size. If WithKurtosis is present and 'true' (i.e. anything but 0), [5] is the kurtosis, using the divisor DataArray size. The structure, if any, of the array is ignored.  DataArray must have at least 2 elements, or an error is raised.
<B>monotonicity</B>(<# blue>array <b>InArray</b>,  bool  <b>ExpectAscending</b> [, scalar <b>StartIndex</b> [, scalar <b>VirtualZero</b> ] ]<# black>) -- If the array is expected to be monotonically ascending / descending, this function detects anomalous values. The function also independently detects values which duplicate the preceding value. 
ARGUMENTS
<bullet><i>InArray</i> -- Must have size of at least 2. Its structure will be ignored, so that returned values will be <i>absolute addresses</i> within the array.
<bullet><i>ExpectAscending</i> -- If TRUE, then any successive values which are descending will be regarded as anomalous; if FALSE, any successive values which are ascending will be regarded as anomalous.
<bullet><i>StartIndex</i> -- The array will be regarded as if it started here, all earlier values being ignored. Therefore the earliest anomalous value or duplicated value that could be detected would be at InArray[StartIndex+1]. It is therefore an error for StartIndex to point to the last element of InArray.
<bullet><i>VirtualZero</i> -- If two successive values differ by this amount or less, they will be regarded as equal. It can be zero, but negative values will be ignored (taken as zero).
RETURNED
An array of size 4:
	<# blue>[	No. of anomalous values,   Index of first anomaly,       No. of contiguous duplicates,    First such duplicate  ]<# black>
Re duplications: 
<bullet>A duplication is not considered to be an 'anomaly', so does not register in the first two elements of the returned array.
<bullet>A sequence "n, n, n" would register as two duplicates, "n, n, n, n" as three.
If no anomalies and no duplicates were detected, the result would therefore be [0, 0, 0, 0]. (Note that where no first anomaly or first duplicate exists, the relevant element is set to 0. It could never take this value if there were a first anomaly / duplicate.)
<B>mouse</B>(...) -- supplies data re mouse clicks; see Help menu item <I>Graphing - Interactive</I> for much more detail on this and related functions.
<B>moveshape(..)</B> -- function for repositioning an existing shape plot. Enter the function name into the Assignments Window and key F1 for details.
<b>multibox</b>(<# blue>array Heading, array LayoutString, array Texts, array ButtonTitles [, array TextsDelimiter ] <# black>) -- a dialog box designed by the user (within limits). There are always button(s) at the bottom, but the stuff in between is determined by the arguments. (For a more user-friendly explanation, key F1 with the cursor on 'multibox' in the Assignments Window.)
<i>The first three arguments</i> must all be <i>named arguments</i>. (With other dialog boxes you can e.g. write the heading directly with quote marks into the function; not so with this one.)
<i><u>LayoutString</u></i>: Each widget is represented by a single letter. Where letters are side by side, they will appear in that order from left to right at one horizontal level. To add a new horizontal level below the present one, insert the delimiter '|'. The allowed widget codes are:
	'L' -- a label, with text wrap.
	'l' -- a label, without text wrap. (The window stretches to accomodate long texts.)
	'T' -- a text box.
	'V', 'W' -- a text view, editable; 'W' accepts and interprets text tags.
	'v', 'w' -- the same, but not editable.
	'X' -- a check button, which is to be checked when the dialog opens.
	'x' -- a check button, which is to be unchecked when the dialog opens.
	'R' -- a radio button, which is to be checked when the dialog opens.
	'r' -- a radio button, which is to be unchecked when the dialog opens.
Example: this will give three horizontal layers: a label-text box pair at the top of the dialog, a set of three radio buttons in the middle (the first being checked at entry), and another label-text box pair at the bottom: "LT|Rrr|LT".
Radio buttons are automatically grouped if they are listed side by side in the one horizontal level. Check buttons are also visually grouped in the same way, but can be checked independently of one another.
<i>LayoutString</i> is a REF argument; it returns altered, if there were buttons and their checking was altered. E.g. in the above example, if the user had clicked the third button before closing the dialog, LayoutString would end up as "LT|rrR|LT".
<i><u>Texts</u></i>:  There must be exactly one substring, within the string Texts, for each widget. (In the case of buttons, this is the text that will be printed beside it. In the case of text boxes, it will be the initial text for the box.) Again the delimiter is '|' (unless you alter it - see below), but this time it must be placed between the text of every widget, without reference to horizontal and vertical placement. Texts will be processed in the order in which widgets occur in LayoutString. If you don't want visible text for some widget, you can either make the text a space or else leave it out altogether (E.g. for three labels, <# blue>Texts = "||"<# black> would make them all blank.)
<i>Texts</i> is also a REF argument. It remains as was at entry, except that if text boxes are present, their segments within Texts will be altered, the final text box content being returned. Empty texts will always be represented by a space in the return (even if they were just represented by emptiness in the input value of Texts).
<i><u>ButtonTitles</u></i>:  Button names delimited by '|'. This does not have to be a named array, so you can enter e.g. "ACCEPT|CANCEL" directly as the function argument. Any (sensible) number of buttons can be used.
<i><u>TextsDelimiter</u></i>:  It may be that you want the character '|' to be a valid character to enter into a text box. In that case, you can change the delimiter for Texts (<i>but not for the other arguments</i>) by adding this argument. The first element of the array will be taken as the delimiter. It should be a printable character, avoiding specialized ones (e.g. Chinese symbols) which may not be handled well by the string handling methods of the underlying Mono language. If in doubt, try it out first. The other reason for using a different delimiter would be where you think there is a significant risk that the user will insert a '|' into a text box, even though it is not called for. Doing so will result in a return value of Texts that will be out of synch with that and later widgets.
<i><u>RETURNED</u></i>:  The button value: 1 for the leftmost (i.e. the first referenced in ButtonTitles), 0 for closure of the dialog box by clicking on the corner icon.
You can <i>change box size and position</i> by a prior call to function <b>setbox</b>, as with other dialog boxes. (Small restriction for this dialog: you cannot change box placement unless you also supply specific values for width and height.)
<b>mxcentre</b>(<# blue>char. array <b>Mode</b>,  matrix <b>InMatrix</b> [, bool <b>RoundToNearestEvenNo</b>] <# black>) -- Think of the matrix as a map, subdivided up into squares, each square representing one element of the matrix. The map consists of 'land' (nonzero values) and 'sea' (zeroes). This function returns that square, or matrix element, which is the nearest to the 'centre' of the land. There are two modes, "of rectangle" (giving the centre of the smallest rectangle for which all nonzero values are either inside or on its perimeter); and "of mass" (giving the centre of mass). For much more detail, together with examples, key F1 on 'mxcentre' in the Results Window.
<B>mxdiag</B>(<# blue>Square Matrix, Character Array, Scalar or Array<# black>) -- reads or alters the main diagonal of a square matrix. If one argument only is supplied, the main diagonal is returned as a list array. If three arguments are supplied, a copy of Matrix is returned with altered main diagonal. In this case, the second argument is an array, the first element of which is the character code for one of: '=', '+', '-', '*', '/'. This character is the <I>operator</I>. The <I>third argument</I> can be either scalar or an array. If it is an array, it must have the same length as the side of the square matrix. If it is a scalar, it will be internally replaced by an array which replicates the scalar in every element.
If the operator is '=', the main diagonal is simply replaced by the supplied value(s). In all other cases, 
	new diagonal = old diagonal  <B>.</B>  <I>operation</I>  <B>.</B>  third argument array

<b>mxhalf</b>(.) -- either reads or writes a triangle of the given square matrix. 
<u>READING THE TRIANGLE</u> 
\t<# blue><B>mxhalf</B>(square matrix SqMx, array WhichHalf<# black>) -- arguments as below. Returns a <b>list array</b>, being the data read along successive rows.
<u>WRITING THE TRIANGLE</u> 
If it has at least four arguments, function <B>mxhalf(.)</B> returns a copy of the input square matrix with one of its triangles altered. The opposite triangle may optionally be filled by copying (reflecting), with or without sign change. Optionally the main diagonal may also be altered. The format is:
\t<# blue><B>mxhalf</B>(square matrix SqMx, array WhichHalf, array OtherHalfAction, array Data [, array / scalar MainDiagonal] <# black>)
<u>ARGUMENTS</u>
<# blue>SqMx<# black> -- at least a 2x2 matrix.
<# blue>WhichHalf<# black> -- (Only the first letter accessed; case sensitive.) "L" = lower matrix triangle (i.e. all to left of / below the main diagonal), "U" = upper triangle. Any other value crashes the function.
<# blue>OtherHalfAction<# black> -- (Only the first letter accessed; case sensitive.)   " " (space) =  leave other triangle alone; "C" = copy this triangle to the other (so that SqMx[i,j] = SqMx[j,i], i ≠ j).  "N" = same, but with sign reversal of each element on copying (so that SqMx[i,j] = ‒ SqMx[j,i], i ≠ j).  Any other value crashes the function.
<# blue>Data<# black> -- the data that will fill the given triangle, filling across rows. It must have exactly the right size, which for an NxN matrix is (N<^>2</^> ‒ N) / 2.
<# blue>MainDiagonal<# black> -- If this argument is omitted, the main diagonal is not altered. If present and scalar, that value repetitively fills the main diagonal. If an array, it must have exactly the right length to fill the main diagonal (from above down).

<B>mxmult</B>(<# blue>2-dim. Array, 2-dim. Array<# black>) -- matrix multiplication. Returns a structured array as a matrix. The argument matrices must be compatible (no. columns of first array = no. rows of  second array). One concession: a list array will be interpreted as a <I>row</I> vector, and so would not raise an error where a row vector is allowed. (This is also true with 'transpose(.)', but is not generally true for matrix-handling functions.)
<B>neat</B>(<# blue> variable DisplayObject [, variable Formatting [, variable Tabbing ] ]<# black>) -- Used typically in 'write(..)' and 'writeln(..)', to provide formatted display of matrices and higher order structures. The output is a chars. array, ready for display, and including formatting tags e.g. for colour settings. Consider the single-argument case first. If DisplayObject is a scalar, the result is simply the chars. version of its value (not very useful). If a list array, the output consists of its values either separated by commas and spaces ("1, 3, 5;") or, if a chars. array, as contiguous characters. If a matrix, each row is on a separate line, the line being introduced by the row number. If a higher-dimensional object, each submatrix is headed by the location of its first element (e.g. "[1, 2, 0]"), and the submatrix 's row number again introduces each row. Each row will be as above: values separated by commas or by contiguous characters.
<I>Argument 'Formatting':</I> If a scalar in the range 0 to 15, sets the maximum number of decimal places (rounding occurring if necessary). If a chars. array, it is handed directly to .NET; if it makes sense to .NET (e.g. "E3", "G4"), the formatting applies to all displayed numbers. If .NET raises an error, 'neat(.)' fails with an error message. Any negative value causes this argument to be ignored, so '-1' is suitable if you want a dummy value (where you are setting the 3rd. argument to a functional value).
 To get a list of allowed values, enter 'str' into the Assignments Window, key F1, and scroll down a bit.
<I>Argument 'Tabbing':</I> If omitted, or is zero or negative, the default of no tabbing applies, as in the first paragraph above. If 'Tabbing' is scalar, then the delimiter is a tab, and the interval between tabs is 'Tabbing' pixels. A practical value for up to 3 digits would be 50. 
If 'Tabbing' is a chars. array, its first character is examined. If it is 'C' or 'c', then each row is displayed as a set of contiguous characters (no delimiters), irrespective of its 'chars.' rating. ('neat(.)' always ignores chars. rating, and defaults to displaying numerical values for all arrays.) In this case, the 'Formatting' argument has no effect on the display. If it is 'T' or 't', then tab-delimiting is enforced, the number of 'T's and 't's in the whole array setting the number of default tab steps. (Small print: Scalar values of Tabbing less than 10 have the same effect as multiple instances of 't'; e.g. Tabbing = 3 has the same effect as Tabbing = "ttt".)
Code examples can be found by entering 'neat' into the Assignments Window and then keying F1.
<B>newclick</B>(<# blue>GraphID<# black>) -- If the identified graph exists and has been clicked since its creation and since the last call to this function (if any), TRUE is returned; otherwise FALSE. Each call resets the internal flag produced by the click. This function returns TRUE even while the mouse button is still being held down.
<B>norm</B>(<# blue>Array<# black>) -- returns the Euclidean norm of the array, irrespective of its structure; that is, it returns the square root of the sum of the elements squared. (It has the same effect as "sqrt(dot(arr,arr));" )
<B>not</B>(<# blue>Variable [, Scalar]<# black>) -- If no 2nd. argument, returns a copy of Variable in which all nonzero elements are replaced by 0 and all zero elements by 1. If 'Tolerance' is supplied and > 0,  elements are replaced by 0 if  they are > Tolerance, otherwise they are replaced by 1. The complementary function is 'is(.)'. See also binary logic functions 'and(.)', 'or(.)', 'xor(.)' and 'xorcomp(.)'; and functions 'matches(.)', 'mismatches(.)'.
<B>nozero</B>(<# blue>Variable [, scalar Tolerance ] <# black>) -- returns a pseudoboolean scalar: 1 (true) if <I>no</I>  elements of Variable are zero; otherwise 0 (false). If there is a 2nd. argument 'Tolerance' and it is positive, a 1 is returned if <I>no</I>  elements in Variable have absolute values <= Tolerance. The complementary function is 'allzero(.)'.
<B>nth</B>(<# blue>scalar Number [, bool JustTheSuffix [, bool NoFullStop] ]<# black>) -- Returns a chars. array with the appropriate suffix. Examples: nth(1) --> "1st.", nth(22) --> "22nd.", nth(0) --> "0th.". Sign is preserved:  nth(-3) --> "-3rd.".  The scalar argument is first rounded.
Optional arguments: If 'JustTheSuffix' is present and TRUE, then eg. 23 --> "rd.".  Independently, if 'NoFullStop' is present and TRUE,  then e.g. 23 --> "23rd". (These would be useful where you were using formatted script and wanted to superscript the two letters.)
<B>odometer</B>(<# blue>Named array, Scalar NoBase[, Scalar Direction]<# black>) -- (This function alters the argument array, and returns a scalar indicator.) The fn. treats the array as if it were an odometer, and increments or decrements the mileage. For example, if the array is [1, 2, 2] and NoBase is 3, successive calls (to increment) will change the array to [2, 2, 2], then [0, 0, 0], then [1, 0, 0], [2, 0, 0], [0, 1, 0]...
If Direction is present and any of 'D', 'd' or 0, then decrementing occurs; any other value, or omission, results in incrementing.
Returned value: 0 = returned array has all zeros;  2 = returned array has all digits maximal (i.e. NoBase-1); 1 = any other arrangement.
<B>offset</B>(<# blue>array Struct,  array IndexAddresses<# black>) -- Given an indexed address like "[2,3]" for a matrix or higher-order structure, return its offset address; i.e. its address within the internal data strip which holds all the data of Struct. (Also called 'absolute address' at times.)
<i>Struct</i> is either -
<bullet>A 2D or higher order structure (currently MonoMaths only allows up to 3 dimensions). In this case no data is accessed; the argument is used purely to supply dimensional sizing.
<bullet>A list array. In this case its elements are taken as the dimensions of a hypothetical structure of any number of dimensions, Struct[0] corresponding to the highest address. E.g. if modelling a 6-dimensional structure of dimensions 6x5x4x3x2x1, Struct would be the array [6, 5, 4, 3, 2, 1].
The return depends on the form of argument <b>IndexAddresses</b>.
<bullet>If it is a <i>list array</i>, then it is taken as a single address (and therefore must have a length equal to the number of dimensions of Struct); the return is <i>scalar</i>, the offset address.
<bullet>If IndexAddresses is a <i>matrix</i>, then each row is taken as a separate address (so that the row length must equal the number of dimensions in Struct), and the return is a <i>list array</i> containing the corresponding offset addresses.
The inverse function is <# blue>indexed(.)<# black>.
<B>or</B>(<# blue>Variable1, Variable2 [, scalar Tolerance ] <# black>) -- returns an object with the structure of Variable1 (scalar allowed), assigning a boolean score to every pair of corresponding elements in Variable1 and Variable2. Where <I>either</I> element in the pair is <I>nonzero</I>, the score is 1; the score is only 0 if both elements are zero.
If there is a 3rd. argument 'Tolerance' and it is positive, a match is regarded as occurring if the absolute difference between the two elements is <= Tolerance.
Argument combinations allowed are: scalar-scalar;  array-array (of same size, not necessarily of same structure); array-scalar (in which case the scalar is replaced by a virtual array containing only that scalar value).
See also binary logic functions 'and(.)', 'xor(.)' and 'xorcomp(.)', and unary functions 'is(.)', 'not(.).
<B>overlay</B>(<# blue>array Underdog,  array Overlay, array Operation [, scalar Pointer1 [, scalar Pointer2 ]]<# black>) -- Overlaps Overlay onto part or all of Underdog, the outcome for overlapping elements of the two arrays being decided by argument 'Operation'.
Operation codes are always just a single character. They are as follows. (The next section will indicate which elements in Overlay and Underdog are 'OverlayElement' and 'UnderdogElement' in the following.)
<bullet>The four mathematical signs '+', '-', '*', and '/', the order being "Underdog OPN Overlay". (E.g. '-'  results in the subtraction (UnderdogElement - OverlayElement) ).
And various overwriting operations, where the Overlay element overwrites the corresponding Underdog element:
<bullet>'#' --  overwriting is unconditional; OverlayElement always overwrites UnderdogElement.
<bullet>'\>' -- OverlayElement overwrites UnderdogElement only if OverlayElement \> UnderdogElement.
<bullet>'\<' -- OverlayElement overwrites UnderdogElement only if OverlayElement \< UnderdogElement.
<bullet>'o' -- OverlayElement overwrites UnderdogElement EXCEPT where OverlayElement = 0. ('o' is the lower-case letter, not the zero digit.) 
<bullet>'u' -- OverlayElement overwrites UnderdogElement EXCEPT where UnderdogElement = 0 
<bullet>'b' -- OverlayElement overwrites UnderdogElement EXCEPT where EITHER OverlayElement = 0  OR  UnderdogElement = 0.
In the case where Underdog and Overlay are both LIST ARRAYS, each element of Operation is significant. The element which applies when OverlayElement is Overlay[n] is Operation[n <b>modulo </b>length-of-Operation]. For example,
\t<# blue>aa = overlay( data(10, 20, 30, 40, 50),   data(1, 2, 3, 4, 5),  "+-*", 0); <# magenta>//  aa --> [11,  18,  90,  44,  45]   
<# black>If either (or both) Underdog or Overlay is not a list array, then the only significant element in Operation is Operation[0], which will apply for all Underdog-Overlay interactions.
<u>Allowed Interactions</u>
<i>Overlaying of one list array on another:</i>  Exactly one pointer must be supplied. If this has value n, then Overlay[i] will overlay Underdog[n + i]. The value of 'n' may be negative or beyond the end of Underdog; for any index [n + i] less than 0 or beyond the end of Underdog, no interaction will happen. 
<i>Overlaying of one matrix on another:</i>  Exactly two pointers must be supplied; the first is the row pointer, the second the column pointer. If these have values 'r' and 'c', then Overlay[i, j] will overlay Underdog[r + i, c + j]. The values of 'r' and 'c' may be negative or beyond the extent of Underdog rows / columns; for any index [r + i, c + j] out of range, no interaction will happen. 
<i>Overlaying of a row vector or a column vector across a matrix: </i>  This time there are <i>no pointer arguments</i>; the overlaying always starts at Underdog[0, 0]. If Overlay is a row vector, then the operation will occur between it and each row of the matrix; and analogously for column vectors. There must be an exact match between the length of Overlay and the row / column length of Underdog. (NB - if you want to overlay just one row/col of a matrix with a row/col vector, use the previous method with two pointers, as a vector is stored as a matrix.)

<i>For examples of the use</i> of this function, enter 'overlay' in the Assignments Window and then key F1.
<B>pad</B>(<# blue>array InArr,  scalar DesiredLength, array or scalar PadValue [, bool AndTruncateIfLonger ]<# black>) -- returns a list array (which we shall call OutArr), whatever the structure of InArr. If InArr is shorter than DesiredLength, OutArr will contain it + as many pad values as necessary to reach DesiredLength. If PadValue is an array, its first element is taken as the pad value. If InArr is longer than DesiredLength, OutArr simply copies it unless the 4th. argument is present and nonzero, in which case it is trimmed to DesiredLength. (For truncating only, without padding shorter arrays, see fn. "truncate(.)" ). OutArr has the same characters rating as InArr.
This function can take an 'empty' array as its argument (i.e. an array of length 1, content NaN), in which case the whole returned array will consist of PadValue. (Fails in the unlikely event that DesiredLength is 1.)
<B>paintshape(..)</B> -- function for recolouring an existing shape plot. Enter the function name into the Assignments Window and key F1 for details.
<b>palette</b>(<# blue> [ matrix UserPalette, ]  scalar Index<# black>) -- Index has its absolute value, modulo (length of the palette), taken, and this modulus then retrieves a colour from the palette. The one-argument version uses an internally set palette consisting of 10 colours: <# blue>0:"blue"; <# red>1: "red";  <# green>2: "green";  <# orange>3: "orange";  <# magenta>4: "magenta";  <# darkviolet>5: "darkviolet";  <# deepskyblue>6: "deepskyblue";  <# brown>7: "brown";  <# grey>8: "grey";  <# black>9: "black".
The two-argument version requires UserPalette to be a matrix of unicode characters, typically a jagged matrix, each row representing one colour as a string (either as a colour name, like "red", or in the hexadecimal format "0x88ffff" - "0x", then two R digits, two G digits, then two B digits). Errors in colour names would not be detected here, but in whatever function uses the colour (e.g. 'plot(.)').
<B>pause</B>(<# blue>Scalar 0 to 9<# black>) -- Pauses the program; to continue the program, click on 'GO'. All ten pauses can be activated (i.e. made able to pause) or inactivated (i.e. nothing happens when the function is called). Activation can be toggled either programmatically (see 'pausable(.)') or from the keyboard ([Cntrl-Shift-P] + [0 to 9]). Pause 0 is active from the start, but pauses 1 to 9 are inactive at the start.
When the program has been paused the line containing the active pause will have a special colour (which you can reset from the 'View' menu, if you so desire).
Lazy man's way of inserting the phrase 'pause();' -- use the key code 'Cntrl - #' (UK keyboard).
<B>pausable</B>(<# blue>Scalar N = 0 to 9 [, Scalar 0 (TRUE) or 1 (FALSE) ] <# black>) -- Used in conjunction with function 'pause(.)'. The one argument version simply tells whether pause no. N is activated (i.e. whether a call to 'pause(N)' will actually cause a pause, or will be ignored). It returns 1 (true) or 0 (false). The two-argument version actually sets the activation status of the pause; any value other than exactly 0 will be taken as TRUE (i.e. activate the pause). (The function still returns the final activation status, though this would be already known.)
<I>Hint:</I> Quite apart from pausing, this function can be used to cause switching from the keyboard during program execution. A section of code to be switched in / out during runtime can be enclosed in: <# blue>if (pausable(1)) { ... }<# black>. The keypress indicated above under <I>pause(..)</I> will then switch this code segment in or out.
<B>peck</B>(<# blue> array Subject,  scalar Sought [, scalar Replacemt]<# black>) -- alters Subject itself (i.e. does not copy it). Looks for the first (and only the first) instance of Sought. If found, the action depends on the number of arguments. (1) <I>2-arg. version:</I> if Subject is a list array, the instance is removed, thus shortening Subject by one. (If it is a structured array, the function crashes, as there is no sensible way to shorten it). (2) <I>3-arg. version:</I>  the instance is simply replaced by Replacemt, the structure of the array remaining unchanged.
The function returns 1 (TRUE) if a find has occurred (along with a replacement / removal), and 0 (FALSE) if not. (Note that it does not return -1 for a no-find, in this respect differing from function 'find(.)')
In the 2-arg. version, if the returned array would logically be empty (from pecking for 'n' in an array of length 1, with [0] = n), then its single value is changed to NaN, and a call to 'empty(.)' will return TRUE. (The function's returned value would still be 1, reflecting a genuine find.)
<b>persistent_array</b>(..) -- gets or sets an internal array which MonoMaths always sets to the 'empty' array when the instance starts, but only thereafter resets it via this function; consequently its value persists across any number of user program runs which don't call this function. To get data, call it with NO argument (or a scalar argument). To set data, call it with the new data as the single argument; used in this way the function is void.
<B>perturb</B>(<# blue> array Subject,  scalar SD,  scalar MaxDeviation<# black>) -- Returns an array of the same structure as Subject, made up of the values of Subject perturbed in a Gaussian random manner in accordance with the given SD. Both SD and MaxDeviation must be \> 0. MaxDeviation should not be \<\< SD, unless you are prepared to wait a very long time (as random deviations are continually generated internally and discarded until they lie within range).
See also function <# blue>randgauss(.).
<B>pgm_load</B>(<# blue>array Data;  array Mode<# black>) -- the current program will stop and new data will replace it in the Assignments Window. Two scenarios:
<i>Case 1:</i>  Load a program in a disk file: 'Data' is the path and file name, and Mode is 'F' or 'f'. (The rules for this file name are exactly as for e.g. function 'load(.)'; in particular, the abbreviation "~/" for the home directory is allowed.)
<i>Case 2:</i>  No files are involved: 'Data' is the text that you want to load. In this case, Mode is 'T' or 't'.
If you not only want to load a program but also have it automatically run, use the sister function <i>run(.)</i> instead.
<B>pixels</B>(<# blue> one argument<# black>) -- Used in two different forms.
<u>Form 1:</u>  The argument is a <i>scalar</i>, the graph ID for an existing graph. Always returns an array of size 4. For 2D graphs, [0] = width of a pixel in terms of the X axis variable; [1] = height of a pixel in terms of the Y axis variable; [2] = number of pixels from left to right of the plottable surface; [3] = same, vertically. For 3D graphs, [0] and [1] are always simply 0, and [2] and [3] give the width and height of the blue-lined box which contains the actual 3D plot region together with the region to its right where descriptive data goes. If the graph cannot be identified, the return is { -1, -1, -1, -1 }.
<i>Caveat:</i>  If used after 'graphresize(.)', you have to allow time before calling 'pixels(.)', or you are given the sizes that predated the 'graphresize(.)' call. Insert a step like this:  "starttimer();  while (timer() < T) { dummy = 1; }", where T  is found by experiment. (On my current computer, T = 100 (msecs) is safe;  T = 40 to 60 fails some of the time;  smaller T always fails.)
<u>Form2:</u>  The argument is an <i>array</i>. [Currently, any array will do; but in case of future extensions, always use the word 'screen' to ensure compatibility.] The return is an array of size 2; [0] = the screen width, in pixels; [1] = the screen height.
The scenario: You have a <i>reference array</i> containing values sorted in ascending order. You also have some new value, and you would like to know where it might fit into the sorted array, if it were to be inserted there. The function to use is:
<b>placement</b>(<# blue>scalar / array Value,  array RefArray [, scalar StartIndex ]<# black>) -- returns a set of virtual fractional indexes, or 'placements', for each of the values in Value; the returned structure has exactly the same dimensionality as Value.
It is <b>vitally important that RefArray be sorted</b>, in ascending order. There is no test for this; you will simply get meaningless results if you don't observe the rule. Duplications are tolerated, but for all i \> 0 it must be true that RefArray[i-1] ≤ RefArray[i].
There is no such restriction on Value; however if Value is even approximately in ascending sorted order, operation is many times faster. (This is because internally the placement of Value[i] starts from the placement of Value[i-1] if it is found that Value[i] \> Value[i-1].)
These placements take the form of virtual indexes, for which fractional indexes are possible. Suppose Value[i] is V. Then if V = RefArray[N], the return will be N; but if V is halfway between RefArray[N] and RefArray[N+1], the return will be (N + ½).
More exactly, here are the rules. Suppose we have a Value element V; we define 'result' as what will be returned for V. 
<bullet>If V  \< RefArray[0],  then return = NEGINF.
<bullet>If V = RefArray[N],  then return = N.
<bullet>If V \> RefArray[N]  but  V \< RefArray[N+1],  then return = N +  (V - RefArray[N-1]) / (RefArray[N] - RefArray[N-1] ).
<bullet>If V  \> the last element in RefArray,  then return = POSINF.
If <i>StartIndex</i> is supplied, then the search for all elements of Value begins only at that index of RefArray. (If Value is fractional, it is adjusted to the nearest integer below. If Value is negative, it is adjusted to 0.) If you are going to use this argument, bue careful to ensure that it is definitely lower than a possible placement; otherwise it will return NEGINF. For example, if RefArray is [10, 20, 30], and Value is 25, then a StartIndex of MINREAL to +1.9999... will return a placement of 1.5; but a StartIndex of 2 or more will return NEGINF. 
Two more points:
<bullet>Duplications within RefArray are not a problem; simply the duplicated values will be hopped over. For example, if RefArray where [10, 20, 20, 20, 30], then V = 15 would return 0.5,  V = 20 would return 1, V = 25 would return 3.5.
<bullet>If Value has been mathematically derived, then tiny numerical rounding errors may have pushed some value that should be, e.g. 10, to being 10 ± 1e-15. To allow for this, any value closer to RefArray[N] then <b>1e-10</b> is regarded as equalling RefArray[N]. This is particularly important if V should equal either the first or last element in RefArray, as a slight numerial error taking V from RefArray[0] to, say, RefArray[0] - 1e-15, would return NEGINF rather than the logically expected 0.
The inverse function is <b>interpolate(.)</b>  (version 1). An example of the use of the two together is given in the 'hints' file (key F1 on the function name).
See also function 'readtable'.
<B>place</B>(<# blue>Array, Scalar LowLimit[, Scalar HighLimit]<# black>) -- <# red>[Deprecated - use 'placement' instead]<# black> -- returns the index of the first array element which is at or above LowLimit and also at or below HighLimit. (If HighLimit is not supplied, there is no upper limit to be satisfied.) Returns -1 if no array value is in range.
<B>places</B>(<# blue>Array, Scalar LowLimit[, Scalar HighLimit]<# black>) -- <# red>[Deprecated]<# black> -- differs from the above in returning an array of size 6, which contains more information. If we call a value 'in range' if it is at or above LowLimit and also at or below HighLimit, then array values have the following meanings: [0] = index of first value in range (= the same that 'place(.)' would return). [1] = index of last value in range. (If no values are in range, both return as -1.)   [2] / [3] = the number of values <I>between these indexes</I> which are below / above range;  [4] / [5] = the number of values <I>throughout the whole array</I> which are below / above range.
<# blue>\tarr = data(-100, 100,  1, 2, -100, 100, 100,  3, 4, 5); 
<# blue>\tpls = places(arr, 1, 3);  writeln(pls);  <# magenta>// -->  pls = [2, 7, 1, 2, 2, 5]
<# black><B>placeboard</B>(...) -- two versions:
<# black><B>placeboard</B>(<# blue>scalar GraphID, char. array PutItWhere)<# black>) -- VOID. Leaves the current board dimensions as is, but places it in one of nine positions in accordance with the value of PutItWhere. Allowed values (case-sensitive) are: "top_left", "top_mid", "top_right", "mid_left", "mid_mid",  "mid_right", "btm_left", "btm_mid", "btm_right", with obvious meaning. (only the first 3 letters of each half of PutItWhere are parsed.) Errors in PutItWhere generate a dialog message but do not crash the program; the graph remains in its preexisting position.
<# black><B>placeboard</B>(<# blue>scalar GraphID,  scalars &/or array(s): Left, Top, Width, Height)<# black>) -- VOID. Attempts to set the overall graphing board dimensions and placement according to the arguments. The rules for the four values:
<bullet>Value negative: Accept the existing parameter.
<bullet>Value in the range 0 ≤ Value ≤ 1: the value is taken as a fraction of screen height or width, as appropriate.
<bullet>Value > 1: the rounded Value is taken as a number of pixels. (If you intend an offset to be just 1 pixel, enter e.g. 1.1 instead.)
As above, no errors crash the program. If the number of arguments is wrong, you get a dialog box with error message. If the values are ridiculously large, GTK will do whatever it will with your graph, but no crash should occur.
<B>playsound</B>(<# blue> FileName[,  bool WaitTillSoundFinished ] <# black>) -- plays a recorded sound (typically a .WAV file) stored at FileName. If the file is not found or is not playable, no error is raised but no sound occurs. If 'WaitTillSoundFinished' is present and nonzero, program operation stops till the sound is finished; otherwise the program continues on while the sound is occurring on another thread. Normally you don't want this wait; but you have to use it if you are going to queue sounds, as otherwise the only sound you will here will be the last in the queue. 
<B>plot(..), plotmesh(..), plot3d(..), plotmesh3d(..)</B> -- functions for creating a plot, ready to apply to a graph. Too complex to describe here - see Help menu item <I>Graphing - Basic</I> for more details on the use of these functions.
<b>plotbins</b> plots bins of data in histogram form. There are two versions: <B>plotbins</B>(<# magenta>matrix Mx <# blue>[, scalar BarWidth [,  scalar/array LineShape [, scalar LineWidth [, scalar/array LineColour [, scalar/array FillColour ]]]]]<# black>), -- OR -- <B>plotbins</B>(<# magenta>array LeftEdges, array RightEdges, array Heights <# blue>[, scalar BarWidth [,  scalar/array LineShape [, scalar LineWidth [, scalar/array LineColour [, scalar/array FillColour ]]]]]<# black>)
Note that the arguments in blue are the same in both cases. The three magenta arrays in the second form are formatted exactly as for the first three rows of the matrix supplied by function <b>setbins</b>.
'BarWidth' sets the width on the graph of the bar, as a fraction of the X axis extent that it represents. If set to 1, bars will be touching; if very small, bars will be needles. (Values ≤ 0 or \> 1 are reset internally to the default 1).
All the blue arguments from 'LineShape' on are as for other plotting functions - may I refer you to the help notes for function <b>plot</b>? (Small difference - there is no equivalent to the 'plot' function argument 'LineFamily', so you can't e.g. have different lines or colours for different bars within the one graph.)
The outcome is not a single plot, but an <i>array of plot IDs</i>, one plot for each bar.
<b>plotmx(.)</b> -- function for plotting a sequence of curves contained in a matrix. Too complex to explain here. Key F1 with the cursor on 'plotmx' in the Assignments Window.
<B>plotshape(..)</B> -- function for creating a complete shape plot, ready to apply to a graph. Too complex to describe here - Enter the function name into the Assignments Window and key F1 for details.
<B>plotsof</B>(<# blue>scalar GraphID<# black>) -- returns an array. If the graph exists and has plots, the array length is the number of plots in the graph, and the array elements are the plot IDs. Failure produces an array of size 1, value NaN; a  call to 'empty(.)' returns TRUE.
It is safe to use this function inside 'addplot(.)', 'killplot(.)' and 'removeplot(.)', even if 'plotsof(.)' returns the failure array just mentioned. For example, "addplot(Graph2, plotsof(Graph1));" can be used to copy all the graphs of Graph1 across to Graph2.

<b>plu(...)</b> -- Returns the singular or plural form of supplied text, according to a supplied value; if the value is exactly 1, the input text is returned as is; any other values returns the pluralized form of the text. There are four forms:
<b>plu(<# blue>char. array Text,  scalar Value<# black>)</b> -- Returns the singular or plural form of Text. If Value is exactly 1, Text is returned as is; if any other value, its plural form is returned. An attempt is made to adjust the plural form according to the ending: "cat" --> "cats"; "city" --> "cities"; "boss" --> "bosses"; "dash" --> "dashes"; "catch" --> "catches". The algorithm is not extensive; you can fool it ("child" will not go to "children"; "locus" will not go to "loci").
The <i>letter case</i> of alterations to Text will be the same as that of the last letter of Text. 
<b>plu(<# blue>scalar Value,  char. array Text<# black>)</b> -- Exactly the same, except that the value itself is returned before the plural form: "1 cat", "2.54 cats", ... 
<b>plu(<# blue>array Text,  scalar Value, array PluralText<# black>)</b> -- If Value is exactly 1, Text is returned as is; if any other value, PluralText is returned instead. It is intended for irregular plurals: <# blue>plu("child", 2, "children");<# black>. But no analysis of Text occurs; therefore this could be used in any situation where any array is to be conditionally replaced by any other array.
<b>plu(<# blue>scalar Value,  array Text, array PluralText<# black>)</b> -- As above, but with Value preceding the text, as for the second case above.
<b>pointsof(<# blue>scalar PlotID,  bool ScaledCoordinates [, bool OriginalShape ]<# black> )</b> -- returns point plotting details for the given plot. See 'Hints' (by keying F1 with the cursor on the name in the Assignments Window) for details and examples.
<B>poke</B>(<# blue>structured array Subject, array of Indices, array of Values OR scalar SingleValue<# black>) -- A VOID function. Use this if you have an array 'Subject', and you want to change values at some particular locations. The locations are defined in the array Indices; the values you want to insert are listed in the array Values. If Subject is an MxN matrix, then Indices will consist of ordered pairs [m1, n1, m2, n2, ...], the outer dimension preceding the inner dimension. Likewise if it is an MxNxP structure, Indices must take the form [m1, n1, p1, m2, n2, p2, ...]. If the last argument is scalar, that value will go into every location indicated by the 2nd. argument; if an array, then for each such set of coordinates there must be one corresponding value in the array Values, which will be inserted into Subject.
While the structure of Subject is important, that of Indices and Values is ignored. If, for example, Subject were a matrix, and Indices were a matrix with rows of length 2, each row corresponding to one coordinate of matrix Subject, then the function would work just fine..
<B>pokecols</B>(<# blue>matrix Destination, list array ColumnNos, matrix Source<# black>) -- A VOID function. Destination is a preexisting matrix, which is to have some of its columns replaced. Source is an array of these replacement columns (i.e. a matrix), and ColumnNos tells where, in Destination, each column is to go: the nth. <I>row</I> (not column) of the Source matrix becomes the (ColumnNo[n])th. <I>column</I> of matrix Destination. Obviously the size of ColumnNos and the number of <I>rows</I> in Source must be the same. The inverse operation is <# blue>selectcols(..)<# black>.
<B>pokerows</B>(<# blue>matrix Destination, list array RowNos, matrix Source<# black>) -- A VOID function. Destination is a preexisting matrix, which is to have some of its rows overwritten. Source is an array of the replacement rows (i.e. a matrix), and RowNos tells where, in Destination, each row is to go: the nth. row of the Source matrix becomes the (RowNos[n])th. row of matrix Destination. Obviously the size of RowNos and the number of rows in Source must be the same. The inverse operation is <# blue>selectrows(..)<# black>.
<B>polar</B>(<# blue>Var1 [, VirtualZero]<# black>) -- Nonvoid; given a complex array in rectangular form, returns its polar equivalent. (For explanation of 'complex array' as occurring in <I>MonoMaths</I>, see function <B>complex(.)</B>). If VirtualZero is present, then any amount with absolute value smaller than it is treated as zero, for both the input and output.  The inverse of this function is <B>rect(.)</B>.
<B>polystring</B>(<# blue>array Polynomial [, scalar Precision [, bool PowersAsSuperscripts [, char. array IndepVariable ]]]<# black>) -- Accepts a polynomial as an array (ordered by ascending index). If Precision has a value from 1 to 15, then that number of significant digits is used; .NET decides whether to use a fixed decimal format or an exponential format, using whichever is shorter. (Faulty argument invokes a default of five significant digits.) If PowersAsSuperscripts is present and TRUE, then superscript tags are added; these will be recognized by 'show(.)' and 'writeln(.)' to display powers as superscripts. Otherwise powers are represented with carats: "X^2". The default text for the independent variable is "X". If the final argument is present, its contents will replace this default.
<b>pop</b>(<# blue>NAMED array <b>Stack</b>,  scalar <b>HowMuchData</b> [,  bool <b>PopFromLowEnd</b> ]<# black> ) -- a NONVOID function,  which <i>both</i> returns the popped data  <i>and</i> changes Stack directly (by removing from it the popped data). 
<bullet><i>Stack</i>:  As for the inverse function <# blue>push(.)<# black> - whic see - this is either a list array or a matrix; and again, the two are handled differently. It is again permissible to start with an 'empty' Stack (i.e. the list array [NaN], or a matrix consisting of one row with all values NaN).
<bullet><i>HowMuchData</i>: If Stack is a list array, this is the number of elements you want. If Stack is a matrix, it is the number of rows. (You may not get all that you want - see under 'returned' below.)
<bullet><i>PopFromLowEnd:</i>  If this argument is <i>absent</i>, or is set to TRUE, data is taken from the low-index end of Stack; otherwise from the high-index end.
RETURNED: Always a list array. If there was enough data in Stack, this will be the amount of data that you requested. If not, it will be the whole contents of Stack. If Stack was already empty, the return is the 'empty' array, [NaN].
If Stack is left empty by your popping, it will become an 'empty' array. If it was a list array, this will be the list array [NaN]. If it was a matrix, this will be a 1xN matrix containing nothing but NaN. (In both cases, the function "empty(.)" would return TRUE for Stack.)
<B>populate... through... using...</B> This is a syntax rather than a function, but is described here for convenience. Functions 'fill(.)' and 'ladder(.)' are fine for filling an array with data that increases linearly or according to a power series. But what if you want to fill a large array with nonlinear data, you use 'populate'. (Two examples of use are in the 'hints' file, so can be displayed by keying F1 while the cursor is at 'populate'.)
<U>Version 1</U> 
<# blue><B>populate </B>Struct<B> through </B>aa, bb, cc <B>using</B> Foo;
<# black>Note that -
<bullet>'Struc' is created by the statement, so does not have to be declared beforehand.
<bullet>There is a list of one or more comma-separated arrays aa, bb, ... , one for each dimension of Struc. The dimensions of Struc will be A x B x C x ..., where A is the length of aa, B of bb, etc.
<bullet>A user function (here, 'Foo') is referenced. You can use just the name - without brackets and arguments - or can supply the argument list: 'Foo(a, b, c, ...)'.
<bullet>You must have written such a function Foo(x, y, ...) with at least as many arguments as there are arrays aa, bb,...; and it must return a scalar value. (If there are extra arguments, obviously you cannot use the function name alone, without an arguments list.)

<U>Version 2</U> 
<# blue>dim(Mx, 11, 21);
<# blue>populate Mx through <B>(</B>low1, high1<B>),(</B>low2, high2<B>)</B> using Foo;
<# black>Note that -
<bullet>The array Mx is predimensioned.
<bullet>There is a list of one or more bracketted sets (low, high), one for each dimension of Mx (optionally with commas between bracketted sets). They represent ranges of values, equally spaced, one for each element of the corresponding dimension of the array.
<bullet>The value of Mx[p, q] will be given by Foo( [the pth value in the first range], [the qth. value in the second range]).

In version 1, there is no need for arrays aa, bb... to be arithmetic progressions, or even in ascending order; their values are arbitrary. It is therefore more generally applicable than version 2.

<U>More on the Function Name:</U>
If the function has exactly as many arguments as there are dimensions to the first array ('Struc' and 'Mx' in the above examples), you can omit the arguments as above; writing any of "Foo(a, b)",  "Foo" or even "Foo(boo, hoo)" - will have the same effect. (The last because the first arguments are ignored and overwritten by values from the 'through' arrays.) If the function has more arguments, then the extra ones will be faithfully preserved. E.g. for a matrix as the 'populate' argument, "Foo2(x, y, 100, p+1)" would replace the first two arguments but leave the last two to values which were provided before the 'populate' code. 

<b>prevalence(<# blue>InArray, ...<# black>)</b> -- gives the frequency of occurrence of values within InArray. There are two distinct modes:
<b>prevalence(<# blue>InArray,  scalar OnlyIfDuplicatedThisOften [, IgnoreThisValue ]<# black>)</b> -- returns a matrix in which row 0 holds all the values of InArray and row 1 holds the number of times each is represented. The matrix is sorted on the second row, in descending order, so that the most frequently occurring value is in the 0th. column. (Sorting does not occur within ties; e.g. if '1', '2' and '3' all occur with the same frequency, their order with respect to one another is indeterminate.)
<i>OnlyIfDuplicatedThisOften</i> is rounded (and converted to 1 if \< 1). The output matrix only includes those values which occur at least this number of times. If no values are so duplicated, the 'empty' array { NaN } is returned.
If <i>IgnoreThisValue</i> is present, then the result will be as if InArray did not contain any instance of ThisValue.
<b>prevalence(<# blue>InArray,  array LoValues [ , array HiValues ]<# black>)</b> -- gives the frequency of occurrence of particular values within InArray, rather than the full spectrum of values. It returns a list array - call it 'Result' - which is longer than LoValues by one. Where there is no third argument, values in InArray which exactly match values in LoValues are scored; and Result[i] will contain the number of occurrences of LoValues[i]. The last element of Result will give the number of elements of InArray which do not occur in LoValues. Where there is a third argument, Result[i] will contain the number of occurrences of InArray elements 'v' such that  LoValues[i]  ≤  v  <  HiValues[i]. (Note that the upper limit is excluded.)  The last element of Result will again contain the number of elements of InArray which did not lie within any of the given ranges.
See also functions <# blue>removedups(.),  removeruns(.)<# black>.
<B>primes</B>(..) -- Computes a range of prime numbers. NB: this function uses the simplest of algorithms (a sieve), and so is only useful for something of the order of the first 100,000 primes, but depending on your computer. (Mine, a cheapish laptop of 2010 vintage, takes 0.6 secs. to return 100,000 primes, and 20 secs. to return the first million primes. Just don't try to print them all out in the Results Window!) It is therefore not intended for numerical research, but for situations where you need a set of numbers guaranteed not to have common factors. The best way to explain the arguments is by examples:
<I>(a) Using Cardinal Numbers:</I>
\t<# blue>arr = primes(11,20); <# magenta>// returns all primes between 11 and 20 inclusive.
\t<# blue>arr = primes(11, 0, 10); <# magenta>// returns 10 primes, starting with 11. Note that the middle argument is now zero 
\t\t<# magenta>// (or it can be negative), which tells the program to ignore it and use the third argument instead.
\t<# blue>arr = primes(9, 0, 10); <# magenta>// returns the same as the above, as 9 is not prime.
\t<# blue>arr = primes(14, 16); <# magenta>// returns an array of size 1, value 'NaN' - i.e. no primes.

<# black><I>(b) Using Ordinal Numbers:</I>
Ordinal numbers are those with 'st.', 'nd.', 'th.' after them. The first prime is 2 in this system.
It is <I>the presence of a fourth argument</I> which tells you that you are using ordinal numbers; it does not matter what that argument is. A good choice is the explicit array "th", but you could just as easily use 0.
\t<# blue>arr = primes(1, 100, 0, 'th'); <# magenta>// returns all from the first to the hundredth prime.
\t<# blue>arr = primes(4, 0, 10, 'th'); <# magenta>// returns 10 primes, starting from the 4th. prime (which is 7).
\t<# blue>arr = primes(1000, 0, 1, 'th'); <# magenta>// returns the thousandth prime (in an array of size 1).
\t<# blue>arr = primes(1000, 1000, 0, 'th'); <# magenta>// does the same.
<# black>Where there are no primes in range, an array of size 1, value NaN, is returned, and an immediate call to function 'empty(.)' returns TRUE.
<B>prodrows</B>(<# blue>Mx [, FromRow [, Extent [, IgnoreZeroes]]]<# black>) -- returns a list array whose length is the length of a row of Mx, and whose ith. value is the product of all the elements in the ith. column of Mx. If the 4th. argument is supplied and nonzero, then any zeroes <I>after the first</I> in a column will be ignored (i.e. treated as if they were 1).
If 2nd. +/- 3rd. arguments are supplied and are wrong, the outcome is as if the matrix had rows of zeroes extending to infinity both before the first and after the last row; for example, FromRow = -1 with Extent = 1 would return an array of zeroes (the values of virtual 'row -1'). Similarly, Extent <= 0 returns an array of zeroes. The only error raised is if Mx is not a matrix.  (See also 'sumrows' and 'sumcols'.)
<B>prodcols</B>(<# blue>Mx [, FromCol [, Extent [, ZeroesToOne ]]]<# black>) -- the column equivalent of 'prodrows(.)'; it behaves in exactly the same way.
<B>product</B>(<# blue>Array [, ZeroesToOne]<# black>) -- the product of all the contents of the array (irrespective of its structure). If the 2nd. argument is supplied and is not zero, then any zeroes <I>after the first</I> will be ignored.
<B>programfile</B>(<# blue>scalar Dummy or array WhichPart<# black>) -- Always returns a chars. array, the path and/or name of the current MonoMaths user program. (If the program has never been saved to disk, an error will be raised.) <i>Argument:</i>  If a scalar argument, the whole file path and name is returned. If an array, its first character is checked; if 'P' or 'p', only the path is returned (terminated by the character '/'); if 'N' or 'n', only the name is returned; anything else defaults to returning the full path and name.
<B>progressive</B>(<# blue>array Subject,  array Operation<# black>) -- Operation can be  '+'  or  '*' (only the first character is checked). 
Used to perform cumulative operations on array Subject. Returns an array of the same structure as Subject (but as a non-chars. array).
If Operation is '+', then the nth. term of the output array is the sum of all of the terms in Subject up to and including the nth. term.
If Operation is '*', then the nth. term of the output array is the product of all of the terms in Subject up to and including the nth. term.
<b>push</b>(<# blue>NAMED array <b>Stack</b>,  array / scalar <b>NewData</b>,  scalar <b>SizeLimit</b> [,  bool <b>PushOntoLowEnd</b> ]<# black> ) -- a VOID function, changing array Stack directly. 
<bullet><i>Stack</i>:  Is either a list array or a matrix. (The two are handled differently, as explained below.) It is permissible, and often very useful, to start with an 'empty' Stack. If the stack is to operate as a list array, Stack would be set to data(NaN). If the stack were to be a matrix, instead you would make Stack a 1xN matrix (N being the intended row length), all its values being NaN. In either case the contents of Stack would be replaced by that of NewData.
<bullet><i>NewData</i>: If Stack is a list array, this can have any length. If Stack is a matrix, the length of NewData must be an exact multiple of the length of one row of Stack.
<bullet><i>SizeLimit</i>: The stack may grow until this limit is reached; thereafter it stays the same size, as much being discarded from one end as is being added on at the other end. NB - when Stack is a <i>matrix, SizeLimit is a number of rows, not a number of elements</i>.
<bullet 30,>  No internal adjustments are made to SizeLimit; it must round to at least 1. If you want your stack to have unbounded size, set SizeLimit to some ridiculously high value.
<bullet><i>PushOntoLowEnd:</i>  If this argument is <i>absent</i>, or is set to TRUE, data is added onto the low-index end of Stack; otherwise onto the high-index end.
The inverse function is <# blue>pop(.)<# black>.
<# black><B>rad</B>(<# blue>Variable<# black>) -- converts the variable from degrees to radians. No cutoff values; for example, rad(720) will return 4*PI, rad(-720) will return -4*PI.
<B>rand</B>(..) -- generates a random no. of uniform distribution. It comes in one VOID and two NONVOID forms. 
<bullet>"p = rand(scalar N)" - Nonvoid; returns a single random number. If N (rounded) is 1 or less, this generates a random no. in the range 0 \<= N \< 1.0.  If N (rounded) is 2 or more, a random integer from 0 to (rounded) N - 1 is generated. 
<bullet>"arr = rand(scalar Size, scalar N [, bool NoDuplications] ) - Nonvoid; returns a list array of size 'Size', N functioning as above. If N >= 2 (so that an integral value is returned), then a 3rd. argument, if present and 'true', ensures that no value in the returned array will be duplicated. (If N < Size, this is impossible; an error will be raised.)
<bullet>"rand(ArrName, scalar N [, bool NoDuplications] ) - Void; the array's contents are overwritten by random numbers. The remaining arguments function as above.
If 'Size' is < 1 or 'ArrName' is invalid, an error is raised.
See also <# blue>seed(..)<# black>, where generation is discussed.
<B>randgauss</B>(..) -- generates a random no. of Gaussian distribution. It comes in a VOID and a NONVOID form. The nonvoid form first:
\t"<# blue>x = randgauss(mean, SD [, LowLimit, HighLimit] );<# black>" generates a value with mean and standard devn. as shown. The extremes of possible returned values are 5.476 standard deviations from the mean. You can supply <I>exactly</I> two further scalar arguments, LowLimit and HighLimit. If they are present, the function will only return values within that range (inclusive). But there are restrictions: (1) the window must be wider than SD/10 (the underlying algorithm would take too long, as it has to keep producing values till it finds one in range); and (2) the window must not be further away from the mean than 4 SD's (for the same reason). In both cases an error will be raised.
\tAnd the void form:
\t"<# blue> randgauss(xx, mean, SD [, LowLimit, HighLimit] );<# black>" fills variable xx (whether scalar or array) with random gaussian numbers over the same range as above. This form also may have exactly two extra parameters, precisely as above.
\tSee also <# blue>seed(..)<# black>, where generation is discussed.
<b>randrange</b>(<# blue>NamedVariable, scalar / array LowLimit, scalar / array HighLimit [, IntegersOnly] <# black>) -- Always VOID. The first argument must be either a named array or a named scalar; the random values will be inserted into the variable, overwriting any preexisting data. If the limits are the wrong way around, they will be reversed internally. If the last argument is present and TRUE, then LowLimit and HighLimit will be rounded, and returned values will be integral, in the range INCLUSIVE of both limits.
If LowLimit and HighLimit are not both scalars, then they must both be arrays, and must have the same length as NamedVariable (which cannot be scalar); in this case, NamedVariable[i] will be developed using limits LowLimit[i] and HighLimit[i].
<b>randsign</b>(scalar or array Original [, PropnOfPlusses] ) -- returns a copy of 'Original' with all of its values multiplied randomly by +1 or -1. The probability of multiplication by +1 is 0.5 if no second argument is supplied. If it is supplied, it MUST lie between 0 and 1 (inclusive), or a crash occurs.
<B>randum</B>(scalar NoBytes) -- Returns NoBytes random bytes generated by the Linux kernel rather than through Mono; the returned array holds one byte (0 to 255) per element. Hugely slower than "rand(Arr, 256)" for NoBytes 1000 or below, and still 3 times slower for very large sizes. Only useful where you want the purest possible supply of random bytes, not generated in accordance with a seed as in Mono.
<B>readgrid(graphID)</B> -- See Help menu item <I>Graphing - Interactive</I>.
<B>readtable</B>(<# blue>matrix <b>Table</b>,  scalar / array <b>InputValues</b>,  array <b>LookupRule</b> [, scalar <b>StartPtr</b> ]<# black>) OR - splitting the table up into two separate list arrays -
<B>readtable</B>(<# blue>array <b>InRow</b>,  array <b>OutRow</b>,  scalar / array <b>InputValues</b>,  array <b>LookupRule</b> [, scalar <b>StartPtr</b> ]<# black>) -- Returns table outputs for a set of inputs.
ARGUMENTS:
<bullet><b>Table</b> -- This matrix must have exactly two rows, row 0 (call it "InRow") holding values to look up, row 1 (call it "OutRow") holding corresponding table output values. Rows must have at least length 2.
<bullet><b>InRow, OutRow</b> -- As in the second version of the function; the two arrays must have equal length, at least of length 2.
<bullet><b>InputValues</b> -- Need not be sorted, EXCEPT in the case of a negative StartPtr - see later.
<bullet><b>LookupRule</b> -- Three allowed values:
<bullet 50,➯>"=" - An input value must exactly match an InRow value, or else the error code MINREAL is returned for that  value.
<bullet 50,➯>"~" - The nearest InRow value to the input value is found, and the corresponding OutRow value is returned. If the input value is exactly halfway between, say, InRow[i] and InRow[i+1], then InRow[i] will be selected, and OutRow[i] will be returned.
<bullet 50,➯>"L" - Linear interpolation occurs. Suppose the input value is 1/3 of the way between InRow[i] and OutRow[i+1]; then the output value will be 1/3 of the way between OutRow[i] and OutRow[i+1].
<bullet 30,>If input values are outside of the range in InRow, extrapolation occurs on the same basis.
<bullet><b>StartPtr</b> -- If present, causes the function to ignore all elements of InRow earlier than InRow[StartPtr]. It is an error to set this to beyond the end of the table, or - in the case of LookupRule "L" - to beyond the last two elements of the table.
<bullet 30,><i>Special case:</i> Where the table is large and there are many input values, it saves a lot of time if (a) InputValues is sorted (duplicates allowed), and (b) you set StartPtr to any negative value. In this case, each successive search will start in InRow where the last search finished, rather than going back to InRow[0] each time. NB! If, in this situation, InputValues is not sorted, "garbage-in-garbage-out" will apply to your results.
<B>rect</B>(<# blue>Var1 [, VirtualZero]<# black>) -- Nonvoid; given a complex array in polar form, returns its rectangular equivalent. (For explanation of 'complex array' as occurring in <I>MonoMaths</I>, see function <B>complex(.)</B>). If VirtualZero is present, then any amount with absolute value smaller than it is treated as zero, for both the input and output. The inverse of this function is <B>polar(.)</B>.
This function will crash if any input polar value has a negative 'absolute value' component.
<B>redim</B>(<# blue><one or more arrays> Victims, <one or more scalars> Dimensions<# black>) -- Non-void. 'Victims' must have been declared before this. The highest dimension comes first (e.g. row size, then column size, for a matrix). One argument produces a <I>list array</I>: "redim(Arr,10)". Two or more produce <I>structured arrays</I> - "redim(Arr,1,4)" produces a row vector, "redim(Arr,4,1)" a column vector, "redim(Arr,3,4)" a 3x4 matrix. Up to 5 dimensions are allowed. The difference between 'dim' and 'redim' is that 'dim' creates a new array and fills it with zeroes, while 'redim' redimensions an existing array <I>with retention of data</I>. If the new size is smaller, then existing data will be cropped; if the new size is larger, the end is padded with zeroes.
<i>Returned:</i>  the new size(s) minus the old size(s). If there is only one Victim, the return is a scalar; otherwise an array with one element per Victim.
<B>redimlike</B>(<# blue><one or more arrays> Victims, array Model <# black>) -- Precisesly as for 'redim(.)' except that 'Dimensions' are not explicitly supplied but are copied from the dimensions of the last argument 'Model'. ('Model' itself is not altered or otherwise accessed.)
<i>Returned:</i>  the new size(s) minus the old size(s). If there is only one Victim, the return is a scalar; otherwise an array with one element per Victim.
<B>removedups</B>(<# blue>Array<# black>) -- returns a copy of the array with all duplications removed: <# blue>removedups(data(1,1,3,2,2,3,1));<# black> returns the array [1, 3, 2]. No reference to input structure; output always a list array.  See also function <# blue>prevalence(.)<# black>.
<B>removedups</B>(<# blue>Matrix,  array 'R' or 'C'<# black>) -- returns a copy of the array with duplicated rows / columns removed; returns the reduced matrix. The second argument is case-insensitive; only its first element is examined.
<B>removeplot</B>(<# blue>GraphID, one or more PlotID values<# black>) -- Removes plot(s) from the given graph (but not from other graphs, and not from memory). The plot IDs may be presented as any mix of scalars and arrays. If any identifiers are invalid they are ignored without an error being raised.
<b>removeruns(<# blue>InArray [,  scalar / array OfThese ] )</b> <# black> -- the returned array will be a copy of InArray with runs of values replaced by a single value. For example,  <# blue>removeruns("AAABAADD")<# black>  would return "ABAD".
If a second argument is supplied, just the value(s) in it will have runs removed; runs of other values will remain. E.g.
	<# blue>aa = removeruns("AAABBBCCCDDD", "BD");<# black>
would return "AAABCCCD".
The structure of InArray is ignored. The output array is always a list array.
The chars. rating of the output array will be the same as that of InArray.
<B>reorder</B>(<# blue>KeyArray, Array1[, Array2...]]<# black>) -- Void; Array1, Array2... must be names of initialized arrays, which will have their contents altered. KeyArray is an array of size N which contains integers within the range 0 to N-1 (after rounding). All of Array1, Array2..  will be rearranged in situ accordingly; e.g. Array1[i] will be replaced by Array1[ KeyArray[i] ]. All arrays must be of the same size as KeyArray. Duplications within KeyArray are legal.
\t<# blue>arr1 = data(10, 20, 30, 40, 50);
\t<# blue>key1 = data(4,3,2,1,4);
\t<# blue>reorder(key1, arr1); <# magenta>// arr1 becomes: [50, 40, 30, 20, 50]<# black>
<b>repartition(<# blue>array WhichWindow, scalar NewHeight<# black>)</b> -- changes window heights without altering the total size or layout of the whole MonoMaths window. WhichWindow[0] must be 'A' (Assignments Window) or 'R' (Results Window) - case-sensitive.  If NewHeight is in the range 0 to 1, it is taken as a fraction of screen height; if \>1, as pixels.
RETURNS the final window heights (in pixels) as a list array of size 2: [AsstWindowHt,  ResWindowHt]. If no changes occurred (see below), these will be the existing heights.
If WhichWindow is not 'A' or 'R', no changes occur. (WhichWindow is allowed to be scalar, in which case it would have to be the unicode value for one of these.)
If NewHeight (after rounding) is 0 or negative, no changes occur. (Hence either of these two 'errors' may be used simply to return existing heights without change.)
If NewHeight \> (combined window heights ‒ 20), it is corrected down to this value.
Be warned that NewHeight \< 20 works oddly with small MonoMaths instances; use trial and error for a chosen size of instance, to find the right smaller value.
No errors are raised (apart from using the wrong number of arguments). If NewHeight is an array, it will be taken as scalar 0.
See also <i>reposition(.)</i>.
<B>replace</B>(<# blue>array Original,  scalar FromPtr,  scalar Extent,  scalar / array Replacement<# black>) -- returns a list array which is a copy of Original, but with all data excised from FromPtr for extent Extent; the excised data is replaced by Replacement.
If Extent exceeds the array length, all of the array from FromPtr onwards is replaced. Negative or zero Extent, or FromPtr beyond the end, all return an unaltered copy of Original. If FromPtr is negative, behaviour is as if Original had a virtual extention with negative indices; that is, FromPtr of -n and Extent of n+k has the same effect as FromPtr of 0 and Extent of k.
The output array retains the "characters" setting of the input array, but is always a list array.
<B>replaceto</B>(<# blue>array Original,  scalar FromPtr,  scalar ToPtr,  scalar / array Replacement<# black>) -- returns a list array which is a copy of Original, but with all data excised from FromPtr to ToPtr inclusive; the excised data is replaced by Replacement. 
If ToPtr exceeds the array length, all of the array from FromPtr onwards is replaced. If ToPtr is less than FromPtr, an unaltered copy of Original is returned. If FromPtr is negative, it is reset to 0.
The output array retains the "characters" setting of the input array, but is always a list array.
<B>replacerows </B>(<# blue>matrix InMatrix, scalar Where,  variable NewData [, scalar Repetitions]<# black>) -- NOT void. Returns a copy of InMatrix with a series of rows overwritten by NewData. 'Where' will be the index of the first overwritten row. If Where is < 0 or > index of last row, an error is raised. An error is also raised if the supplied data would overflow the bounds of InMatrix.
The function behaves differently depending on the argument. Examples using 'x' for scalar, 'Mx' for matrix, and 'arr' for a list array.
<# blue>replacerows(Mx, Where, x) <# magenta>// replaces row Where with a row full of the value in x.
<# blue>replacerows(Mx, Where, x, 3) <# magenta>// replaces 3 rows, starting with row Where, with rows full of the value in x. (If the last argument is absent or < 1, it defaults to 1.)
<# blue>replacerows(Mx, Where, arr) <# magenta>// Replaces one or more rows, depending on the length of 'arr'; \n\t// the length of 'arr' MUST be an integral multiple of the row size of Mx. The data fills\n\t// one row from left to right and then starts at the left of the next row down.
<# blue>replacerows(Mx, Where, Mx1) <# magenta>// Replaces from row Where with the whole matrix Mx1.<# black>
<B>replacecols </B>(<# blue>matrix InMatrix,  scalar Where,  variable NewData [, scalar Repetitions]<# black>) -- NOT void. Returns a copy of InMatrix with a series of columns overwritten by NewData. 'Where' will be the index of the first overwritten column. If Where is < 0 or > index of last column, an error is raised. An error is also raised if the supplied data would overflow the bounds of InMatrix.
The function behaves differently depending on the argument. Examples using 'x' for scalar, 'Mx' for matrix, and 'arr' for a list array.
<# blue>replacecols(Mx, Where, x) <# magenta>// Replaces a column full of the value in x at column Where.
<# blue>replacecols(Mx, Where, x, 3) <# magenta>// Replaces 3 columns full of the value in x. (If the last argument is < 1, it defaults to 1.)
<# blue>replacecols(Mx, Where, arr) <# magenta>// Replaces one or more columns, depending on the length of 'arr'; \n\t// the length of 'arr' MUST be an integral multiple of the column size of Mx. The data fills\n\t // down one column and then starts at the top of the next.
<# blue>replacecols(Mx, Where, Mx1) <# magenta>// Replaces the whole of Mx1 into Mx.
<# black>Note, in particular, that if you convert Mx1 to a list arr 'arr1' and then carry out 'replacecols(Mx, Where, arr1)', the data will be replaced in a different order, in accordance with the above rule. (There is no equivalent difference in the case of 'replacerows(.)'.)
<b>reposition(<# blue>new left, new top, new width, new height<# black>)</b> -- Changes positioning of the MiniMaths instance, and returns a list array of size 4: [final left, final top, final width, final height]. The four values may be supplied as any mix of scalars / arrays, but there must be exactly four. 
If any dimension is negative, that dimension will not be altered. (So if you only want existing data, and not to change anything, set all four values to e.g. -1.)
Any dimension  >= 0 and <= 1 is taken as a fraction of screen width / height as appropriate.
Any dimension > 1 is rounded and taken as pixels.
Impractical values are corrected back to feasible values before  being applied. See also <i>repartition(.)</i>.

<b>request</b>(<# blue>Btn, Heading, BodyText, Label1, Content1 [, Label2, Content2, [ ... ] ] , ButtonsEtc <# black>) -- Displays a dialog box requesting data from the user, to be entered into one or more text boxes. The function sets 'Btn' and returns the entered data as explained below.
<i>Btn</i> MUST be a predefined scalar variable; the function will reset its value to the code of the button that closed the dialog box.
<i>Heading</i> is the short snippet of text which goes inside the title bar of the dialog box. (No formatting tags are valid.)
<i>BodyText</i> is explanatory text which can be much longer; it will be printed above the textboxes. Only Pango text formatting can be used, which includes the following tags, all of which must be strictly paired: "\<b> .. \</b>", "\<i> .. \</i>", "\<u> .. \</u>", superscript "\<sup> .. \</sup>", subscript "\<sub> .. \</sub>". For more Pango options (including colouring), enter 'format' into the Assignments Window and press F1; scroll to the end of the display. (The same information is also in the main menu item "Help | Formatting with Text Tags".)
<i>Label - Content pairs</i>:  Any number allowed (but at least one pair). The number of text boxes is set by how many pairs you supply. 'Label' is the text displayed to the left of the text box, and 'Content' is its initial content. If either is scalar, the corresponding string in the dialog box will be the empty string. 
<u>Special Case:</u>  It is possible to condense several label - content pairs into a single pair, using the 3-character delimiter <b>{|}</b> between labels in Label1, and the same number of instances of the same delimiter in Content1. (Of course in such a case, there must be no Label2 and Content2 as further arguments.)  The purpose of this is to allow you to set the number of text boxes at run time, if necessary, rather than design time. Empty content is allowable; for example, if you have chosen three text boxes and want them all to be blank, you can set Content1 to "{|}{|}".
<i>ButtonsEtc</i> - A set of button titles delimited by '|'; e.g. "ACCEPT|CANCEL". You can have any number of buttons, but at least one. Buttons are displayed from left to right on the dialog box in the order supplied.
The 'Etc' refers to an optional final substring, which must be introduced by "#:", and which tells the function what to do in each text box if ENTER is keyed while the box is in focus. The whole string might look like this: "ACCEPT|CANCEL|#:101, 102, 1". Note that one or more integers follow the "#:", and that they are delimited by commas. (Spaces are ignored.) There should be one integer per text box. The integer codes have the following meanings:
<bullet>-1:  Close the dialog box, after setting the REF argument <i>Btn</i> to 100 + the no. of the text box (the first box being no. 0).
<bullet>0:  Do nothing. (This is the default, if this 'Etc' substring is omitted.)
<bullet>1, 2, 3, ...:  Send focus to the button of this number (1 being the leftmost button).
<bullet>100, 101, 102, ...  Send focus to textbox 0, 1, 2, ....
To set the size of the dialog box to other than the default, use function <b>setbox</b>.
<u>RETURNED</u>
(a) The button click which closed the dialog box is automatically stored in the named argument variable Btn. It will be 0 if the user closed the box using the corner icon; otherwise it will be the number of the button, the leftmost button (and the first referenced in argument 'Buttons') being 1. (If you used the 'Etc' part of 'ButtonsEtc', and set up for text box no. N to cause the dialog to close, then if that happens the return will be 100 + N. Note that text boxes are numbered from 0 upwards.)
(b) The data in the text boxes when the dialog is closed.
If only one text box was present, this will be a chars. array, trimmed of white spaces at both ends. If the text box was empty, it will be an array of size 1, containing the space character.
If there were multiple text boxes, the return is a 'jagged matrix' containing the contents of all boxes, the first box corresponding to row 0. Before the jagged matrix is built, the text box content is trimmed at both ends. In the process of building the jagged matrix, MonoMaths pads smaller rows out to the size of the longest text, using the space character for padding. In the event that all boxes were empty at the time of closure, the matrix will have size (No. boxes x 1), each row consisting of a single space.
<u>PROCESSING THE DATA</u>
There is <b>no internal parsing</b> of data by this function; whatever is typed (or not) in the box is returned. However you may parse scalar and array data using the function <# blue>stringtovalue(..)<# black>. Here is an example, where an array is expected:

<B>reverse</B>(<# blue>Named Array<# black>) -- VOID; reverses the contents of the array, wihtout interfering with its structure or characters rating.
<B>reversed</B>(<# blue>any no. of variables<# black>) -- NOT void; returns a list array consisting of all the data contained in the variables - whatever their type or structure - but in reverse order. (Returned array is of 'non-characters' type.)
<b>rgb</b>(<# blue>ColourRef [, DefaultColourRef ]<# black>) -- Always returns an array of size 3.
If 'ColourRef' can be identified as a colour, then the return has values:
<bullet>[0] = R(ed) value (0 to 255);
<bullet>[1] = G(reen) value;
<bullet>[2] = B(lue) value.
If 'ColourRef' cannot be identified, but 'DefaultColourRef' is present and a valid colour reference, then it is returned instead, in the same manner.
Otherwise the return is an array of all zeroes (equivalent to the colour black).
'ColourRef' can be:
<bullet 30,1.> A recognized colour name (type 'colour' and key F1, for list of allowed names; spaces are ignored);
<bullet 30,2.>  An integer (can be negative);
<bullet 30,3.>  Three values, taken as the R, G, B values (in which case using this function is pointless);
<bullet 30,4.>  four values, the first of which will be ignored (this allows for an unused 'brightness' byte; the rest are R, G, B values); 
<bullet 30,5.>  a hex number of length 6 digits, preceded by '0x' ('0' = zero, not the letter O); format "0xRRGGBB". (It accepts 8 hex digits also, ignoring the first 2, as for item 4 above).
Wherever 'gray' occurs in a legal name, the UK English version 'grey' is also allowed.

<b>rotate</b>(.) -- This has three forms, all void, and all directly changing the arguments:
<bullet><b>rotate</b>(<# blue>two or more variables of the same type<# black>) -- void. Variables in the list must be all scalars or all arrays with the same total size (though their dimensional structure will be ignored and may differ). "rotate(aa, bb, cc)" resets bb to have aa's old value, cc to have bb's old value, aa to have cc's old value.
<bullet><b>rotate</b>(<# blue>Array [, scalar NoTimes]<# black>) -- void. The contents of the array are rotated the given number of times. If 'NoTimes' is positive, values move to higher indexes (e.g. if NoTimes is +1, the contents of [0] become the contents of [1]). If negative, downwards. If NoTimes is omitted, it is taken as +1. (If it is present but 0, no rotation occurs.) NoTimes may overflow or underflow the size of Array, as its modulo is used. Array structure is unaffected; only the internal data strip is affected. For example, in a 2x3 matrix 'Mx', with NoTimes = 1, data in Mx[0, 2] will be moved to Mx[1, 0], and Mx[1, 2] will be moved to Mx[0, 0].
<bullet><b>rotate</b>(<# blue>Matrix, IsRows, NoTimes [, scalar/array Replacement) ]<# black>.
<i>IsRows:</i>  a boolean, to tell whether you want to rotate rows of the matrix or columns.
<i>NoTimes:</i>  As above. If positive, the contents of row/column 0 goes to row/column NoTimes. Overflow or underflow is no problem, as the modulo is taken.
<i>Replacement:</i>  If this argument is absent, 'wrapping' occurs; all the original rows and columns are preserved, but in a new order. If present, then the supplied value will replace the last row or column at each rotation by one. Replacement may be scalar (in which case the new row or column will be wholly made up of its value) or an array. If an array, its size must exactly match the row or column size of the matrix, as appropriate.

<b>rotaterow</b>(<# blue>Matrix, RowNo [, NoTimes [, scalar/array Replacement [, scalar StartAt [, scalar EndAt ] ] ] ] )<# black> and
<b>rotatecol</b>(<# blue>Matrix, ColNo [, NoTimes [, scalar/array Replacement [, scalar StartAt [, scalar EndAt ] ] ] ] )<# black> -- rotate the contents of part or all of a single row / column within a matrix, leaving the rest of the matrix untouched.
<i>Matrix:</i> should be a named matrix. No error is raised if it is not, but you will never see any result.
<i>NoTimes:</i>  As above; can be positive or negative. If absent, defaults to 1. If NoTimes = N, then for <i>rotaterow</i> the contents of Matrix[i, j] goes to Matrix[i, (j + NoTimes) modulo row length ]. For <i>rotatecol</i>, the contents of Matrix[i,j] goes to Matrix[ (i + NoTimes) modulo no. rows, j].
Overflow or underflow is no problem, as the modulo is taken.
<i>Replacement</i>: If omitted, or if it is an array (any array, but we suggest: "wrap"), wrapping of values will occur; e.g. the row "[1, 2, 3]", rotated once, will become "[3, 1, 2]". If present and scalar, values left empty will be filled with this value. E.g. if Replacement is 99, the row rotated once becomes "[99, 1, 2]".
<i>StartAt, EndAt</i>: If present, they define a subrange of the row or column which will rotate; the rest of the row or column will remain exactly as before. For example, for row [0, 1, 2, 3, 4, 5, 6], with StartAt = 2 and EndAt = 4, rotating once produces [0, 1, 4, 2, 3, 5, 6] (if wrapped) or [0, 1, 99, 2, 3, 5, 6] (if not wrapped, with Replacement = 99).
If StartAt is negative it is adjusted to 0. If EndAt is negative or beyond row / column end, it is adjusted to that end. If the pointers cross, simply no rotation will occur.
<B>rootstopoly</B>(<# blue>Array<# black>) -- Given a set of roots as an array, produces a polynomial (the lowest degree coefficients being lowest in the array). The array is allowed to be either (1) a list array or a vector (in which case all entries are taken as being real roots); or (2) an Nx2 matrix (N solutions, [i][0] is the real part, [i][1] the imaginary part). If using the second form, complex roots MUST come in exact conjugate pairs, or an error will be raised. Complex roots are taken as being in rectilinear form.
<B>round</B>(<# blue>Variable [, Scalar]<# black>) -- 'round(n)' rounds the variable to the nearest integer above or below. (An exact half is rounded to the nearest integer away from zero; (2.5 --> 3, -2.5 --> -3). The second argument is a decimal point precision specifier. For example, 'round(1.56789, 3)' --> '1.568'. This specifier can be negative - 'round(123, -2)' returns 100. But it must always lie between -15 and +15. (Hint: you can in some cases get the same effect by using a colon: "X:3" is equivalent to "round(X,3)" - the parser in fact converts the first form into the second. But anything more complex than a simple variable name (scalar or array), or a literal, also needs brackets: "(sin(x)):3", "(Arr[2,3]):3". )
<B>rowop</B>(<# blue>matrix Mx, scalar RowNo, scalar Coeff1, array isRowOrCol1, scalar RCNo1 [, array Sign, scalar Coeff2, array isRowOrCol2, scalar RCNo2] <# black>) -- VOID. Replaces the row RowNo in the Matrix with data, derived as follows. Suppose Coeff1 is 10, isRowOrCol1 is 'R' (for 'row'), RCNo1 is 2 (for row no. 2). Then for the 5-argument version, we would replace Mx[RowNo] with 10*Mx[2]. Continuing on with the 9-argument version, Suppose Coeff2 is 100, isRowOrCol2 is 'C', and RCNo2 is 3. (This would have to be a square matrix, if we are combining a row and a column.) Finally, suppose 'Sign' is '-'. Then row Mx[RowNo] would be overwritten by:  10*Mx[2]  -  100*Mx[ ][3].
\t<I>isRowOrCol1</I>:  Only the first char. is examined. 'R','r' tells us that RCNo1 is a row no; 'C','c' that it is a column no. Any other value - e.g. a space ' ' - will generate a row or column of appropriate length but containing all ones; in effect, you will be replacing every value in Mx[RowNo] with Coeff1. This is fairly pointless for the first term, but more useful for the second term, where for example you want Mx[RowNo] to be replaced by (Coeff1 * row1 + a constant, Coeff2). If you use this option, then you can use any value for RCNo1 (or RCNo2), as it is not accessed.
\t<I>Sign:</I>:  Only recognized ones are " + - * / "; any other crashes. There is no test, in the case of division, for zero in the divisor; you have to precheck that in the rare situation where you would want to use this sign.
\tThere is no adjustment for errors in arguments; any error of any sort will crash.
<B>rowvec</B>(<# blue>One or more variables or literals<# black>) -- returns a list array which contains whatever data is between the brackets. For example, 'Arr = data(1.23, "ABC", x)' - where 'x' is a scalar holding value 2.34 - will result in an array [1.23, 65, 66, 67, 2.34]. If one element of the list is itself an array, all its elements will be inserted into Arr. Note that you can include characters and character strings between single or double quotes; the unicode value (converted to an integer) will go into the LHS array. <I>Related functions taking the same arguments:</I> 'colvec(..)' returns a column vector; 'data(..)' returns a list array; and 'matrix(NoRows, NoCols [, ...] )' returns a matrix.
<B>run</B>(<# blue>array Data;  array Mode<# black>) -- the new program will be run in the same instance of MonoMaths. Four scenarios:
<i>Case 1:</i>  Invoke a program in a disk file: 'Data' is the path and file name, and Mode is 'F' or 'f'. (The rules for this file name are exactly as for e.g. function 'load(.)'; in particular, the abbreviation "~/" for the home directory is allowed.)
<i>Case 2:</i>  No files are involved: 'Data' is the text that you want to run as a program. In this case, Mode is 'T' or 't'.
<i>Case 3, case 4:</i>  Mode is "FQ" or "TQ" (case-insensitive; 'Q' for 'quietly'). As for 'F' and 'T', but the program text does not appear; preexisting text remains in the Assignments Window. However in the case of "FQ". the window title does change to display the new running program's name. The downside to using the 'quietly' option is that what is displayed in the Assignments Window is not what is in fact running - which could have quite serious effects e.g. when you go to examine the contents of a variable during or after a run.
If all you want to do is to load the new program (or other text) but not run it, use the sister function <b>pgm_load(.)</b> with exactly the same arguments (except that there is no 'TQ' option).
See also function 'exec()'.

<b>save</b>(<# blue>array Mode, array  TheData,  array FileName,  array WhatIfFileExists, ... <# black>) -- saves data to a disk file. Arguments vary across the four different modes, the mode being set by the first argument, 'Mode'. Only its first element is tested. This should be one of: 'T'(ext), 'B'(bytes), 'A'(rray), 'F'(ormatted). ('Mode' is case insensitive, and can even be scalar - the unicode of a valid letter.)
<i>Data:</i>  It must be an array (except with mode 'F'), but need not be a named array; <i>save('A', arr1 + arr2, ...)</i> would work, for instance. (Where the saved array is nameless like this, the prefix will have no entry in the portion reserved for the name; see under <i>load('A', ...)</i> for more details.)
<i>FileName:</i> If no file path precedes the name, the current data path will be used. Shortcut "~/" is allowed for the user's personal home directory. If 'FileName' is empty (spaces only) or begins with '?', a dialog box will open for user choice of file. Also if 'FileName' is a directory (and so ends in '/'), a dialog box will open at that directory.
Leading and trailing spaces are trimmed from 'FileName', together with unicode 0, so that a row from a jagged array (as, for example, is produced by function 'split(.)') can be used as is.
<i>WhatIfFileExists:</i> If the file already exists, action will be taken in accordance with the first character in this array. To overwrite without asking, use the letter 'O' or 'o'. In the case of mode 'F' alone, you also have the option of appending; in that case, use 'A' or 'a' here. For all modes, anything else (we suggest '?') will provoke a dialog box offering either to overwrite or to abandon saving. (If 'A' is used for a mode which does not support appending, the same will happen.)

The deployment of ARGUMENTS for the different modes are as follows:
<i>save</i>(<# blue>'T', Data, FileName, WhatIfFileExists<# black>) -- assumes the data can be converted to UTF8 unicode characters, tries to do so, and then saves the result to disk as a text file. (There is some built-in protection against impossible codes, but it would be possible to crash this function by sending it certain values that cannot be decoded into UTF8 characters; so use the function sensibly.)
<i>save</i>(<# blue>'B', Data, FileName, WhatIfFileExists<# black>) -- for this not to fail, all of the elements of array Data must be in the range 0 to 255 inclusive. Each array element will become a byte of the file which is saved by this mode.
<i>save</i>(<# blue>'A', Data, FileName, WhatIfFileExists [,  bool ApplyPrefix [, array Description ] ]<# black>) -- The underlying Mono platform - like .NET - has a method which codes each double into eight bytes. This is used here, so that the resulting file will have a size which is eight times the size of the array. If <i>ApplyPrefix</i> is missing or 'false', this is all that happens; there is no record as to how the array was structured. If 'true', then the array data is preceded by a prefix which encodes the array's name, dimensions and chars. rating, together with a time stamp (no. seconds since start of 1AD) preceding the data. This is read by the analogous function <i>load('A', ...)</i>, which will return an array of the same structure and chars. rating. (See the help file for that function to see how to retrieve the other recorded information.) If you want the prefix to contain other data (e.g. explanatory text, or a message to your mother), you can supply that data in the final optional argument <i>Description</i>; such data will be inserted into the prefix instead of the array's name. As long as it does not contain two colons together, any printable characters can be used; but spaces will be trimmed from the ends.
<i>save</i>(<# blue>'F', Data, FileName, WhatIfFileExists,  array VarNameInFile<# black>) -- Saves data in a specially formatted and easily human-readable form. Such a file may contain more than one variable; but a later call to <i>load('F', ... , VarName)</i> will only return data for the variable in the file which corresponds to its argument VarName. This file format is verbose, and so not practical for large arrays; but it has the advantage that it alone allows for scalars to be saved. (This is the one mode for which argument 'Data' may be a scalar rather than an array.) (For the curious, the formatting system is detailed at the end of the Help section 'Data I/O and Display'; but such knowledge is not required to use 'load('F', ...)' and 'save('F', ...).)
Argument <i>VarNameInFile</i> does not have to be the original name of the variable; use any text and any printable characters <i>except for the colon</i> ':' (which is used in the text file format to delimit the name). Leading and trailing spaces will be trimmed off, but internal spaces remain. <b>NB:</b> there is no check for duplication of name; if a variable with the same name is appended to an existing file, the corresponding function <i>load('F', ...)</i> will only ever find the first instance.
<i>RETURNED:</i> a boolean, 'true' if saving was successful, otherwise 'false'.
<i>ERRORS:</i> The function crashes only if the arguments are illegitimate in form - e.g. a scalar where an array is expected, or an improper 'Mode' argument (like 'X'). Where the save operation fails - e.g. a name is faulty, the path does not exist, or access is blocked - you find out by calling the two functions <i>iok()</i> and <i>iomessage()</i>, which retain their values until the next disk file operation. If saving was successful, <i>iok()</i> returns 'true' (and <i>iomessage()</i> is just a single space). If not, <i>iok()</i> is false, and <i>iomessage()</i> is a string telling you what went wrong.
As mentioned, the 'save(.)' function itself returns 'false'; but instead of testing for this, it is wiser to use the functions just mentioned.

<B>scalefit</B>(<# blue>2 to 4 values in any form<# black>) -- rarely useful, but here as a bit of exotica. Typically could be used to make tidy scale markings for an axis where curve endings are untidy numbers. For example, if you had a curve ranging from X = 0.2134 to X = 1.112, you would prefer the graph to have tidier scale markings like [0,  0.5,  1,  1.5], accepting the fact that there will be 'dead space' at both sides of the curve. You never need to use this function when drawing graphs, as the 2-argument version is called internally whenever you don't specify axis extents; for example, "plot(X,Y);" without a "grid(.)", for the above limits in X, would indeed automatically produce a graph with scalings [ 0.2, 0.4, 0.6, 0.8, 1, 1.2 ] (a tighter fit than our suggestion above).
There are two versions - (a) the version with only two values, which are XLow and XHigh. This is the one used internally for graphs, and always returns between 4 and 7 segments. It tends to give neater numbers, but at the cost of some looseness of fit. (b) The version with 3 or 4 values, the 3rd. being the least number of segments you want (at least 2), and the 4th. being the most segments you will allow. (If no 4th. argument, then the 3rd. stipulates an exact number of segments.) You get a tight fit, but often less neat values.
Both versions return an array of three values: [0] is the new X low, [1] is the new X high, and [2] is the number of segments proposed for the graph. (You would go on to produce actual graph scale values by using "scalery = ladder(NoSegs+1, NewXLo, NewXHi);" ).
Argument errors return a zeroed array; so if testing for this, test [2], which is always nonzero if there is no error.
<B>scaleoverx(..), scaleovery(..), scaleoverz(..), scalefudgex(..), scalefudgey(..), scalefudgez(..), scaleformatx(..), scaleformaty(..), scaleformatz(..), scalejumpx(..), scalejumpy(..)</B><# black> -- Used in 2D and 3D graphing to modify or replace the machine-generated X-axis and Y-axis scales. See Help menu item <I>Graphing - Basic</I> for details of their use.
<B>seed</B>(<# blue>[Scalar]<# black>) -- a void function which resets the seed value for the calculation of random numbers (using <# blue>rand (..)<# black> or <# blue>randarr(..)<# black>). The argument (which should be in the range 1 to 2,147,483,647 - which is hex 7FFF FFFF) is always rounded. If it rounds to less than 1 (i.e. is 0.5 or below), or is omitted, then an internal NET generation method applies, using a value obtained from the computer clock. Otherwise the supplied number (rounded) becomes the seed. A new internal random seed is always generated before all user programs, so 'seed()' is normally not necessary. NB: If you do use 'seed()' (empty argument) to randomize the seed, DO NOT include it in a loop, as the loop will usually operate much faster than the changes of system clock used internally, so that you will in fact have long runs with the same seed being generated each time.
<b>seekno</b>(<# blue>array <b>TheString</b> [, scalar <b>StartPtr</b> [, scalar <b>EndPtr</b> [, bool <b>IntegerOnly</b> [, bool <b>AllowNegSign</b> ] ] ]<# black>) -- searches for the first valid number within the indicated portion (or all) of TheString.
<bullet><i>TheString</i>:  Taken as a string of unicode chars.
<bullet><i>StartPtr:</i>  Defaults to 0 if absent, or if negative.
<bullet><i>EndPtr:</i>  Defaults to end of TheString if absent or too large or negative (so '-1' is fine where you don't know the size of the string).
<bullet 50,➯>All characters before StartPtr or EndPtr are ignored; e.g. the minus sign of the string "-12" if StartPtr is 1.
<bullet><i>IntegerOnly:</i>  Defaults to FALSE if absent. If TRUE, will only look for numeric characters 0 to 9; if FALSE, will look for a sequence of characters which appears to represent any valid number (e.g. "1.23" or "2.3e-21"). (There is no test for whether or not any integer found is within e.g. the Int32 range.)
<bullet><i>AllowNegSign</i>:  Defaults to FALSE. If TRUE, "-12" would return -12; if FALSE, it would instead return 12.
<u>RETURNED</u>
An array of size 3. Its values are as follows:
<bullet>A value was found:
<bullet 50,➯>[0] points to its first character in TheString;  [1] points to its last character;  [2]  is the parsed value of this substring.
<bullet>A potential value was found, but it was outside the range of .NET/Mono  type double (like "1e999"):
<bullet 50,➯>[0] and  [1] again point to its first and last character;  but [2]  is NaN. (This value would never be validly returned from TheString, as characters out of the Unicode range are substituted out before the search.)
<bullet>No value found:
<bullet 50,➯>[0] and  [1] are both -1;  [2]  is NaN.

<B>select</B>(.)  has two forms; both return a list array consisting of selected entries from a source array.
<bullet><B>select</B>(<# blue>SourceArray, IndexesArray<# black>) -- In this form, IndexesArray is simply a list of indexes within SourceArray. The structure of SourceArray is important; sets of values in IndexesArray must constitute valid indices for its locations. For example, if SourceArray is an MxN matrix, with rows m (0 <= m < M) and columns n (0 <= n < N), then the format would be: <# blue>arr = select(SourceArray, data(m1, n1, m2, n2, ...) );<# black> this would return a list array: [SourceArray[m1,n1],  SourceArray[m2,n2], ...). All indexes <i>must be valid</i> for SourceArray, or else the function crashes.
<bullet 30,>The structure of IndexesArray is ignored; it would usually be a list array, but for the above example could also be a matrix with two columns, column 0 for M values and column 1 for N values, as the internal data strip would then have the same values in the same order as would the corresponding list array version of IndexesArray.
<bullet 30,>See also <B>evict(.)</B>, which returns all <I>except</I> the indicated elements of SourceArray.
<bullet><B>select</B>(<# blue>SourceArray,  scalar LowKey [, scalar HighKey],  IndexesArray<# black>) -- IndexesArray this time must have exactly the same total length as SourceArray (the actual structure of the two arrays is irrelevant). Suppose you have only supplied one scalar, 'LowKey'. Then for every index n in IndexesArray such that IndexesArray[n] = LowKey, SourceArray[n] is added to the collection of values to be returned. If you have supplied both scalars, then for every index n such that   LowKey ≤ IndexesArray[n] ≤ HighKey,  SourceArray[n] is added to the collection to be returned. If no values in IndexesArray fall within the range, the empty array [NaN] is returned.
An example of use of this second form of the function is in the Hints file - key F1 with the cursor on the word 'select'.

<B>selectrows</B>(<# blue>SourceMatrix, array of row nos.<# black>) -- returns a matrix whose rows are the selected rows from SourceMatrix. The second argument holds the requried row numbers; its structure is ignored.
<B>selectcols</B>(<# blue>SourceMatrix, array of column nos.<# black>) -- returns a matrix whose columns are the selected columns from SourceMatrix. The second argument holds the required column numbers; its structure is ignored.
<B>sequence</B>(<# blue>scalar StartValue; any number of variable names<# black>) -- This function is used to assign integer values to any number of scalar variables, whether mentioned earlier or not. If not, they are defined by this function, as with <b>unpack(.)</b>. The first scalar will receive the value StartValue (rounded), and increment it; each subsequent scalar receives the updated StartValue and again increments it. The return is the last incremented value, so that the returned value minus StartValue equals the number of named variables.
<B>setalias</B>(<# blue>{any number of  variable names}<# black>) -- void. Sets variable aliasses. (For an explanation of aliassing, key F1 with the cursor on this function name, or just on 'alias'.) The variables must have been assigned before this function call. (In the case of arrays, no address component like "[1]" is allowed.) The variables must exist in the current function level. Constants and system variables cannot be aliassed. The aliasses assigned to the variables are integers, always starting from 0 (for the first variable). While you may use 'setalias' more than once in a function (or main program), a later call will completely negate all aliasses from an earlier call; the new aliasses will again start from 0.
<B>setbins</B>(<# blue>DataArray [, scalars BinWidth, LoCentre, HiCentre, IncludeAllData ]<# black>) -- Given an array of data, use it to fill a number of compartments or 'bins' which represent subranges of that data. Note that you have to supply either just one argument (where you simply want a rough idea of the spread of data, and so will accept program defaults) or the full set of five arguments.
<I>DataArray</I> -- Its structure is irrelevant, but it must have a total length of at least 4. For this function to be useful, the data would obviously have to be spread across a significantly large range of values.
<I>BinWidth</I> -- for the histogram that is to be produced, this would be the subrange of data that is to be fitted into each bar of the graph.
<i>LoCentre </i> -- the centre, on the X axis, of the lowest bar. Hence, the central value in the lowest data bin.
<i>HiCentre </i> -- the centre, on the X axis, of the highest bar. Hence the central value in the highest data bin.
It is important, for the sake of appearances and good scaling, to ensure that BinWidth exactly divides (HiCentre ‒ LoCentre). Then the number of bins or bars will be given by  1 + (HiCentre ‒ LoCentre) / BinWidth.
Note also that you must have at least four bins. If the above formula produces a smaller number of bins, BinWidth will be internally reset such that there are four bins.
<i>IncludeAllData</i> -- A boolean which determines what happens to data that is outside of the ranges that you have set; that is, data less than half a bin width below LoCentre and more than half a bin width above HiCentre. If 'true', all that data is included in the nearest bin; otherwise it is simply omitted from the bins altogether (though not from the returned statistics  - see later). (In the case where only one argument is supplied, all data is always included, as LoCentre and HiCentre are internally calculated to include all data.)
<U>Assignment to compartments:</U>
If a given bin extends from some value 'lo' to some value 'hi', then for every datum 'd' in the range  <# blue>lo ≤ d \< hi<# black>, that bin's total will be incremented.
<U>Returned:</U>  
A <B>matrix</B>, with three rows, the row length being the number of bins. 
<bullet>Row 0 holds the lower X axis coordinates of the bins;
<bullet>Row 1 holds their higher X axis coordinates;
<bullet>Row 2 gives the content of individual bins;
<bullet>Row 3 provides (a) an indication of success or failure; and if success, (b) some statistics for the data.
<bullet 50,➯>Element 0 is positive if there is no error; it is equal to the number of bins of data. If there is an error, it is negative. Specific codes for error are: -1, for DataArray too small (\< 4 items); -2 for LoCentre and HiCentre being equal or crossed.
In the single-argument case, the program first computes the statistics, then sets parameters such that there are 3 bins between standard deviations, and a total of at least 12 bins to enclose all of the given data.
<b>setbox</b>(<# blue>Width, Height[, CentreX, CentreY]<# black>) -- exactly two or four values, in any mix of arrays or scalars. Sets the size and positioning of the next dialog box to be called. Any dimension D in the range 0 \< D ≤ 1 will be regarded as a fraction of the screen width or height (as appropriate). Dimensions \> 1 are taken as pixel dimensions. Silly values are corrected internally or ignored.
CentreX and CentreY refer to where the centre point of the dialog box is to be.
The value to invoke the default dimension is -1. The one proviso is that you cannot separately set one of Width and Height to default; setting either to -1 has the same effect as setting both to -1. (This is not the case with the other two arguments.)
The box setting lasts only till you call the next dialog box. If you want a setting to last longer you will have to repeatedly call 'setbox' before each dialog box call.
The function has no effect on the size of file dialog boxes.
<B>setfunc</B>(<# blue>scalar Which Func, array FnName [, bool DontCrashIfNameNotFound [, bool OnlyCheckForUserFns] ]<# black>) and <B>func</B>(<# blue>arguments<# black>) -- Functions 'func1(.)' and  'func2(.)' can stand for any system or user function; the function which each represents is set by a prior call to 'setfunc(.)', which takes the name of the function as an argument. To see how it is used, see Help menu item <I>Anonymous Functions</I>.
<b>setsegmt</b>( <# blue>NAMED array <b>InArray</b>,  array / scalar <b>Delimiter</b>,  scalar <b>WhichSegment</b>, scalar / array <b>NewData</b><# black> ) -- VOID; changes InArray directly.  (By 'segment' is meant a subarray of InArray which is delimited by Delimiter; it can be empty. For more detail, key F1 on 'segment'.) 
<bullet><b>InArray</b> must be a predefined named array; if structured, its structure will be ignored.
<bullet><b>Delimiter</b> is a single value. If supplied as an array, only the first element of the array will be used as the delimiter.
<bullet><b>WhichSegment</b>: The first segment is numbered segment 0. <b>The function crashes</b> if WhichSegment does not refer to a valid segment; in other words, if WhichSegment is negative, or is \> 1 + number of delimiters present in InArray.
<bullet><b>NewData</b>: Whatever will replace the current contents (if any) of the segment. If you want to make the segment an empty segment, set NewData to NaN (or to an array for which element 0 is NaN).
<b>setval</b>(<# blue>Alias [, segment address]<# black>) -- Void. Sets the value of an aliassed variable, or (if an array) of a segment of it. (For an explanation of aliassing, key F1 with the cursor on this function name, or just on 'alias'.)
In the case of scalars, <# blue>setval(N, z)<# black> will cause the aliassed scalar to take on value z.
For arrays, <# blue>getval(N, zz)<# black> will set the aliassed array to be a copy of zz (same structure and chars. rating), overwriting whatever prior value and structure the aliassed array had.
To set just a segment of the aliassed array, use <# blue>setval(N, <address>, Data)<# black>, where 'address' is what you would put between square brackets if using the unaliassed variable. As an example, suppose that N is the alias for a matrix Mx'. In the following pairs, both assignments will have the same effect on Mx:
<bullet><# blue>setval(N, 1, 2, x)<# black>	  and  <# blue>Mx[1,2] = x<# black>. ('x' is either a scalar or an array with only one element.)
<bullet><# blue>setval(N, 1, arr)<# black>	  and  <# blue>Mx[1] = arr<# black>. In both cases, 'arr' must have exactly the right length to fit a row of Mx.
Where you want the whole of a column, and would use empty square brackets "[]" to indicate this, you instead use -1 (but no other negative number) - or MINREAL. These are equivalent:
<bullet><# blue>setval(N, -1, 1, foo)<# black>	  and  <# blue>Mx[][1] = foo<# black>. ('foo' must have the length of one column of Mx.)
<B>show</B>(<# blue>One or more variables or literals<# black>) -- A void function, which displays its argument in a message box: 'show("Current value of x: ",x);'. See Help menu item <I>Data Input and Display</I> for more details on the use of this function.
<b>showarray</b>(<# blue>Arr<# black>) -- display the contents of an array in a separate window. It is in fact exactly the same window as you get when you have the cursor next to an array's name in the Assignments Window - during or after a program run - and then click the F1 key.
The argument may be a temporary array; e.g. "showarray(Arr+1)" would work.
<B>showhairlines</B>(<# blue>GraphID, scalar HowX [, HowY [, HowZ ] ] <# black>) -- A void function. If e.g. HowX is zero, the graph's X axis will have no hairlines or scale markers; if 1, no hairlines but small scale markers will occur where hairlines would go; if 2 (the default) - or any other value - full hairlines are present. Note that scaling strings at hairline locations are not affected by this function.
<B>shuffle</B>(<# blue>Array [, ReturnOriginalIndices]<# black>) -- Two versions, one VOID and one NONVOID. In both cases Array is directly shuffled (i.e. the function never returns a shuffled copy of Array). If there is only one argument (or if the second argument is exactly 0), it is void.  If there is a second nonzero argument, Array is still shuffled, but this time the function returns an array consisting of the original indices of array elements. For example, if Array was originally [0, 10, 20], and after sorting became [20, 0, 10], the returned array would be [2, 0, 1].
<I>Special case:</I> If Array contains only zeroes (as it does when created by "dim(..)" ), then it is first converted to the array [0,1,2, ... Length-1], and then shuffled.
<B>shufflemx</B>(<# blue>Matrix, array RowsOrCols [, array ImposedOrder] <# black>) -- A NON-void function. It returns a matrix of exactly the same size as 'Matrix'. If there is no third argument, the matrix will be a copy of 'Matrix' but with its rows or columns randomly shuffled. (If RowsOrCols is 'R' or 'r', rows; if 'C' or 'c', columns.) If a third argument is present, it must be exactly as long as the number of rows / columns; this will be the order of rows / columns in the reordered copy of 'Matrix'. Duplications and omissions are allowed in 'ImposedOrder', as long as the total length is as described.
<B>sigmoid</B>(<# blue>array XX, scalar IndexCoefficient, scalar DenominatorCoefficient,  char array Mode <# black>) -- returns a list array giving the appropriate sigmoid function value for each element of XX. The structure of XX is ignored. Refer to the 'Hints' file for details (i.e. key F1 with cursor on 'sigmoid' in Assignments Window).
<b>sign</b>(<# blue>scalar / array Values [, scalar ReturnForZero [, scalar ReturnForPositive [, scalar ReturnForNegative [, scalar VirtualZero ] ] ] ]<# black>) -- Returns an entity with the same structure as Values. Suppose we call the function's return "Result". Then if there are no more arguments, Result[i] will hold +1 if Values[i] is positive, 0 if Values[i] is exactly zero, and -1 if Values[i] is negative. The next three arguments will alter these defaults of +1, 0 and -1 to any other values you wish.
<i>VirtualZero</i>:  If Arr has been derived by division (and some other operations), then it is quite possible that where there should logically be a zero there is a very tiny positive or negative value. To negate this, set VirtualZero to some value well below any you anticipate in your array (like 1e-10). Then any Values[i] which has an absolute value ≤ VirtualZero will be treated as zero.
<B>sin</B>(<# blue>Variable<# black>) -- the sine of the variable (which is taken as being in radians). Inverse function: <# blue>arcsin(..)<# black>.
<B>size</B>(<# blue>Variable [, Scalar]<# black>) -- Intended for arrays. If one argument, returns the total array size, irrespective of dimensions. If two arguments, returns a particular dimension; e.g. for a 2x4 matrix, <B>size(arr,0)</B> returns 4, <B>size(arr,1)</B> returns 2, <B>size(arr,2)</B> returns 0. For an impossible number of dimensions, -1 is returned. 
For scalar first arguments any second argument is ignored, and 0 is returned. (The total size of an array is never 0, so <B>size(xx)</B> can be used to distinguish a scalar from an array.)
<B>smash</B>(<# blue>[ array Message [, array FileName ] ]<# black>) -- Sudden death to the MonoMaths instance (by raising an unhandled exception). The better way to end a MonoMaths instance programmatically is by means of fn. 'kill_on_exit()' (with subsequent 'exit'). But in some circumstances that does not work; then you must turn to this brute force method. If there is a first array argument, it is regarded as text and is saved to disk. If there is a second array argument, it is taken as a file name, and an attempt is made to save the message there. If that fails, or if there is no second argument, the message is instead saved in "/tmp/smash.txt".

<b>solve_de</b>(<# blue>char. array FnName,  scalar Y0,  array XX [, char. array Method]<# black>) -- solve differential equation. The equation is in the form: "dy/dx = ƒ(x, y). The RHS of this equation should be encoded in a function with arbitrary name - say, "Foo(.)". It must have the args. in the order given, and must give a single scalar value for scalar args. x and y. ("Foo" can take optional args., and can handle array args; but these capabilities would not be used by this system function.) The first argument is this name as a chars. array. XX is an arithmetic progression from some Xlow to Xhigh. Y0, representing the constant of integration, is the imposed value for the solution when x = Xlow. Method is the first three letters of the method name (further chars. allowed but ignored), not case-sensitive. Methods are: "eul" for the Euler method, "run" for the Runge-Kutta method (4th. order). If Method is omitted, it defaults to the Euler method. If present but any other value than these given, the function crashes.

<b>solveexp</b>(<# blue>char. array Expression [, array Values]<# black>) -- Given an expression in the form of a string, return a scalar value which is its evaluation. The form of <i>Expression</i> is completely different between the two versions. In both cases, values are connected with the standard operators '+', '‒', '*', '/' and '^'. Brackets '( ... )' are allowed, and may be nested to any level. But you cannot use system functions. And in both versions, arrays are not allowed; only scalars.
In the <u>one-argument version</u>, the values used in Expression may be any of: (1) literal numerals; (2) constants (system or user-defined); and (3) <i>main</i> program <i>scalar</i> variables. For example, if you have in the main program defined some scalar variable "x = ...", then this is a valid expression: "x / (PI + (2.34 * EE)^2 )". I repeat: no arrays allowed; and the answer will always be scalar.
In the <u>two-argument version</u>, the values used in Expression are all stored in the second argument, Values. No reference in Expression may be made to any other values. The expression refers to Values[n] by the code "{n}" (where 'n' is an explicit integer, a valid index of Values). For example, if Values is the array { -1, 2, 10, 4 }, then the Expression "{1} + {3}" would be equivalent to Values[1] + Values[3], i.e. 2 + 4, and so the function would return 6.
In both cases, spaces, tabs and paragraph marks are all removed by the function before it starts parsing. Also in both cases, all errors crash; if wanting to avoid this (e.g. in handling input from a user via a dialog box), use the error functions (enter 'error' in the Assignments Window and key F1).
<B>solvepoly</B>(<# blue>Array Poly [, Scalar CutOff [, Scalar Pol/Rect ]] <# black>) -- Solve the polynomial equation  [Poly] = 0. (The lowest degree coefficients are lowest in the polynomial array.)  If N is the degree of the polynomial (i.e. the highest index), a matrix (Nx2) is returned, holding N solutions: [i][0] is the real part of each solution, [i][1] the imaginary part. If CutOff is supplied, and is > 0, the default for regarding a tiny value as zero (default = 1e-15) will be overruled. (You can use 0, but many polynomials will then not get solved.) If there is a third argument, it must be 'P' (or 'p') for polar output, or 'R' (or 'r') for rectilinear output. Rectilinear is the default. Roots are sorted, with real roots being lower in the returned matrix than complex roots. If the polynomial cannot be solved (very rare), an array of size 1 is returned ([0] = 0); therefore always test the size before processing it. One other caution: every few hundred polys you will get one which appears to solve, but which is wrong because a spurious tiny imaginary quantity was taken as valid, so that a conjugate root was devised - which throws the process out. It is not a bad idea to crosscheck using functions 'rootstopoly(..)' (to recreate a polynomial from the solution) and 'compare(..)' (to compare the original and the reconstructed polynomial - use the RMS result returned by 'compare'). For valid solutions, RMS values will constellate around the CutOff value.
<B>solvesim(</B>(<# blue>Matrix Coeffs, Array RHS<# black>) -- Solve simultaneous equations:  [Coeffs][solutions] = [RHS].
\tIf there are N equations (N at least 2), 'Coeffs' has dimensions NxN and RHS has size N. Program ends if not so. Success returns the solutions array of size N (always >= 2); failure to solve does not crash, but returns an array of size 1, with value: 1 (equations homogeneous) or 2 (equations indeterminate - e.g. one equation is simply a multiple of another); no valid answer returns an array of size 1.
<B>sort</B>(<# blue>array Data [, scalar SortType [, scalar StartPointer[, scalar EndPointer]]]<# black>) -- a VOID function that sorts the array Data (retaining its original structure). If SortType is omitted or is positive (or zero), ascending sorting occurs; if it is negative, descending sorting. StartPointer and EndPointer give the range within the array to be sorted. Out-of-range pointers are corrected; but crossed pointers raise an error. Allows array of size 1 (does nothing to it, though pointers still checked).
<B>sortbykey</B>(<# blue> array Data1 [, array Data2 [, ... ] ], array (Key)[, scalar SortType [, scalar StartPointer[, scalar EndPointer]]]<# black>) -- a VOID function that sorts one or more data arrays according to the key array 'Key'. All arrays must have the same total length, irrespective of pointer values. Structure and chars. rating is ignored for all of the array arguments.
The scalar arguments have exactly the same significance as in 'sort(..)', applying to the sorting of the key array.
<i>Warning!</i> The key array is also sorted; so if you want to preserve the original key, make a copy of it first.
Allows arrays of size 1 (but does nothing to them).
<B>span</B>(<# blue>SourceArray, array (scalar) Bookmark1, array (scalar) Bookmark2 [, scalar FromPtr [, scalar ToPtr ] ]<# black>) -- returns data from SourceArray which lies between bookmarks. If FromPtr ± ToPtr are supplied, they represent the first and last values in SourceArray which will be examined; the rest of SourceArray will be treated as if it did not exist.
A bookmark is an array; for example, if the SourceArray were [0, 1, 2, 3, 4, 5, 6, 7, 8], and Bookmark1 were [1, 2] and Bookmark2 [5, 6, 7], then the function would return the subarray [3, 4]. Exceptions: If Bookmark1 is scalar (any value - not accessed), then all is taken from the start of SourceArray (or FromPtr inclusive, if supplied) to Bookmark2. Likewise if Bookmark2 is scalar, all is taken from Bookmark1 to the end of SourceArray (or to ToPtr inclusive, if supplied). 
RETURNED: This requires care, as <i>the return can be scalar or an array</i>.
<bullet>If a nonempty subarray is found, it is always returned as a list array (with the same chars. rating as SourceArray).
<bullet>If Bookmark1 is not found, SCALAR 1 is returned.
<bullet>If it is (or if there was no Bookmark1), but Bookmark2 is not found, SCALAR 2 is returned.
<bullet>If the returned array would logically be empty, the 'empty' array [NaN] is returned. This happens if (a) Bookmark1 and Bookmark2 are contiguous; (b) if there is no Bookmark1, but Bookmark2 is right at the start of SourceArray (or at FromPtr, if supplied); or (c) if there is no Bookmark2, but Bookmark1 is right at the end of SourceArray (or ends at ToPtr, if supplied).
Note that after this function has found the first instance of BookMark1 it then seeks the first instance of BookMark2; if there are any further instances of BookMark1 between the first Bookmark1 and the first Bookmark2, they will be included in the returned array.
The function only crashes the program if SourceArray is not an array, or if both bookmarks are scalars. Errors in FromPtr and ToPtr are handled like this: FromPtr \< 0 is corrected to 0, and ToPtr beyond the end of SourceArray is corrected to its last character. If the pointers are crossed, the return is scalar (1 or 2, depending on the deployment of book mark arguments).
<B>split</B>(<# blue>array Original, array or scalar Delimiter [, array or scalar Padder [, bool AcceptEmptySubarrays [, FixedLength [, array / scalar Prefix [, array / scalar Suffix ] ] ] ] ] )<# black>) -- The original array is divided into 'subarrays', being extents between delimiters (and before the first delimiter, and after the last). A jagged matrix is built from these subarrays, rows being padded as necesssary by Padder.
Delimiter may be an array, in which case the whole of the array constitutes an instance in Origin of the delimiter.
Padder may also be an array. If so, the whole array will be appended to the new row until the required length has been reached (in which case the last instance of the padder array may be truncated). The default Padder is 32 (I chose the unicode of the SPACE character, as 'split' is commonly used with strings). Any values can be used, including NAN.
The structure of Original is ignored; its data is read as if it were a list array. The 'characters' rating of the returned array will be the same as that of Original.
If Prefix is present, it is added to the start of every subarray of Original. If Suffix is present, it is added to the end of every subarray. Any padding is only added after Prefix and Suffix have been incorporated into the matrix row. (Prefix and Suffix may include NAN, but Original and Delimiter should not include NAN.)
If AcceptEmptySubarrays is present and TRUE, empty subarrays (occurring where two delimiters are contiguous) are included; in which case they will be built from Prefix (if any) + Suffix (if any) + padding. If AcceptEmptySubarrays is absent or FALSE, such subarrays are simply ignored. (If all subarrays are empty, the 'empty' array [NaN] is returned. This also happens if AcceptEmptySubarrays is false but no fixed length has been specified, as row length then would default to 0.)
If FixedLength is present and rounds to at least 1, then rows will be forced to this exact length, either by padding or by truncation. Otherwise row length is set by the longest subarray (any prefix or suffix inclusive).
<B>sqr</B>(<# blue>Variable<# black>) -- returns the square of the variable. If an array, returns a copy with all elements squared.
<B>sqrt</B>(<# blue>Variable<# black>) -- returns the square root of the variable. If an array, returns a copy with all elements squared. An error is raised if the argument is negative.
<B>starttimer</B>(<# blue>1 or more timer identifiers (range: 0 to 19) as any mix of scalars and arrays<# black>) -- There are (notionally) 20 timers on board; this starts the nth. timer(s) counting up from 0 msecs. (n being in the range 0 to 19). (In fact, the 'timer' is just a memory location which stores the time at which your program ran this step, ready for later subtraction from the current time.)  Error raised for argument outside this range. You read the timer with function <B>timer(n)</B> - which see.
<b>str</b>(<# blue>scalar or array Value [, array: FormatHow]<# black>) -- returns a character array, expressing the value as a string of characters. If Value is an array, the separator ", " occurs between separate value strings. If FormatHow is present, it must be such as is recognized by C#, as it is passed uncritically to C#. If the format is faulty, one of the following can happen: (a) it is ignored, and the default format occurs; (b) garbage is returned (usually the variable type name in C#); or occasionally (c) MonoMaths crashes without an error message. So don't get it wrong. Allowed values that work in MonoMaths (which only uses C# type 'double' for variables) are found by entering this function's name into the Assignments Window and keying F1. Note that <b>valuetostring(..)</b> is exactly the same function (preferred if you want your code to be more self-explanatory).
<b>stringtovalue</B>(<# blue>chars. Array [, .... ]<# black>) -- (Alias: "val(.)".) Given the string form of a scalar or array value, returns the scalar or array. Two forms:
<i>Encoded scalar expected:</i>  <b>stringtovalue</B>(<# blue>chars array Arr [, Scalar: failureValue]<# black>). If there is a parsing error, failureValue is returned instead. If there is no second argument, the returned value in the case of parsing failure is MAXREAL.
<i>Encoded array expected:</i>  <b>stringtovalue</B>(<# blue>chars array Arr,  array Delimiter [, Scalar: failureValue]<# black>). (Note that the second argument must be an array, and the third, if present, scalar.) Returns the encoded array; or if there is any error parsing any value, an array of size 1, value failureValue, is returned. (As for the scalar case, the default failure value is MAXREAL.)
In both forms, spaces in Arr are ignored unless they are inside the representation of a single value (as in "1 23"), where they cause the failure value to be returned.
<B>structure</B>(<# blue>One or more values, contained in any mix of scalars and arrays<# black>) -- returns a structure for which the values are the dimensions. The highest dimension comes first; e.g. to create a 5 x 3 matrix, use 'structure(5, 3)'. All values are zero.
<B>submatrix</B>(<# blue>Matrix, scalar PivotRow, scalar PivotColumn<# black>) -- returns a matrix made from Matrix by removing the indicated column and row. Matrix need not be square but must have at least 2 rows and 2 columns.
<B>substitute</B>(<# blue>array Source, ...., scalar/array Replacer<# black>) -- returns a copy of Source which has certain values replaced by Replacer. Four forms are possible:
\tForm 1: <# blue>arr = substitute(array Source, scalar Value, scalar Replacer)<# black>. Every value in Source which exactly equals Value is replaced. (This is the one form in which Value may be NAN.)
\tForm 2: <# blue>arr = substitute(array Source, scalar LoVal, scalar HiVal, scalar Replacer)<# black>. Every value in Source which is between <I>or at</I> the limits LoVal and HiVal is replaced. (The order of these two values is not important.) 
\tForm 3: <# blue>arr = substitute(array Source, array Values, scalar Replacer)<# black>. Every value in Source which exactly equals any value in Values is replaced. 
\tForm 4: <# blue>arr = substitute(array Source, array Value, array Replacer)<# black>. Every segment of Source which exactly equals Value is replaced.
The returned array will have the same characters rating as Source; it will also have the same structure, except for form 4, where arrays Value and Replacer have different lengths; in that case alone, the returned array is always a list array.

<B>sum</B>(<# blue>Array [, scalar StartAt [, scalar EndAt ] ]<# black>) -- the sum of the contents of the array (irrespective of its structure); if no limits, the whole array is summed. If only the first limit, summing starts from there. The limit arguments are adjusted if out of range; crossed limits returns 0.
<B>sumrows</B>(<# blue>Mx [, FromRow [, Extent ]]<# black>) -- returns a list array whose length is the length of a row of Mx, and whose ith. value is the sum of all the elements in the ith. column of Mx. If 2nd. +/- 3rd. arguments are supplied and are wrong, the outcome is as if the matrix had rows of zeroes extending to infinity both before the first and after the last row; for example, FromRow = -1 with Extent = 1 would return an array of zeroes (the values of virtual 'row -1'). Similarly, Extent <= 0 returns an array of zeroes. The only error raised is if Mx is not a matrix. (See also 'prodrows' and 'prodcols'.)
<B>sumcols</B>(<# blue>Mx [, FromCol [, Extent ]]<# black>) -- the column equivalent of 'sumrows(.)'; it behaves in exactly the same way.
<B>swing</B>(<# blue>2, 4 or 6 args., either all scalar or all equal-length arrays<# black>) -- returns angle(s) of rotation. The following explanation is in terms of scalars; the same applies for the ith. values of all array arguments.
(a) swing(Xto, Yto) -- the angle which a ray hinged at the origin makes in swinging from the X axis (positive direction) to the 'to' point (Xto, Yto).
(b) swing(Xto, Yto, Xfrom, Yfrom) -- the angle which a ray hinged at the origin makes in swinging from the 'from' point (Xfrom, Yfrom) to the 'to' point.
(c) swing((Xto, Yto, Xfrom, Yfrom, Xpivot, Ypivot) -- the angle which a ray hinged at the 'pivot' point (Xpivot, Ypivot) makes in swinging from the 'from' point to the 'to' point.
<B>tan</B>(<# blue>Variable<# black>) -- the tangent of the variable (which is taken as being in radians). Inverse function: <# blue>arctan(..)<# black>.
<B>text</B>(<# blue>One or more variables or literals<# black>) -- returns a characters array built from the arguments. Character arrays and literals are taken as containing unicode values; non-character arrays and scalar variables have their values transcribed to character representations of those values. The arguments are handled exactly as for display functions such as <B>write(..)</B>.
<b>thislineno</b>() -- No arguments. Returns the number of the line of text in the Assignments Window which contains the function itself. (Lines are numbered such that the first line of text is line 1.)
<B>timer</B>(<# blue>scalar TimerID<# black>) -- There are (notionally) 20 timers on board; this reads the nth. timer ( n in range 0 to 19). If you previously called 'starttimer(n)', the no. msecs. since that call is returned; otherwise the no. msecs. since the start of 1AD. A call to 'timer(.)' does not reset the timer; it only reads the current value.
You can pause timer n by the call <# blue>timer(n, "pause")<# black>; the timer will resume when you call <# blue>timer(n, "resume")<# black>.
You can also query timer n to see if it is paused: <# blue>timer(n, "?paused")<# black> returns TRUE if it is paused, otherwise FALSE.
There are <b>two special arguments</b> for timer(.): <# blue>timer(-1)<# black> returns the time (msecs.) since the user program started; <# blue>timer(-2)<# black> returns the time (msecs.) since this instance of MonoMaths started.
An <b>error is raised</b> if the argument is outside of the range -2 to 19.
<B>touch_array</B>(...) -- a very dangerous function, for very rare use only. Enter name into Assignments Window and key F1, for information.
<B>tozero</B>(<# blue>Variable [, scalar NoDecDigits]<# black>) -- If only one argument, gives the first integer which is at or closer to zero than Variable. If a second argument is present, it gives the nearest number closer to zero of that precision (or Variable itself, if Variable has that precision). E.g. 'tozero(1.234,1)'  returns 1.2; 'tozero(-1.234,1)'  returns -1.2. Negative numbers are allowed: 'tozero(57, -1)' returns 50.  See also 'fromzero(.)', 'floor(.)', 'ceiling(.)'.
NB:  Internal numerical handling errors can cause unexpected results; e.g. if x, the result of a division, should theoretically be 1 but in fact is 0.9999... due to such errors, then  the theoretical value of tozero(x) would be 1 but the actual value would be 0.
<b>train</b>(<# blue>char. array Mode, ... <# black>) -- a suite of subfunctions to deal with 'trains'. A train is a concatenation of subarrays, the train having a header section which allows individual subarrays to be distinguished. Too complex for here; instead, enter the word 'train' into the Assignments Window and click F1 for a full account.
<B>transpose</B>(<# blue>Array<# black>) -- NOT void. Works only with two-dimensional structures: vectors (1xn or nx1) and matrices (mxn). The function returns the transpose of the argument, as a structured two-dimensional array. One concession: a list array will be interpreted as a <I>row</I> vector, and so would not raise an error. (This is also true with 'mxmult(.)', but is not generally true for matrix-handling functions.)
<B>truncate</B>(<# blue>Array, scalar DesiredLength<# black>) -- returns a copy of Array, truncated to the desired length. (If Array is shorter, it is returned in toto.)
<B>unbin</B>(<# blue>array Values [, scalar TreatAsCharsArray]<# black>) -- Returns the number represented by the binary digits implied by Values. If Values is to be treated as a chars. array, all chars. other than '0' (unicode 48) and '1' (49) will be ignored; and the first '0' or '1' of the array is treated as the most significant bit. Hence, "unbin('0000-1000')" will produce 8.
If Values is to be treated as a non-chars. array, zero is taken to represent binary digit 0 and any nonzero value as digit 1. This time, the first value in the array is taken as the <I>least</I> significant bit. "unbin(data(0, 0, -123))" would also return 8. If pseudoboolean argument 'TreatAsCharsArray' is present, its value overrides the internally stored 'IsChars' rating of array Values.
<B>unchars</B>(<# blue>Any no. of arrays<# black>) -- See <# blue>chars(..)<# black>, for which this is the inverse function.
<B>undim</B>(<# blue>Any no. of arrays<# black>) -- Redimensions all supplied arrays as list arrays. Arguments can have different sizes and dimensions, but all arguments must be named arrays, already assigned.
<B>unhex(chars. array HexString [, bool isInt16] )</B> -- Converts a hex-coded number (as a string of characters) to its scalar value. If there is no boolean argument, or it is FALSE, will convert up to 16 hex digits; but for HexString beyond "7fff ffff ffff ffff" (16 digits) will result in a negative no. If HexString has more than 16 digits, only the right 16 will be accessed and so converted.
If the boolean is present and TRUE, the function will convert only up to 8 digits, and HexString beyond "7fff ffff" returns a negative value. HexString is not case-sensitive. Spaces and tabs within HexString are tolerated, but no other characters (e.g. no prefix "0X" allowed).
<B>unicode</B>(<# blue>Any no. and mix of scalars or arrays<# black>) -- returns a chars. array using the supplied values as unicode values. These values are rounded; also, any values below 0 or above char. hex. DFFF (decimal 57343) are converted to 32 (space). 
<B>unjag(</B>(<# blue>Matrix, RowNo [, scalar PadValue]<# black>) -- Intended for matrices created with e.g. 'jagger(.)'. Returns the row of Matrix indicated by RowNo, after trimming pad values from the end. If PadValue is not supplied, it removes any final value from 32.0 down to 0 (no rounding). If PadValue is supplied, only that exact value is removed. If trimming would logically return an empty array, an array of size 1, value NaN is returned, and a call to 'empty(.)' will return TRUE. Note that PadValue must be a scalar (e.g. '32' or 'asc(" ")', for the space character).
You can safely use a list array in place of Matrix, in which case it will simply return the array trimmed at the end, as for rows of a jagged matrix. This concession is here to allow for functions (such as 'request(.)') which in different circumstances may return either a list array or a jagged matrix.
<B>unmerge</B>(<# blue>SourceArray, named array Destination1, named array Destination2 [,  named array Destination3 ... ]<# black>) -- (All of the named arrays must have been predefined as arrays, though they will be recreated here.) The data in SourceArray will be dealt out to the various destination arrays. If the length of SourceArray is not an exact multiple of the number of destination arrays there will be a remainder which is not distributed; the <b>value returned</b> is the amount of this unused data (and therefore 0 if all data was distributed).
 For example:
	<# blue>SourceArray = data(1, 2, 3, 4, 5, 6, 7, 8, 9);
	N = unmerge(SourceArray, Arr1, Arr2, Arr3); <# magenta>// Arr1 --> { 1, 4, 7 };  Arr2 --> { 2, 5, 8 };  Arr3 --> { 3, 6, 9 }; and N = 0.
	<# blue>SourceArray = data(1, 2, 3, 4, 5, 6, 7, 8);
	N = unmerge(SourceArray, Arr1, Arr2, Arr3); <# magenta>// Arr1 --> { 1, 4 };  Arr2 --> { 2, 5 };  Arr3 --> { 3, 6 }; and N = 2.
If you want just one output array - say Arr1, but not Arr2 and Arr3 - then you are  better to use function <# blue>downsample(.)<# black>.
<# black>The inverse of this function is <# blue>merge(.)<# black>.
<B>unpack</B>(<# blue>array Donor; any number of variable names<# black>) -- Copies the values in 'Donor' to the variables in the list, be they arrays (structure ignored) or scalars. It returns a success indicator; if there were not enough variable spaces to take all the donor wanted to give, then the indicator is positive, being the amount of data left over. If there was not enough in the donor to satisfy the demand, the indicator is negative, being the shortfall. Zero = complete match. Where the donor had insufficient data, the variables that missed out retain their preexisting values. True, even if data peters out half way through filling an array; the rest of the array retains its preexisting values. 
The first argument may be any array of any structure, assigned or not. For the rest, if an unassigned variable name is in the list it will be defined on the spot as a new scalar, and assigned the value due to it from its position in the list. Apart from 'dim(.)', this is the <I>only</I> function in <I>MiniMaths</I> which allows you to use new variable names as arguments; they will be set up as scalars. This is the real strength and purpose of the function: you can define a wad of new scalars from an array in one go. Here is an example, where graph parameters are assigned, the graph in this case having the ID "thisgraph":
\t<# blue>unpack(readgrid(thisgraph), Xmin, Xmax, Xsegs, Ymin, Ymax, Ysegs); <# magenta>// all new variables, not previously mentioned.
<# black>One use for this function is where you have a large wad of the same arguments to pass to several of your functions; you can wrap them up into an array in the main program, using function 'data(.)', and then unpack them locally in each such function, for your code simply using copy-paste to lift the arguments out of the 'data' statement and into the 'unpack' statement.
<B>upsample</B>(<# blue>Array, Scalar UpsamplingRate, variable Method [, Scalar StartPtr[, Scalar EndPtr [, Scalar LopCount ]]]<# black>) -- Nonvoid. Returns a list array, the result of upsampling the data in Array.
<i>Array</i> -- may have any structure, but must contain at least 3 data items. Whatever its structure, the returned array is always a list array.
<i>UpsamplingRate</i> -- This is rounded; the resulting integer should be ≥ 2, for upsampling to occur. If it is ≤ 1, the function simply returns  a copy of the data of the original array (as a list array), ignoring remaining arguments.
<i>Method</i> -- If Method is 'Z' or 'z' or 0, interpolated values are all zero. If 'L' or 'l' or 1, linear interpolation occurs. If 'S' or 's' or 2, stepwise interpolation (the previous value is perpetuated over the interpolation interval). If 'C' or 'c' or 3, cubic splining is used, giving something looking like a polynomial fit curve.
<i>StartPtr, EndPtr</i> -- If supplied, only that part of the data within the defined subarray will be upsampled; but the returned array still contains the original data before StartPtr and after EndPtr.
If EndPtr is too large, it is internally downsized to the last member of the array, without error. Don't mess with StartPtr, though.
<i>LopCount</i> -- If present and a sensible value, that no. of values are lopped off the end. (The main use: set to 1 with stepwise upsampling, where you don't want the final riser included, but just want to end on a flat top step.) You can use '-1' as a filler for StartPtr and/or EndPtr where you are supplying LopCount (in which case they assume default values).
<b>val(.)</b> -- see "stringtovalue", of which it is an alias.
<b>valuetostring</b>(<# blue>scalar or array Value [, array: FormatHow]<# black>) -- returns a character array, expressing the value as a string of characters. If Value is an array, the separator ", " occurs between separate value strings. If FormatHow is present, it must be such as is recognized by C#, as it is passed uncritically to C#. If the format is faulty, one of the following can happen: (a) it is ignored, and the default format occurs; (b) garbage is returned (usually the variable type name in C#); or occasionally (c) MonoMaths crashes without an error message. So don't get it wrong. Allowed values that work in MonoMaths (which only uses C# type 'double' for variables) are found by entering this function's name into the Assignments Window and keying F1. Note that <b>str(..)</b> is exactly the same function (an alias for frequent users).
<B>vecdirns</B>(<# blue>array PointsGrid, matrix Angles, scalar OR matrix ArrowLength<# black>) -- Used in the displaying of vector directions in a field. Recall that one of the optional arguments of 'plot(.)' defines line type, and two of the line type codes are ' < ' and ' >'. These options cause only alternate pairs of points along a curve to be joined, giving a dashed effect; they also suppress drawing of either the start or the end point, so that the remaining point suggests an arrow head (though the 'arrow' actually looks more like a sperm). You can provide the data for such a graph using this function. 
<I>The arguments:</I> <# blue>PointsGrid<# black> is an array of at least size 6, detailing which points in the field are to be sampled: [X min. value, X max. value, no. X intervals, Y min. value, Y max. value, no. Y intervals]. (Any further content is ignored.) For example if you want to show vector directions at X = 0, 0.1, 0.2, ... 0.9, 1, the first three arguments of PointsGrid would be: 0, 1, 10. <# blue>Angles<# black> is a matrix containing the angle (in radians) at every point in the grid; so its dimensions must be [No. Y segments + 1] x [No. X segments + 1].  <# blue>ArrowLength<# black> is what it says; all the arrows on the graph will have this length. It may be scalar - all arrows have the same length - or a matrix of exactly the same dimensions as Angles, holding the length of the vector at every point.
<I>The returned matrix</I> has dimensions [2 * total size of Angles] x 2. Note the two columns; column [0] holds all the x coordinates and column [1]  all the matching y coordinates.
An <B>example</B> of use is definitely needed for this function; you can find one by entering 'vecdirns' into the Assignments Window and then keying F1.
<b>window</b>(<# blue>array WhichWindow, array Action [, array TheText, array / scalar Where [, bool Formatted OR scalar NoCharsToDelete ]]<# black>) -- operations on the Assignments Window and the Results Window during a program run.
<i>WhichWindow:</i>  The first letter must be one of: 'A', 'a' (Assignments Window),  'R', 'r' (Results Window).
<i>Action:</i>  The first letter must be one of: 'C', 'c' (clear of all text),  'F', 'f' (focus the window),  'R', 'r' (read all text),  'W', 'w' (write the supplied text into the window), 'M', 'm' (adjust markup tag status), 'D', 'd' (delete text). 
For Action 'C', 'F' and 'R', only the first two arguments are required or accessed. With 'clear' and 'focus', the funtion is VOID; with 'read', NONVOID, returning the text from the window. (If the window is empty, 'read' returns an array consisting of a single space.)
For Action 'M', the third argument 'TheText' must be present, and will be "+" (to turn markup tags usage on), '-' (to turn it off), '?' (to leave it alone - done where you just want to know the current status). For all three, the function is NONVOID, returning "+" or "-" to indicate status after the action. NB - can only be used with WhichWindow = 'A'. 
For Action 'W', 'TheText' is what is to be written to the window.
'Where' must be one of: "<# blue>fill<# black>" = replace any current text with this text; "<# blue>cursor<# black>" = insert text at current cursor position; "<# blue>start<# black>" = insert text at the start of existing text;  "<# blue>append<# black>" = append text to the end of existing text;  <# blue>numerals<# black> (e.g. the scalar 36, or its string form "36") = start inserting at the specific character position in the existing text. Any other value aborts the method. 
'Formatted:'  If present and TRUE, then formatting tags are handled (enter 'format' into the Assignments Window and key F1, for tag descriptions).
The function is VOID.
For Action 'D', all 5 arguments must be present, though 'TheText' is ignored (and so may be scalar). 'Where' must be an integer (either scalar, or as the string form of the integer). The final argument tells how many characters to delete, and must be at least 1. The function is VOID.
<i>Errors</i>  in arguments don't crash the program; simply nothing happens, AND scalar 0 is returned - important to know, if you were expecting an array back.
<b>window_find(</b><# blue>variable SoughtText<# black>) -- invokes the Search dialog box (exactly as with main menu item "Search | Find"). The position of the cursor is relevant. Works only for the Assignments Window. If 'SoughtText' is scalar, or if its first value is not a valid unicode \> 0, the dialog box opens with the 'search for:' text box empty. Otherwise SoughtText goes there as the default text.
<b>window_find(</b><# blue>char array SoughtText, bool MatchCase, bool WholeWord, bool FromCursorDown, bool MarkAll<# black>) -- carries out a search on Assignments Window text as above, but bypasses the dialog box. (However if any arguments are missing, or if 'SoughtText' is anything but valid text, the Search dialog box is invoked and all the other arguments are ignored.) MatchCase and WholeWord are obvious. If FromCursorDown is false, search starts from the cursor; otherwise from the start of window text. If MarkAll is true, all values are marked with background colouring (removed by keying 'ESC'). Otherwise the next find only is marked (with cursor placed there).
<B>write</B>(<# blue>One or more variables or literals<# black>) -- A void function, which displays its argument in the Results Window: 'write("Current value of x: ",x);'. See Help menu item <I>Data Input and Display</I> for more details on the use of this function.
<B>writeln</B>(<# blue>One or more variables or literals<# black>) -- as for 'write(..)'; the only difference is the automatic insertion of a final line feed.
<B>xmenu(..), xvisible(..), xclick(..)</B> -- There is a hidden main main menu item which the user can invoke, equipping it with 1 to 20 submenus. This extra menu system is invoked with void function <b>xmenu( Title, Subtitles )</b>, where 'Title' is the title of the added main menu item, and 'Subtitles' is the accumulated titles of its successive submenus, delimited by '|'. E.g. <# blue>xmenu( "Change Colour", "Red | Green | Sky Blue" )<# black> will produce a menu named 'Change Colour' with three submenus. Note that spaces at the start and end of titles are ignored, but internal spaces (as in "Sky Blue") are preserved. To change even one title or subtitle, or the number of submenus, you have to call "xmenu(.)" again with all arguments, as if calling it for the first time. Empty titles and subtitles should be avoided. 
All submenus are automatically visible after the above. To alter visibility, use <b>xvisible(Visibility)</b>, where 'Visibility' is an array of 'true' (for 'make visible') and 'false' ('make invisible'). (It can also be a set of scalars, or a mix of both.) Visibility[0] applies to the main menu item, and Visibility[1+] to the submenus. If there are less argument values than menu items, only those addressed will have visibility affected. If there are more argument values, the excess will be ignored.
The function <b>xvisible(.)</b> is not void, but always returns the final visibility state of all items as an array. So if you don't want to change the visibility of the second submenu but just want to read its visibility, use <# blue>arr = xvisible(1);<# black> - which makes the main menu item visible (if it wasn't already) - and then test arr[2].
To read clicks, use <b>xclick()</b>. This returns the index of the submenu clicked, and then immediately resets the internal flag raised by that click so that a second call to 'xclick()' would return -1 instead. If no click has occurrred in the lifetime of the program, this function returns -1. Note that submenus are <i>numbered from 1 upwards</i>, as they are for function 'xvisible(.)'. Note also that this function does not detect a click on the main menu item itself. 
<B>xor</B>(<# blue>Variable1, Variable2 [, scalar Tolerance ] <# black>) -- returns an object with the structure of Variable1 (scalar allowed), assigning a boolean score to every pair of corresponding elements in Variable1 and Variable2. Where <I>one</I> of the elements in the pair is zero, <I>but not both</I>, the score is 1; otherwise, 0.
If there is a 3rd. argument 'Tolerance' and it is positive, a match is regarded as occurring if the absolute difference between the two elements is <= Tolerance.
Argument combinations allowed are: scalar-scalar;  array-array (of same size, not necessarily of same structure); array-scalar (in which case the scalar is replaced by a virtual array containing only that scalar value).
See also binary logic functions 'and(.)', 'or(.)'  and 'xorcomp(.)', and unary functions 'is(.)', 'not(.).
<B>xorcomp</B>(<# blue>Variable1, Variable2 [, scalar Tolerance ] <# black>) -- returns an object with the structure of Variable1 (scalar allowed), assigning a boolean score to every pair of corresponding elements in Variable1 and Variable2. Where <I>one</I> of the elements in the pair is zero, <I>but not both</I>, the score is 0; otherwise, 1. (A pair of zeroes or a pair of nonzeroes score 1.)
If there is a 3rd. argument 'Tolerance' and it is positive, a match is regarded as occurring if the absolute difference between the two elements is <= Tolerance.
Argument combinations allowed are: scalar-scalar;  array-array (of same size, not necessarily of same structure); array-scalar (in which case the scalar is replaced by a virtual array containing only that scalar value).
See also binary logic functions 'and(.)', 'or(.)'  and 'xor (.)', and unary functions 'is(.)', 'not(.).
=========================================
//LOOPS AND INTERRUPTS//
<just c><B>LOOPING and INTERRUPTING FLOW</B>

<just l>(<B>NB</B> - If you are <B>caught in an eternal loop</B>, you can always interrupt operation by <B> clicking on the ABORT button</B> which is always visible during program runs).

<U>'FOR'  LOOP</U>
The syntax used is that which is standard for all languages that use the C model. Suppose, for instance, that you wish to generate the sum 1+2+3+4+5; you could use this code:
\t<# blue>x = 0;
\t<# blue>for (i = 1; i <= 5; i++){ x = x + i; }
<# black>Note the three segments inside brackets '(..)', and separated by semicolons ';':
<bullet>An assignment which sets a counter to its initial value - "i = 1".
<bullet>A condition which allows looping only while it evaluates to TRUE: "i <= 5".
<bullet>An assignment which changes the value of the counter at each loop: "i++".
The third component does not have to simply increment the counter; it can in fact be any assigment you like, as long as it eventually leads to a value of the counter which will allow the loop to end (by causing the condition to evaluate to FALSE).

<B>Points re the above:</B> 
<bullet>You must enclose the three loop-counter statements in brackets '(..)';
<bullet>You must separate the three loop-counter statements by semicolons ';' (not e.g. by commas).
<bullet>You can omit the braces '{..}' if there is a single action assignment: 
\t<# blue> for (i = 1; i <= 5; i++)  x = x + i;

<# black><B>Shorthand version</B>
It is most common for FOR loops to start with the counter set to 0 and simply to increment it at each loop. As this is so common, the following shorthand has been devised -
\t<# blue>for (k, N) {...}
<# black>- which is equivalent to
\t<# blue>for (k = 0; k < N; k++) {...}

<# black><B>Further Points</B>
<bullet>Loops may be nested to any depth.
<bullet>Loop counters need not be integral. This works fine: "for (i = 1.02; i < 10*PI; i+= sqrt(2) ) {...}".
<bullet>The condition is reevaluated at every loop. For example, "arr = data(1,2,3);  for (i=0; i < size(arr); i++) arr = data(arr, 1);" will go on forever, as 'arr' is constantly getting longer, and 'i' can never reach its size.
<bullet>The loop variable can have its value altered within the loop (though this is not a recommended programming technique).
You can examine the value of the loop counter after the loop. It will hold the incremented value which overshot the limit; e.g. for the loop 'for (i = 1; i < 2;  i += PI)...', i will end up as 4.14159... .

<I>Be careful with calculated loop counters.</I> 'a++' is safe, but anything which computes a value using multiplication or division may return a value not quite like you expect (e.g. 9.9999.. instead of 10), due to the inherent rounding errors in computer number-crunching. If your loop's upper limit is 10 (e.g. 'for (i = 1; i < 10; ...) then '9.99..' will evoke one more loop than you wanted.


<just l><U>'WHILE'  LOOP</U>
Again, the syntax of all C-type languages is used:
\t<# blue>x = 1;
\t<# blue>while  ( x < 10)  { x++; }
<# black>The brackets '()' are essential around the condition. The braces '{..}' may be omitted if you have a single action assignment, as in the above example:
\t<# blue>while  ( x < 10)   x++; 
<# black>Points listed above under 'Points re the above' and 'Further Points' apply here also (except the first two, which are obviously specific to the 'for' loop).

<# black><just l><U>'DO .. WHILE'  LOOP</U>
Again, the syntax of all C-type languages is used:
\t<# blue>x = 1;
\t<# blue>do  { x++; } while ( x < 10);
<# black>The brackets '()' are essential around the condition. The braces '{..}' may be omitted if you have a single action assignment, as in the above example:
\t<# blue> do  x++;  while ( x < 10);
<# black>Points listed above under 'Points re the above' and 'Further Points' apply here also (except the first two, which are obviously specific to the 'for' loop).

<# black><just l><U>'FOREACH'  LOOP</U>
This differs from the 'foreach' syntax of other C-type languages, though it is a development from it. There are three forms, depending on the number of arguments that you supply in brackets after 'foreach' (two, three or four). The full four-argument syntax is as follows:
\t<# blue>foreach(x, y, i, AA)   {  ....  }<# black>
where x, y and i are scalar variables (not necessarily declared beforehand), and AA is an array.
Using the particular variable names given in the example above:
<bullet>AA is an existing named array; there will be one loop executed for each element in AA.
<bullet>'x' will be internally assigned to AA[i] at the start of the loop;
<bullet>'y' starts equal to x; whatever value you assign to it will, at the end of the loop, be the new contents of AA[i]. (If you don't intend AA to be changed, simply don't make any reference to 'y' in your loop code.)
<bullet>'i' is the iterator for the loop. You can ignore it, but sometimes it is handy to have access to it. (You actually can change it in the loop code, and so interfere with the order of loopings. This would usually be a daft thing to do, but occasionally could be made to achieve some interesting results.)
<b>NB!</b> No notice is taken of the structure of AA; all its data will be looped through, and 'i' will track the <b>absolute address</b>, not the address by rows and columns.

Here is an example which converts a matrix containing an arithmetic progression into one containing a sequence of factorials.
	<# blue>Mx = data(1,2,3,4,5,6);   redim(Mx, 3, 2); <# magenta>// a matrix with rows  { 1, 2;  3, 4;  5, 6 }.<# blue>
	ylast = 1;
	foreach(x, y, i, Mx)
	{	
		y = x * ylast;   <# magenta>// x was internally set to Mx[i] at the start of the loop.<# blue>
		ylast = y;	
		<# magenta>// Internally, Mx[i] is now set to the final value of y. If y was never introduced, that final value is the original value.<# blue>
	}
	writeln(neat(Mx)); <# magenta>// This will display a matrix with rows  { 1, 2;  6, 24;  120, 720 }.<# black>

<u>Shortened forms of "foreach"</u>
<bullet><# blue>foreach(x, AA)   {  ....  }<# black> -- where you don't want to change elements of AA. This version is significantly faster than an equivalent FOR loop, and <i>much faster</i> than the full 4-argument form of "foreach" (which is about one third slower than the equivalent FOR loop).
<bullet><# blue>foreach(x, y, AA)   {  ....  }<# black> -- where you don't need access to the iterator. There is no significant time saving over the 4-argument version (it is of the order of half a percent). 

<font same, 10><u>Timing considerations</u>
<bullet><i>Case 1 -- You don't want to change the array.</i>  Use the two-argument form; this is a bit faster than an equivalent FOR loop (around 12% faster). Don't use the three or four argument form: these take about 1/3 as long again as the equivalent FOR loop.
<bullet><i>Case 2 -- You DO want to change the array.</i>  You have to use the 3- or 4-argument version (virtually no time difference between the two - of the order of 0.5%). If you only refer to the element once in the loop (that is, one use of 'x' or 'y' in the FOREACH loop, and one of 'Arr[i]' in the equivalent FOR loop), then the FOREACH version takes a tiny bit longer than the FOR loop equivalent - around 5% longer. But if you make two references to the array element in the loop, the 'foreach' version is 8% faster; and it would be faster again for multiple such references.
</font>


<# black><b>INTERRUPTING FLOW</b>

<i>(1) Programmatically:</i>

BREAK, CONTINUE: In loops, you can use the instructions 'break' (break out of the loop) and 'continue' (jump over the following instructions to the loop end, for this cycle). Where loops are nested, the instruction only applies to the loop in which it is placed.
 
EXIT:  Causes the program to end: "if (timeElapsed > timeLimit) exit;". It can only be used in the main program, not in functions (where 'return' is the right way to end operation). (However there is a way of ending a program from within a function - see 'force a crash' below .)

EXIT AND SHUT DOWN: If you want the <I>MonoMaths</I> instance to close when the program is finished, include the void function call "kill_on_exit();" somewhere where it will be processed before the program is finished. (It will not close the instance if the program ends because of an error crash.)

FORCE A CRASH: You can raise an error anywhere using function '<b>crash(Msg)</b>', where Msg is the error message you want displayed in the Results Window after the crash.  ('Msg' can be a string of variables: "if (x < A ||  x > B) crash("'x' must lie between ", A, " and ", B );" 

PAUSES:  A call to the void function '<B>pause(n)</B>' (where n evaluates to 0 to 9) halts operation; in the halted state you can examine variable values by keying F1 while the cursor is at the variable. Program flow resumes when you click the "GO" button (now renamed "RESUME"). (The status is shown in the form header; if program operation is proceeding, " [RUNNING]" follows the name of the program file; if paused, "[PAUSE n]" follows the name - 'n' being the index of the pause.)

\tThe power of a "pause(.)" instruction to evoke a pause can be turned on ('activated') and off ('inactivated') either from the keyboard or programmatically. NB - "pause(0)" is activated by default at startup, but "pause(1)" to "pause(9)" are inactivated by default.
\t<I>From the keyboard:</I>  A two-keypress code toggles the pause on and off: [Cntrl-Shift-P] followed by the number of the pause (0 to 9). (Make sure focus is in the Assignments Window when keying, or nothing will happen.)
\t<I>Programmatically:</I>  <B>pausable(n)</B> returns 1 (TRUE) if pause n is activated, otherwise false. <B>pausable(n, bool)</B> activates pause n if 'bool' is 1 (or anything other than zero), inactivates if 'bool' is exactly 0. (It also returns the final activation state, like the single-argument version.)


<i>(2)  Otherwise:</i>

BREAK POINTS:  There is a menu option "Run | Toggle Break Point", more conveniently effected by using the key combination Cntrl-Alt-B (as shown on the menu). If you apply this at any code paragraph, the paragraph will be highlighted with a specific colour; and when the program runs, operation will halt there till you click the 'RESUME' button, just as with the 'pause(.)' function mentioned above. To remove all break points at once, either use the menu option "Run | Remove All Break Points" (key: Cntrl-Alt-K) or else key Cntrl-Escape (which also removes other colour tags).
<i>Small print points:</i>  (1) There is nothing to stop you marking a remarks-only line as a break point, but it won't have any effect. (2) If you add text to the front of a highlighted break point line (so that there is unhighlighted text at the beginning of the line) it will no longer break; an extra keying of Cntrl-Alt-B will restore the full highlight. (When the program is being parsed after 'GO' is clicked, it looks for lines which <i>begin</i> with the highlight colour; only those lines will acquire internal break points.) (3) You can set or unset a break point while the program is running (say, while it is on hold from an earlier break point). (4) There is a small time cost to using break points (even if never reached by code); this is of the order of 10% to 15% for one break, with much smaller increments for further breaks.
A hint: better not to use on a line with '}' somewhere in it. For example, if this '}' ended an 'if ([condition]) { .. }' section, the break point would operate whenever the 'if' condition was evaluated, whether it evaluated as TRUE or FALSE.

INTERRUPTING AN ONGOING PROGRAM:  While the program is running, the 'GO' button will be renamed 'FREEZE'. If you click on it a message box will appear offering three options: continue operation; go into a hold state (as at a break point or by a 'pause(.)' call); or abort the program. This is particularly valuable if the program is caught in an eternal 'while .. do' loop.
Clicking the top right corner icon will also have the same effect.

===================================================
//CONDITIONALS//
<just c><B>CONDITIONAL STATEMENTS</B>
<just l>
There are three formats in MonoMaths for conditional decision-making:
<bullet>Using keyword <b>if</b>:  the syntax used is that which is typical for C and C-derived languages.
<bullet>Using <b>shorthand version of "if"</b> which involves symbols '?' and ':'
<bullet>Using keyword <b>sift</b>: this is analogous to the 'switch' statement in C and C-derived languages, but has major differences (it is much better!), so has been given a different name.

<just c><b>1.  "IF"  STATEMENTS</b>
<just l>
<U>Examples </U>
<# blue>if  (a == 0)  {  p = 1;  q = 2; }
<# blue>if  (a == 0)  {  p = 1;  q = 2; }  else  {  p = 3; q = 4; }
<# blue>if  (a == 0)  {  p = 1;  q = 2; }  else if  (a > 0)  { p = 3; q = 4; }  else  {  p = 5; q = 6; }

<# black>There can be multiple 'else if' segments. And of course any valid code (including nested 'if' statements) can replace the simple assignments 'p = 1; ...' above.

Note that the for the key phrase <b>else if</b>, the two words must be on the same line, and separated only by blanks. (You can actually use the instruction without any blank - <b>elseif</b>).

Points to note:
<bullet>Brackets '(', ')' around the condition are essential. 
<bullet>Braces '{', '}' may be omitted in any of the above cases if there is only a single assignment between them:
\t<# blue>if  (a == 0)   p = 1;   else if  (a > 0)   p = 3;   else    p = 5; 
<bullet><# black>Semicolons are essential <I>between</I> assignments, as everywhere else in <I>MonoMaths</I>, but are optional before braces and before 'else' and 'else if'.

<U>THE CONDITION SECTION</U>
Allowed conditional operators:
	 '==' ('equals')
	'!='  (is not equal to)
	>,   >=,   <,   <= (greater than / greater or equal / less than / less or equal) 
Conditions may be joined by:
	 '&&'	(representing logic AND)
	 '||'	(representing logic OR)
	'^^'  (representing logic XOR)
Brackets  may be omitted, if you are willing to depend on the natural order of computation (given below).

<b>Differences with other C languages:</b>
<bullet>In some languages, such as C#, it is possible to use a single '&' and a single '|', the difference being that e.g. "A & B" always evaluates B, but "A && B" won't evaluate B if A is 0. There is no such single operator in MonoMaths.
<bullet>In some languages, such as C#, there is no operator "^^"; the XOR operator is simply "^", as it is always necessary to evaluate both values connected by XOR. In MonoMaths, however, the operator "^" is reserved for indicating a power index (e.g. "2^3" for the cube of 2), so you are forced to use "^^" as the XOR operator.

Example of a conditional section:
\t<# blue>if  (a > 10 && (b > 10 || c < 15)) {... 

<# black><b>Use with arrays:</b>
<bullet><i>Array - scalar combinations:</i>  allowed <i>provided</i> the array has a length of exactly 1. A typical use would be:  <# blue>if (ss[0] == 'a') ...<# black>, where ss is a list array, so that ss[0] is scalar.
<bullet><i>Array - array combination:</i>  Only allowable with operators '==' and '!='.  Only the raw data is compared, not array structure or characters rating. Arrays will be regarded as 'equal' if they have the same total length and contain identical data; e.g. the 2x2 matrix [65, 66;  67. 68]  and the chars. list array "ABCD" would be judged equal.

<B>booleans?</B> There is no special variable type 'boolean'. However any scalar can be interpreted as one by a conditional section. The rule is: any scalar that evaluates exactly to zero is 'false' and any nonzero scalar is 'true'.
You can even use the common language operator '!' as the NOT operator. You can apply this to any value; '! x' returns 1 if x is exactly 0, or returns 0 if x is any nonzero value. Used with an array, each term is set accordingly.
If there is some risk that due to internal numerical errors a number might not be exactly zero (e.g. 'sin(PI)' evaluates to a very small negative number), use instead the system function 'not(x, limit)', which evaluates to 0 if |x| is less than or equal to 'limit' - see 'System Functions' section for more details.
Two system constants are defined: <# blue>TRUE<# black> (or <# blue>true<# black>), which simply evaluates to 1, and <# blue>FALSE<# black> (or <# blue>false<# black>), which evaluates to 0.


<B>Order of processing in conditional statements</B>
The 'not' operator '!' -- see below -- has precedence over all others.
Where two conditions are joined by '&&' or '||', the condition on the left is evaluated first; if this determines the outcome, the condition on the right is not evaluated. For example, the following will not provoke a 'divide-by-zero' error, if variable 'a' is zero:
\t<# blue>if (a != 0) && (1/a < 1) {...

<# black>The logic joiners '&&' and '^^' (which are on the same level) are processed before '||', so that the following have different meanings:
\t<# blue>if  (a > 10 && (b > 10 || c < 15)) {..
\t<# blue>if  (a > 10 &&  b > 10 || c < 15)  {..

<# black><B>The 'not' operator "!"</B>
This is typically used with a conditional statement ("if (!(a == b))..".  But it can also be used with a scalar or array value, in which case it produces a copy of that scalar or array with every <I>nonzero</I> value replaced by '0' and every <I>zero</I> value replaced by '1':
\t<# blue>arr = data(-1, 0, 0.001, 10);
\t<# blue>brr = !arr; <# magenta>// 'arr' is unaltered, and 'brr' is set to [0, 1, 0, 0].
<# black>There is also a system function "not(.)" which does the same, with the extra advantage that it can treat near-zero values as zero, if you wish it to do so. (There is also a complementing function "is(.)" which does the reverse; it replaces all nonzero values with '1' and all zero values with '0'.)


<# black><U>FURTHER POINTS</U>
<bullet 30,1.>You can freely <B>use conditional statements outside of 'if' constructions.</B> A 'true' condition always returns 1, and a 'false' condition returns '0'. For example, "parity = (mod(N, 2) == 1)" will cause the variable 'parity' to be 1 for even N and 0 for odd N. ("mod(..) returns the modulus.) Similarly, "Sign = (N >= 0)" will set 'Sign' to 1 for positive or zero numbers, 0 for negative numbers.
<bullet 30,2.>In conditional statements - again, as in all C-like languages - you should <B>always use '=='</B> for the (notional) statement "if A equals B...", not '='. (In fact, the parser does substitute '==' for inadvertently used '=' after 'if' and 'while'; but it does not elswhere; for example, you cannot get away with '=' for '==' in "x = (p == q)" or " return (a == b)".).
<bullet 30,3.><B>Always keep in mind the problem of internal numerical errors</B> inherent in computing. If several steps of calculation have produced variable 'a', then the outcome might be 9.9999.. where you would have expected 10. In that case, the test 'if (a == 10)..' will unexpectedly fail.

<just c>__________________________________________________

<just c><b>2.  THE SHORTHAND VERSIONS</b>
<just l>
There are two versions, one for where there are only two possible outcomes (i.e. the condition evaluates to either 'true' or 'false'; and one for where there are three possible outcomes (the 'condition' is replaced by an expression which can be positive, zero or negative).

<bullet><i>Two possible outcomes:</i> The format is: 
<bullet 30,>	<b>a = expression <# red>?<# black>  outcome_if_true <# red>:<# black> outcome_if_false;</b>
<bullet 30,>Whether 'expression' is a condition or a nonconditional expression, if it evaluates to a nonzero value, the LHS 'a' acquires the value 'outcome_if_true'; otherwise 'a' acquires the value 'outcome_if_false. The outcomes may be expressions, but not assignments or code blocks.

<bullet><i>Three possible outcomes:</i> The format is: 
<bullet 30,>	<b>a = expression <# red>?<# black>  outcome_if_positive <# red>:<# black> outcome_if_zero <# red>:<# black> outcome_if_negative;</b>
<bullet 30,>As above, 'expression' and 'outcome_...' can be any expressions. Usually you would not use a conditional expression, as 'tertium non datur' - the third outcome would never be reached.

Note that the shorthand form must occupy the whole of the RHS of an assignment.
	<i>legal:</i>	<# blue>a = 10 + x ? 1 : 2;<# black>  <# magenta>// All from '=' to '?' is taken as the condition - in this case, "10 + x".<# black> 
	<i>WRONG:</i> <# grey>a = 10 + (x ? 1 : 2);<# black>
	<i>WRONG:</i> <# grey>a = sin (x ? 1 : 2);<# black>

It is a good practice to include the condition in brackets, if it is a logic expression; this becomes important when the operators '&&' and '||' are involved, as they are lower in the hierarchy than all the other logic symbols, and in particular, lower than those used in the prefixes added on internally. (What happens internally is that e.g. for the one-colon form "a = x > 2 ? ..." is converted to the equivalent of "if (x > 2 != 0) a = ...".)

The short forms work where the LHS variable is <i>scalar</i>. The function <b>sign(.)</b> will allow the use of arrays; that is, 'expression' can be replaced by a set of values, and 'a' will become an array in which outcomes are set element by element. (Be careful - the order of arguments is different.)

<just c>__________________________________________________

<b>2:  "SIFT"  STATEMENTS</b>
<just l>
A <b>sift</b> block allows one to choose one of several competing code blocks on the basis of the evaluation of some expression. (While it resembles the 'switch' block of C-like languages, there are important differences.)

Here is a simple example. Suppose that X is a scalar variable:
	<# blue>sift (X)  <# magenta>// Note the brackets around 'X'.<# blue>
	{
		1:	{ writeln("X = 1");  y = 100; }   <# magenta>// Note the colon, and note the  braces '{..}' after it.<# blue>
		2:  writeln("X = 2");  <# magenta>// You can only omit the braces if there is just one simple assignment or operation after the colon.<# blue>
		else:  { writeln("X isn't 1 or 2"); }  <# magenta>// Note the colon after 'else'.<# blue>
	}

<# black>A 'sift' block can always be replaced by a chain of 'if' statements; for example, the above gives the same output as:
	<# blue>if (X == 1)  {  writeln("X = 1");  y = 100; }
	else if (X == 2) writeln("X = 2");
	else writeln("X isn't 1 or 2");
<# black>

However the sift block is <b>much more powerful</b> than the above example.
<bullet>You can replace 'X' above by <i>any variable, scalar or array</i>; and by <i>any expression</i>: "sift(Array1 + Array2)".
<bullet>You can use any of the standard conditional test symbols: ">= 2: { ... }".
<bullet>You can include '&&' and '||': ">0 && < 1: { ... }";   "2 || 3 || 4: {..}".
<bullet>You can use expressions before the colon: "> sqrt(Y): { ... }".
<bullet>If 'X' is an array variable or expression, you can use index addressing. E.g. for a test on Arr[0]:  " [0]: { ... }".
<bullet 50,⇨>But you can only use it before any conditional test symbol; e.g. "[0] > 10: { ... }" is fine, but this will fail: "[0] > [1]: { ... }".
<bullet>You can nest 'sift' statements: " 1: { sift (Y) {... } }"  (though I can't begin to imagine why you would want to do that).


<b>Points of syntax to note</b>
<bullet>The keyword <b>sift</b> must be followed by brackets "(..)" containing a variable or an expression (which I still denote by 'X' below).
<bullet>Braces "{ ... }" must follow, containing the rest of the sift block.
<bullet>Note the colons, which <i>must</i> be present for every instance of X.
<bullet>Whatever goes before that colon is <i>anything</i> that could be legitimately written for '?' in the statement "if (X  ?)". For example, "\> 1", because it is possible to write "if (X \> 1) ..."; or "!= a^2" because it is permissible to write "if (X != a^2)...".
<bullet>If there is no conditional symbol before the colon, the symbol is assumed to be "==" (and is in fact inserted internally).
<bullet>The 'else:' line is optional.

<b>Points of operation to note</b>
<bullet>Important note for those familiar with C-type languages: Instances are completely separate from one another; focus does not 'fall through' from one to the next, as it does in the C 'switch' block.
<bullet 50,⇨>Therefore the keyword 'break' (used in C 'switch' blocks) should never be used to end an instance!
<bullet>The only situation in which you can dispense with the braces inside an instance is where the code block is a simple assignment. (This is the same rule as for the braces following an 'if' statement.) (This is another way in which this statement differs from the C-type 'switch' statement, where braces are unnecessary and usually omitted.)
<bullet>The block still works if the colon is left off the end of the  final 'else:'. This is accidental to the design of the code; should I revise the code in the future, I would ensure that the version with the colon was unaffected, but would not struggle to preserve this ambiguity. Therefore - don't omit the colon!

===================================================================
//FUNCTIONS BY CATEGORY//
The following list is provisional. All the functions are kept up to date, but they not very elegantly set out yet.

<# red>SYSTEM 
<# magenta>Deployment of the MonoMaths window and its constituent windows
<# black>    SysFn[393] = new TFn("reposition",1, 4,      0,        false,      1);
    SysFn[394] = new TFn("repartition",2,2,      0,        false,      1);
<# magenta>System information
<# black>    SysFn[392] = new TFn("commandline",1,1,      0,        false,      1);
    SysFn[387] = new TFn("datetime",  1, 1,      0,        false,      1);
    SysFn[285] = new TFn("keyed",     1, 2,      1,        false,      1);
    SysFn[342] = new TFn("keydown",   1, 1,      0,        false,      1);
    SysFn[421] = new TFn("keyname",   1, 2,      0,        false,      1);
    SysFn[397]  = new TFn("btnrelease",1,1,      0,        false,      1);
    SysFn[419] = new TFn("cursorposn",1, 2,      0,        false,      1);
    SysFn[398] = new TFn("cursordata",1,1,       0,        false,      1);
    SysFn[439] = new TFn("ini_data",  1, 1,      0,        false,      1);
<# magenta>Conditional tests on data (extending the 'if' instruction)
<# black>    SysFn[287] = new TFn("iff",       3, 4,      0,        false,      1);
<# magenta>Variable querying, manipulation<# black>
    SysFn[399] = new TFn("persistent_array",1,1, 0,        false,      1);
    SysFn[390] = new TFn("lookup",    1, 3,      0,        false,      1);
    SysFn[391] = new TFn("touch_array",4, 4,      0,        false,      1);
    SysFn[143] = new TFn("captured",  1, 1,      0,        false,      1);
    SysFn[157] = new TFn("clear",     1, MaxREFArgs, MaxREFArgs,true,  1);
    SysFn[163] = new TFn("kill",      1, MaxREFArgs, MaxREFArgs,true,  1);
    SysFn[409] = new TFn("setalias",  1, MaxREFArgs, MaxREFArgs, true, 1);
    SysFn[410] = new TFn("getval",  1, 1+MaxArrayDims, 0,  false,      1);
    SysFn[411] = new TFn("setval",  2, 2+MaxArrayDims, MaxREFArgs, false, 1);
<# magenta>Timers
<# black>    SysFn[133] = new TFn("starttimer",1, NoTimers,      0,        false,      1);
    SysFn[134] = new TFn("timer",     1, 2,      0,        false,      1);
<# magenta>Program interruption
<# black>    SysFn[208] = new TFn("pause",     1, 1,      0,        false,      1);
    SysFn[209] = new TFn("pausable",  1, 2,      0,        false,      1);
    SysFn[425] = new TFn("crash",     1, MaxREFArgs, MaxREFArgs,false, 1);
<# magenta>Error handling
<# black>    SysFn[109] = new TFn("errortrap", 1, 2,      0,        false,      1);
    SysFn[110] = new TFn("errormsg",  1, 1,      0,        false,      1);
    SysFn[111] = new TFn("errorcnt",  1, 1,      0,        false,      1);
<# magenta>Function aliasing
<# black>    SysFn[322] = new TFn("setfunc",   2, 4,      0,        false,      1);
    SysFn[323] = new TFn("func1",      1, 1000,   0,        false,      1);
    SysFn[324] = new TFn("func2",      1, 1000,   0,        false,      1);
<# magenta>Program manipulation, Window content manipulation
<# black>    SysFn[146] = new TFn("run",       2, 2,      0,        false,      1);
    SysFn[326] = new TFn("exec",      1, 1000,   0,        false,      1);
    SysFn[147] = new TFn("pgm_copy",  2, 4,      0,        false,      1);
    SysFn[148] = new TFn("pgm_graft", 3, 5,      0,        false,      1);
    SysFn[165] = new TFn("pgm_load",  2, 2,      0,        false,      1);
    SysFn[327] = new TFn("kill_on_exit",1,1,     0,        false,      1);
    SysFn[383] = new TFn("smash",     1, 3,      0,        false,      1);
    SysFn[382] = new TFn("window",    2, 5,      0,        false,      1);
    SysFn[386] = new TFn("window_find",   1, 5,  0,        false,      1);
    SysFn[384] = new TFn("thislineno",      1, 1,      0,        false,      1);
    SysFn[434] = new TFn("findlineno",1, 2,      0,        false,      1);
    SysFn[402] = new TFn("exit_plus",  1,3,       0,        false,      1);
    SysFn[403] = new TFn("insert_image",4,4,     0,        false,      1);
<# magenta>Main menu manipulation
<# black>    SysFn[420] = new TFn("mainmenu",  1, 2,      0,        false,      1);
    SysFn[227] = new TFn("xmenu",     2, 2,      0,        false,      1);

<# red>SCALAR MANIPULATION 
<# black>    SysFn[4]   = new TFn("rotate",    1, MaxREFArgs, MaxREFArgs, false, 1);  || Can be used to swap values between scalars.
    SysFn[424] = new TFn("sequence",  2, MaxREFArgs, MaxREFArgs,false, 1);
    SysFn[198] = new TFn("unpack",    2, MaxREFArgs, MaxREFArgs,false, 1);
    SysFn[443] = new TFn("inject",    1, 3,      0,        false,      1);

<# red>MATHEMATICAL FUNCTIONS
<# magenta>Number manipulations
<# black>    SysFn[21]  = new TFn("round",     1, 2,      0,        false,      2);
    SysFn[351] = new TFn("tozero",    1, 2,      0,        false,      2);
    SysFn[352] = new TFn("fromzero",  1, 2,      0,        false,      2);
    SysFn[22]  = new TFn("frac",      1, 1,      0,        false,      2);
    SysFn[23]  = new TFn("floor",     1, 2,      0,        false,      2);
    SysFn[24]  = new TFn("ceiling",   1, 2,      0,        false,      2);
    SysFn[25]  = new TFn("mod",       2, 2,      0,        false,      2);
    SysFn[26]  = new TFn("div",       2, 2,      0,        false,      2);
    SysFn[27]  = new TFn("isintegral",1, 2,      0,        false,      2);
    SysFn[48]  = new TFn("defrac",    1, 1,      0,        false,      2);
    SysFn[14]  = new TFn("abs",       1, 1,      0,        false,      2);
<# magenta>Tests
<# black>    SysFn[104] = new TFn("isarray",   1, 1,      0,        false,      1);
    SysFn[86]  = new TFn("even",      1, 2,      0,        false,      2);
    SysFn[90]  = new TFn("sign",      1, 5,      0,        false,      1);
    SysFn[404] = new TFn("isnan",     1, 1,      0,        false,      2);
<# magenta>Base changes
<# black>    SysFn[52]  = new TFn("hex",       1, 2,      0,        false,      1);
    SysFn[53]  = new TFn("unhex",     1, 2,      0,        false,      1);
    SysFn[55]  = new TFn("bin",       1, 3,      0,        false,      1);
    SysFn[343] = new TFn("unbin",     1, 2,      0,        false,      1);
<# magenta>Mathematical functions A (non-trigonometrical)
<# black>    SysFn[14]  = new TFn("abs",       1, 1,      0,        false,      2);
    SysFn[2]   = new TFn("inc",       1, 1,      1,        true,       1);
    SysFn[3]   = new TFn("dec",       1, 1,      1,        true,       1);
    SysFn[5]   = new TFn("sqr",       1, 1,      0,        false,      2);
    SysFn[15]  = new TFn("sqrt",      1, 1,      0,        false,      2);
    SysFn[16]  = new TFn("fact",      1, 2,      0,        false,      2);
    SysFn[17]  = new TFn("logfact",   1, 2,      0,        false,      2);
    SysFn[18]  = new TFn("exp",       1, 1,      0,        false,      2);
    SysFn[19]  = new TFn("ln",        1, 1,      0,        false,      2);
    SysFn[20]  = new TFn("log",       1, 2,      0,        false,      2);
    SysFn[93]  = new TFn("gauss",     5, 5,      0,        false,      1);
    SysFn[100] = new TFn("moments",   1, 2,      0,        false,      1);
    SysFn[102] = new TFn("sum",       1, 3,      0,        false,      1);
    SysFn[105] = new TFn("norm",      1, 1,      0,        false,      1);
    SysFn[113] = new TFn("fourier",   1, 2,      0,        false,      1);
    SysFn[197] = new TFn("primes",    2, 4,      0,        false,      1);
    SysFn[294] = new TFn("factors",   1, 1000,   0,        false,      1);
    SysFn[199] = new TFn("binom",     2, 3,      0,        false,      1);
    SysFn[200] = new TFn("logbinom",  2, 3,      0,        false,      1);
    SysFn[325] = new TFn("bitop",     2, 1000,   0,        false,      1);
    SysFn[344] = new TFn("bestsquare",1, 1,      0,        false,      1);
    SysFn[68]  = new TFn("max",       1, 1000,   0,        false,      1);
    SysFn[353] = new TFn("min",       1, 1000,   0,        false,      1);
    SysFn[357] = new TFn("and",       2, 3,      0,        false,      1);
    SysFn[358] = new TFn("or",        2, 3,      0,        false,      1);
    SysFn[359] = new TFn("xor",       2, 3,      0,        false,      1);
    SysFn[360] = new TFn("xorcomp",   2, 3,      0,        false,      1);
    SysFn[423] = new TFn("sigmoid",   4, 4,      0,        false,      1);
<# magenta>Mathematical functions B (trigonometrical)
<# black>    SysFn[6]   = new TFn("deg",       1, 1,      0,        false,      2);
    SysFn[7]   = new TFn("rad",       1, 1,      0,        false,      2);
    SysFn[406] = new TFn("fixangle",  1, 2,      0,        false,      2);
    SysFn[8]   = new TFn("sin",       1, 1,      0,        false,      2);
    SysFn[9]   = new TFn("cos",       1, 1,      0,        false,      2);
    SysFn[10]  = new TFn("tan",       1, 1,      0,        false,      2);
    SysFn[11]  = new TFn("arcsin",    1, 2,      0,        false,      2);
    SysFn[12]  = new TFn("arccos",    1, 2,      0,        false,      2);
    SysFn[13]  = new TFn("arctan",    1, 2,      0,        false,      1);
<# magenta>Random nos.
<# black>    SysFn[28]  = new TFn("rand",      1, 3,      1,        false,      1);
    SysFn[29]  = new TFn("seed",      1, 1,      0,        false,      1);
    SysFn[47]  = new TFn("randum",    1, 1,      0,        false,      1);
    SysFn[94]  = new TFn("randgauss", 2, 5,      1,        false,      1);
    SysFn[256] = new TFn("perturb",   3, 3,      0,        false,      1);
    SysFn[103] = new TFn("shuffle",   1, 2,      0,        false,      1);
    SysFn[132] = new TFn("randsign",  1, 1,      0,        false,      1);
    SysFn[405] = new TFn("randrange", 3, 4,      1,        true,       1);
<# magenta>Complex nos. (see also 'polynomials')
<# black>    SysFn[113] = new TFn("fourier",   1, 2,      0,        false,      1);
    SysFn[114] = new TFn("rect",      1, 2,      0,        false,      1);
    SysFn[115] = new TFn("polar",     1, 2,      0,        false,      1);
    SysFn[116] = new TFn("complex",   4, 5,      0,        false,      1);
    SysFn[117] = new TFn("merge",     2, 1000,   0,        false,      1);
    SysFn[140] = new TFn("unmerge",   3, MaxREFArgs, MaxREFArgs,true,  1);

<# red>POLYNOMIALS
<# black>    SysFn[39]  = new TFn("polystring",1, 4,      0,        false,      1);
    SysFn[80]  = new TFn("solvesim",  2, 2,      0,        false,      1);
    SysFn[79]  = new TFn("evalpoly",  2, 2,      0,        false,      1);
    SysFn[82]  = new TFn("solvepoly", 1, 3,      0,        false,      1);
    SysFn[83]  = new TFn("rootstopoly",1, 1,     0,        false,      1);
    SysFn[87]  = new TFn("diffpoly",  1, 1,      0,        false,      1);
    SysFn[96]  = new TFn("curvefit",  3, 3,      0,        false,      1);

<# red>STRING-HANDLING (as their principal intent)
<# black>    SysFn[164] = new TFn("asc",       1, 1,      0,        false,      1);
    SysFn[278]  = new TFn("valuetostring",      1, 2,      0,        false,      1);
    SysFn[277]  = "str" -- ALIAS OF above function "valuetostring"
    SysFn[339] = new TFn("unicode",   1, 1000,   0,        false,      1);
    SysFn[60]  = new TFn("copy",      2, 3,      0,        false,      1);
    SysFn[61]  = new TFn("copyto",    3, 3,      0,        false,      1);
    SysFn[89]  = new TFn("between",   3, 3,      0,        false,      1);
    SysFn[135] = new TFn("chain",     2, 2,      0,        false,      1);
    SysFn[139] = new TFn("cull",      2, 3,      0,        false,      1);
    SysFn[141] = new TFn("span",      3, 5,      0,        false,      1);
    SysFn[432] = new TFn("getsegmt",  3, 3,      0,        false,      1);
    SysFn[433] = new TFn("findsegmt", 3, 6,      0,        false,      1);
    SysFn[149] = new TFn("replace",   4, 4,      0,        false,      1);
    SysFn[150] = new TFn("replaceto", 4, 4,      0,        false,      1);
    SysFn[151] = new TFn("insert",    3, 3,      0,        false,      1);
    SysFn[152] = new TFn("delete",    2, 3,      0,        false,      1);
    SysFn[153] = new TFn("deleteto",  3, 3,      0,        false,      1);
    SysFn[158] = new TFn("expunge",   2, 4,      0,        false,      1);
    SysFn[202] = new TFn("substitute",3, 4,      0,        false,      1);
    SysFn[438] = new TFn("equal",     3, 3,      0,        false,      1);
    SysFn[276] = new TFn("compare",   2, 5,      0,        false,      1);
    SysFn[267] = new TFn("compareto", 5, 5,      0,        false,      1);
    SysFn[371] = new TFn("split",     2, 7,      0,        false,      1);
    SysFn[300] = new TFn("join",      3, 4,      0,        false,      1);
    SysFn[307] = new TFn("unjag",     2, 3,      0,        false,      1);
    SysFn[308] = new TFn("jag",       4, 6,      0,        false,      1);
    SysFn[315] = new TFn("lop",       2, 3,      0,        false,      1);
    SysFn[316] = new TFn("pad",       3, 4,      0,        false,      1);
    SysFn[317] = new TFn("truncate",     2, 2,      0,        false,      1);
    SysFn[375] = new TFn("fixedsize", 3, 6,      0,        false,      1);
    SysFn[388] = new TFn("plu",       2, 3,      0,        false,      1);
    SysFn[400] = new TFn("lettercase",2,2,       0,        false,      1);
    SysFn[401] = new TFn("bracketlevel",4,4,     0,        false,      1);

<# red>ARRAY BUILDING / FORMATTING / DESTRUCTION / ACCESS / TESTS
<# black>    SysFn[1]   = new TFn("dim",       2, MaxREFArgs, MaxREFArgs, false, 1);
    SysFn[348] = new TFn("dimlike",   2, MaxREFArgs, MaxREFArgs, false, 1);
    SysFn[380] = new TFn("structure", 1, MaxArrayDims, 0,  false,      1);
    SysFn[54]  = new TFn("ladder",    3, 4,      1,        false,      1);
    SysFn[30]  = new TFn("data",      1, 1000,   0,        false,      1);
    SysFn[35]  = new TFn("redim",     2, 1000,   0,        false,      1);
    SysFn[36]  = new TFn("redimlike", 2, 1000,   0,        false,      1);
    SysFn[37]  = new TFn("fill",      2, 1000,   1,        false,      1);
    SysFn[51]  = new TFn("write",     1, MaxREFArgs, MaxREFArgs, false, 1);
    SysFn[57]  = new TFn("size",      1, 2,      0,        false,      1);
    SysFn[58]  = new TFn("dims",      1, 2,      0,        false,      1);
    SysFn[81]  = new TFn("determinant",       1, 2,      0,        false,      1);
    SysFn[84]  = new TFn("undim",     1, MaxREFArgs, MaxREFArgs, true, 1);
    SysFn[107] = new TFn("text",      1, MaxREFArgs, MaxREFArgs,false, 1);
    SysFn[198] = new TFn("unpack",    2, MaxREFArgs, MaxREFArgs,false, 1);
    SysFn[278]  = new TFn("valuetostring",      1, 2,      0,        false,      1);
    SysFn[277]  = "str" -- ALIAS OF above function "valuetostring"
    SysFn[412] = new TFn("prevalence",2, 3,      0,        false,      1);
<# magenta>Access
<# black>    SysFn[283] = new TFn("offset",     2, 2,      0,        false,      1);
    SysFn[284] = new TFn("indexed",   2, 3,      0,        false,      1);
SysFn[108] = new TFn("last",      1, 2,      0,        false,      1);
<# magenta>Tests
<# black>    SysFn[104] = new TFn("isarray",   1, 1,      0,        false,      1);
    SysFn[215] = new TFn("empty",     1, 1,      0,        false,      1);
    SysFn[404] = new TFn("isnan",     1, 1,      0,        false,      2);
    SysFn[431] = new TFn("count",     2, 4,      0,        false,      1);
    SysFn[448] = new TFn("monotonicity", 2, 4,      0,        false,      1);
    SysFn[293] = new TFn("showarray", 1, 1,      1,        false,      1);

<# red>WHOLE-ARRAY MATHEMATICAL OPERATIONS including polynomials, equation solving
<# black>    SysFn[66]  = new TFn("dot",       2, 2,      0,        false,      1);
    SysFn[193] = new TFn("distance",  2, 4,      0,        false,      1);
    SysFn[407] = new TFn("distmutual",1, 5,      0,        false,      1);
    SysFn[408] = new TFn("distpoints", 2, 7,      0,        false,      1);
    SysFn[195] = new TFn("hypot",     2, 3,      0,        false,      1);
<# magenta>Polynomials and equation solving
<# black>    SysFn[80]  = new TFn("solvesim",  2, 2,      0,        false,      1);
    SysFn[79]  = new TFn("evalpoly",  2, 2,      0,        false,      1);
    SysFn[82]  = new TFn("solvepoly", 1, 3,      0,        false,      1);
    SysFn[83]  = new TFn("rootstopoly",1, 1,     0,        false,      1);
    SysFn[87]  = new TFn("diffpoly",  1, 1,      0,        false,      1);
   SysFn[422] = new TFn("solveexp",  1, 2,      0,        false,      1);
<# magenta>Calculus
<# black>    SysFn[91]  = new TFn("integral",  3, 3,      0,        false,      1);
    SysFn[92]  = new TFn("intcurve",  3, 4,      0,        false,      1);
    SysFn[87]  = new TFn("diffpoly",  1, 1,      0,        false,      1);
    SysFn[306] = new TFn("solve_de",  3, 4,      0,        false,      1);

<# red>ARRAY MANIPULATIONS
<# black>    SysFn[60]  = new TFn("copy",      2, 3,      0,        false,      1);
    SysFn[61]  = new TFn("copyto",    3, 3,      0,        false,      1);
    SysFn[89]  = new TFn("between",   3, 3,      0,        false,      1);
    SysFn[432] = new TFn("getsegmt",  3, 3,      0,        false,      1);
    SysFn[433] = new TFn("findsegmt", 3, 6,      0,        false,      1);
    SysFn[4]   = new TFn("rotate",    1, MaxREFArgs, MaxREFArgs, false, 1);
    SysFn[64]  = new TFn("reverse",   1, 1,      1,        true,       1);
    SysFn[72]  = new TFn("sort",      1, 4,      0,        false,      1);
    SysFn[73]  = new TFn("sortbykey", 2, 1000,      0,        false,      1);
    SysFn[77]  = new TFn("clip",      3, 3,      0,        false,      1);
    SysFn[78]  = new TFn("clipabs",   3, 3,      0,        false,      1);
    SysFn[287] = new TFn("cap",       3, 3,      0,        false,      1);
    SysFn[85]  = new TFn("interpolate",2,4,      0,        false,      1);
    SysFn[97]  = new TFn("upsample",  3, 6,      0,        false,      1);
    SysFn[98]  = new TFn("downsample",2, 4,      0,        false,      1);
    SysFn[99]  = new TFn("odometer",  2, 3,      1,        true,       1);
    SysFn[310] = new TFn("progressive",2,2,      0,        false,      1);
    SysFn[309] = new TFn("differences",1,1,      0,        false,      1);
    SysFn[103] = new TFn("shuffle",   1, 2,      0,        false,      1);
    SysFn[121] = new TFn("reorder",   2, 1000,   0,        false,      1);
    SysFn[135] = new TFn("chain",     2, 2,      0,        false,      1);
    SysFn[138] = new TFn("jagger",    3, 6,      1,        true,       1);
    SysFn[139] = new TFn("cull",      2, 3,      0,        false,      1);
    SysFn[117] = new TFn("merge",     2, 1000,   0,        false,      1);
    SysFn[140] = new TFn("unmerge",   3, MaxREFArgs, MaxREFArgs,true,  1);
    SysFn[141] = new TFn("span",      3, 5,      0,        false,      1);
    SysFn[149] = new TFn("replace",   4, 4,      0,        false,      1);
    SysFn[150] = new TFn("replaceto", 4, 4,      0,        false,      1);
    SysFn[151] = new TFn("insert",    3, 3,      0,        false,      1);
    SysFn[152] = new TFn("delete",    2, 3,      0,        false,      1);
    SysFn[153] = new TFn("deleteto",  3, 3,      0,        false,      1);
    SysFn[158] = new TFn("expunge",   2, 4,      0,        false,      1);
    SysFn[436] = new TFn("defluff",   2, 2,      1,        true,       1);
    SysFn[186] = new TFn("push",      3, 4,      1,        true,       1);
    SysFn[187] = new TFn("pop",       2, 3,      1,        true,       1);
    SysFn[188] = new TFn("reversed",  1, 1000,   1,        false,      1);
    SysFn[201] = new TFn("select",    2, 4,      0,        false,      1);
    SysFn[202] = new TFn("substitute",2, 4,      0,        false,      1);
    SysFn[203] = new TFn("removedups",1, 3,      0,        false,      1);
    SysFn[441] = new TFn("removeruns",1, 2,      0,        false,      1);
    SysFn[210] = new TFn("poke",      3, 3,      0,        false,      1);
    SysFn[214] = new TFn("cullbykey", 2, 2,      0,        false,      1);
    SysFn[438] = new TFn("equal",     3, 3,      0,        false,      1);
    SysFn[276] = new TFn("compare",   2, 5,      0,        false,      1);
    SysFn[267] = new TFn("compareto", 5, 5,      0,        false,      1);
    SysFn[295] = new TFn("peck",      2, 3,      1,        true,       1);
    SysFn[298] = new TFn("product",   1, 2,      0,        false,      1);
    SysFn[303] = new TFn("evict",     2, 2,      0,        false,      1);
    SysFn[307] = new TFn("unjag",     2, 3,      0,        false,      1);
    SysFn[308] = new TFn("jag",       4, 6,      0,        false,      1);
    SysFn[315] = new TFn("lop",       2, 3,      0,        false,      1);
    SysFn[316] = new TFn("pad",       3, 4,      0,        false,      1);
    SysFn[317] = new TFn("truncate",     2, 2,      0,        false,      1);
    SysFn[319] = new TFn("intersection",2,1000,  0,        false,      1);
    SysFn[340] = new TFn("overlay",   3, 5,      0,        false,      1);
    SysFn[371] = new TFn("split",     2, 7,      0,        false,      1);
    SysFn[300] = new TFn("join",      3, 4,      0,        false,      1);
    SysFn[372] = new TFn("clipcull",  3, 4,      0,        false,      1);
    SysFn[373] = new TFn("clipcullabs",3,4,      0,        false,      1);
    SysFn[357] = new TFn("and",       2, 3,      0,        false,      1);
    SysFn[358] = new TFn("or",        2, 3,      0,        false,      1);
    SysFn[359] = new TFn("xor",       2, 3,      0,        false,      1);
    SysFn[360] = new TFn("xorcomp",   2, 3,      0,        false,      1);
    SysFn[375] = new TFn("fixedsize", 3, 6,      0,        false,      1);
    SysFn[414] = new TFn("filter",    4, 5,      1,        false,      1);
    SysFn[446] = new TFn("firfilter", 2, 5,      0,        false,      1);
    SysFn[440] = new TFn("train",     1, 5,      0,        false,      1);

<# red>MATRIX-SPECIFIC OPERATIONS
<# black>    SysFn[65]  = new TFn("transpose", 1, 1,      0,        false,      1);
    SysFn[67]   = new TFn("mxmult",    2, 3,      0,        false,      1);
    SysFn[130] = new TFn("rowop",     5, 9,      0,        false,      1);
    SysFn[131] = new TFn("colop",     5, 9,      0,        false,      1);
    SysFn[81]   = new TFn("determinant",       1, 2,      0,        false,      1);
    SysFn[106] = new TFn("inverse",   1, 2,      0,        false,      1);
    SysFn[162] = new TFn("shufflemx", 2, 3,      0,        false,      1);
    SysFn[206] = new TFn("selectrows",2,2,       0,        false,      1);
    SysFn[207] = new TFn("selectcols",2,2,       0,        false,      1);
    SysFn[211] = new TFn("pokerows",  3, 3,      0,        false,      1);
    SysFn[212] = new TFn("pokecols",  3, 3,      0,        false,      1);
    SysFn[216] = new TFn("appendrows",2, 3,      0,        false,      1);
    SysFn[217] = new TFn("appendcols",2, 3,      0,        false,      1);
    SysFn[218] = new TFn("insertrows",3, 4,      0,        false,      1);
    SysFn[219] = new TFn("insertcols",3, 4,      0,        false,      1);
    SysFn[223] = new TFn("sumrows",   1, 3,      0,        false,      1);
    SysFn[224] = new TFn("sumcols",   1, 3,      0,        false,      1);
    SysFn[225] = new TFn("deleterows",2, 3,      0,        false,      1);
    SysFn[226] = new TFn("deletecols",2, 3,      0,        false,      1);
    SysFn[259] = new TFn("replacerows",3,4,      0,        false,      1);
    SysFn[260] = new TFn("replacecols",3,4,      0,        false,      1);
    SysFn[261] = new TFn("chainrows", 2, 2,      0,        false,      1);
    SysFn[262] = new TFn("chaincols", 2, 2,      0,        false,      1);
    SysFn[263] = new TFn("copyrows",  2, 3,      0,        false,      1);
    SysFn[264] = new TFn("copycols",  2, 3,      0,        false,      1);
    SysFn[265] = new TFn("copyrowsto",3, 3,      0,        false,      1);
    SysFn[266] = new TFn("copycolsto",2, 3,      0,        false,      1);
    SysFn[273] = new TFn("mxdiag",    1, 3,      0,        false,      1);
    SysFn[274] = new TFn("__UNUSED",   2, 5,      0,        false,      1);
    SysFn[275] = new TFn("__UNUSED",   2, 5,      0,        false,      1);
    SysFn[282] = new TFn("mxhalf",    4, 5,      0,        false,      1);
    SysFn[286] = new TFn("findinmx",  3, 5,      0,        false,      1);
    SysFn[296] = new TFn("prodrows",  1, 4,      0,        false,      1);
    SysFn[297] = new TFn("prodcols",  1, 4,      0,        false,      1);
    SysFn[311] = new TFn("rowvec",    1, 1000,   0,        false,      1);
    SysFn[312] = new TFn("colvec",    1, 1000,   0,        false,      1);
    SysFn[313] = new TFn("matrix",    2, 1000,   0,        false,      1);
    SysFn[314] = new TFn("matrixop",  3, 3,      0,        false,      1);
    SysFn[345] = new TFn("charpoly",  1, 2,      0,        false,      1);
    SysFn[346] = new TFn("submatrix", 3, 3,      0,        false,      1);
    SysFn[347] = new TFn("cofactor",  3, 4,      0,        false,      1);
    SysFn[349] = new TFn("copymx",    3, 5,      0,        false,      1);
    SysFn[350] = new TFn("copymxto",  5, 5,      0,        false,      1);
    SysFn[416] = new TFn("cluster",   3, 3,      0,        false,      1);
    SysFn[417] = new TFn("mxcentre",    2, 3,      0,        false,      1);
    SysFn[4]   = new TFn("rotate",    1, MaxREFArgs, MaxREFArgs, false, 1);   <# magenta>// one version of it is matrix-specific<# black>
    SysFn[427] = new TFn("rotaterow", 2, 4,      0,        false,      1);
    SysFn[428] = new TFn("rotatecol", 2, 4,      0,        false,      1);

<# red>SEARCH and REFERENCE
<# black>    SysFn[204] = new TFn("find",      3, 4,      0,        false,      1);
    SysFn[205] = new TFn("finds",     3, 4,      0,        false,      1);
    SysFn[63]  = new TFn("findall",   3, 4,      0,        false,      1);
    SysFn[435] = new TFn("findany", 3, 4,      0,        false,      1);
    SysFn[442] = new TFn("seekno",    1, 5,      0,        false,      1);
    SysFn[68]  = new TFn("max",       1, 1000,   0,        false,      1);
    SysFn[69]  = new TFn("maxat",     1, 1000,   0,        false,      1);
    SysFn[70]  = new TFn("maxabs",    1, 1000,   0,        false,      1);
    SysFn[71]  = new TFn("maxabsat",  1, 1000,   0,        false,      1);
    SysFn[353] = new TFn("min",       1, 1000,   0,        false,      1);
    SysFn[354] = new TFn("minat",     1, 1000,   0,        false,      1);
    SysFn[355] = new TFn("minabs",    1, 1000,   0,        false,      1);
    SysFn[356] = new TFn("minabsat",  1, 1000,   0,        false,      1);
    SysFn[183] = new TFn("placement", 2, 3,      0,        false,      1);
    SysFn[119] = new TFn("place",     2, 3,      0,        false,      1);
    SysFn[120] = new TFn("places",    2, 3,      0,        false,      1);
    SysFn[122] = new TFn("matches",   2, 3,      0,        false,      1);
    SysFn[123] = new TFn("mismatches",2, 3,      0,        false,      1);
    SysFn[124] = new TFn("nozero",    1, 2,      0,        false,      1);
    SysFn[125] = new TFn("allzero",   1, 2,      0,        false,      1);
    SysFn[126] = new TFn("is",        1, 2,      0,        false,      1);
    SysFn[127] = new TFn("not",       1, 2,      0,        false,      1);
    SysFn[201] = new TFn("select",    2, 4,      0,        false,      1);
    SysFn[202] = new TFn("substitute",2, 4,      0,        false,      1);
    SysFn[438] = new TFn("equal",     3, 3,      0,        false,      1);
    SysFn[276] = new TFn("compare",   2, 5,      0,        false,      1);
    SysFn[267] = new TFn("compareto", 5, 5,      0,        false,      1);
    SysFn[303] = new TFn("evict",     2, 2,      0,        false,      1);
    SysFn[128] = new TFn("bkmkcopy",  4, 4,      0,        false,      1);
    SysFn[129] = new TFn("bkmkreplace",5,6,      0,        false,      1);
    SysFn[318] = new TFn("readtable", 3, 5,      0,        false,      1);
    SysFn[361] = new TFn("correlation",4, 7,     0,        false,      1);
    SysFn[362] = new TFn("convolution",3, 3,     0,        false,      1);
    SysFn[363] = new TFn("fft",       1, 2,      0,        false,      1);
    SysFn[385] = new TFn("findbrackets",4,4,     0,        false,      1);

<# red>SYSTEM LISTS
<# black>    SysFn[112] = new TFn("list_to",   3, 3,      0,        false,      1);
    SysFn[154] = new TFn("list",      1, 3,      0,        false,      1);
    SysFn[155] = new TFn("lists",     3, 4,      0,        false,      1);
    SysFn[156] = new TFn("lists_to",  3, 4,      0,        false,      1);
    SysFn[166] = new TFn("list_new",  1, 1,      0,        false,      1);
    SysFn[167] = new TFn("lists_new", 1, 1,      0,        false,      1);
    SysFn[168] = new TFn("list_clear",1, 1000,   0,        false,      1);
    SysFn[169] = new TFn("lists_clear",2,2,      0,        false,      1);
    SysFn[170] = new TFn("lists_clear_to",2,2,   0,        false,      1);
    SysFn[171] = new TFn("lists_kill",1,1,       0,        false,      1);
    SysFn[172] = new TFn("lists_preserve",1,1,  0,        false,      1);
    SysFn[173] = new TFn("list_add",  2, 1000,   0,        false,      1);
    SysFn[174] = new TFn("lists_count",1,1,      0,        false,      1);
    SysFn[175] = new TFn("list_size", 1,1,       0,        false,      1);
    SysFn[176] = new TFn("list_read", 1, 3,      0,        false,      1);
    SysFn[177] = new TFn("list_read_to",3,3,     0,        false,      1);
    SysFn[178] = new TFn("list_alter",3,3,       0,        false,      1);
    SysFn[179] = new TFn("lists_read",3,4,       0,        false,      1);
    SysFn[180] = new TFn("lists_read_to",3,4,    0,        false,      1);
    SysFn[181] = new TFn("list_push", 2, 2,      0,        false,      1);
    SysFn[182] = new TFn("list_pop",  2, 2,      2,        false,      1);
    SysFn[190] = new TFn("list_delete",2,3,      0,        false,      1);
    SysFn[191] = new TFn("list_delete_to",3,3,   0,        false,      1);
    SysFn[192] = new TFn("list_insert",3, 1000,  0,        false,      1);
    SysFn[279] = new TFn("list_cull", 2, 1000,   0,        false,      1);
    SysFn[280] = new TFn("list_cull_range",3,3,  0,        false,      1);
    SysFn[281] = new TFn("list_find", 2, 3,      0,        false,      1);
    SysFn[288] = new TFn("list_opn",  4, 5,      0,        false,      1);

<# red>DISPLAY / INPUT / OUTPUT<# black>
    SysFn[34]  = new TFn("label",      1, MaxREFArgs, MaxREFArgs,false, 1);
    SysFn[49]  = new TFn("chars",     1, 1000,      0,        false,      1);
    SysFn[50]  = new TFn("unchars",   1, 1000,      0,        false,      1);
    SysFn[56]  = new TFn("writeln",   1, MaxREFArgs, MaxREFArgs, false, 1);
    SysFn[430] = new TFn("setbox",    1, 4,      0,        false,      1);
    SysFn[31]  = new TFn("show",      1, MaxREFArgs, MaxREFArgs,false, 1);
    SysFn[76]  = new TFn("request",   6, 1000,   1,        false,      1);
    SysFn[145] = new TFn("decide",    3, 10,     0,        false,      1);
    SysFn[429] = new TFn("multibox",  4, 5,      4,        true,       1);
    SysFn[293] = new TFn("showarray", 1, 1,      1,        false,      1);
    SysFn[164] = new TFn("asc",       1, 1,      0,        false,      1);
    SysFn[278]  = new TFn("valuetostring",      1, 2,      0,        false,      1);   "str" is an alias of this function.
    SysFn[277]  = "str" -- ALIAS OF above function "valuetostring"
    SysFn[377] = new TFn("stringtovalue",  1, 2,      0,        false,      1);    "val" (376) is an alias of this function.
    SysFn[339] = new TFn("unicode",   1, 1000,   0,        false,      1);
    SysFn[375] = new TFn("fixedsize", 3, 6,      0,        false,      1);
    SysFn[389] = new TFn("clipboard", 1, 2,      0,        false,      1);
    SysFn[419] = new TFn("cursorposn",1, 2,      0,        false,      1);
    SysFn[398] = new TFn("cursordata",1,1,       0,        false,      1);
    SysFn[399] = new TFn("persistent_array",1,1, 0,        false,      1);
    SysFn[293] = new TFn("showarray", 1, 1,      1,        false,      1);
<# magenta>Menus, key presses
<# black>    SysFn[420] = new TFn("mainmenu",  1, 2,      0,        false,      1);
    SysFn[227] = new TFn("xmenu",     2, 2,      0,        false,      1);
    SysFn[228] = new TFn("xvisible",  1, 1000,   0,        false,      1);
    SysFn[229] = new TFn("xclick",    1, 1,      0,        false,      1);
    SysFn[285] = new TFn("keyed",     1, 2,      1,        false,      1);
    SysFn[342] = new TFn("keydown",   1, 1,      0,        false,      1);
    SysFn[421] = new TFn("keyname",   1, 2,      0,        false,      1);
    SysFn[397]  = new TFn("btnrelease",1,1,      0,        false,      1);
<# magenta>Disk I/O
<# black>    SysFn[88]  = new TFn("load",      1, 3,      0,        false,      1);
    SysFn[46]  = new TFn("save",      4, 6,      2,        false,      1);
    SysFn[159] = new TFn("iok",       1, 1,      0,        false,      1);
    SysFn[160] = new TFn("iomessage", 1, 1,      0,        false,      1);
    SysFn[161] = new TFn("iofile",    1, 1,      0,        false,      1);
    SysFn[364] = new TFn("homedirectory", 1,1,   0,        false,      1);
    SysFn[365] = new TFn("playsound", 1, 2,      0,        false,      1);
    SysFn[367] = new TFn("choosefilename",1,2,   0,        false,      1);
    SysFn[368] = new TFn("currentdirectory",1,1, 0,        false,      1);
    SysFn[369] = new TFn("checkdirectory",1,2,   0,        false,      1);
    SysFn[370] = new TFn("filesize",  1, 1,      0,        false,      1);
    SysFn[305] = new TFn("programfile",1,1,      0,        false,      1);
    SysFn[396]  = new TFn("blockfile",1, 3,      0,        false,      1);

<# magenta>Formatting
<# black>    SysFn[59]  = new TFn("neat",      1, 3,      0,        false,      1);
    SysFn[39]  = new TFn("polystring",1, 4,      0,        false,      1);
    SysFn[62]  = new TFn("boolstr",   1, 1000,   0,        false,      1);
    SysFn[374] = new TFn("nth",       1, 3,      0,        false,      1);

<# red>GRAPHING
<# magenta>Graph itself
<# black>    SysFn[395]  = new TFn("palette",   1, 2,      0,        false,      1);
    SysFn[40]  = new TFn("gridx",     2, 4,      0,        false,      1);
    SysFn[41]  = new TFn("gridy",     2, 4,      0,        false,      1);
    SysFn[42]  = new TFn("gridz",     2, 4,      0,        false,      1);
    SysFn[43]  = new TFn("killplot",  1, 1000,   0,        false,      1);
    SysFn[44]  = new TFn("killgraphs", 2, 2,      0,        false,      1);
    SysFn[45]  = new TFn("addplot",   2, 1000,   0,        false,      1);
    SysFn[74]  = new TFn("grid",      2, 10,     0,        false,      1);
    SysFn[75]  = new TFn("removeplot",2, 1000,   0,        false,      1);
    SysFn[95]  = new TFn("graphcopy", 1, 2,      0,        false,      1);
    SysFn[118] = new TFn("graphresize",2,3,      0,        false,      1);
    SysFn[136] = new TFn("placeboard",2, 5,      0,        false,      1);
    SysFn[137] = new TFn("lastclosed",1, 1,      0,        false,      1);
    SysFn[142] = new TFn("readgrid",  1, 1,      0,        false,      1);
    SysFn[194] = new TFn("pixels",    1, 1,      0,        false,      1);
    SysFn[213] = new TFn("boardresize",3,3,      0,        false,      1);
    SysFn[220] = new TFn("plotshape", 7, 12,     0,        false,      1);
    SysFn[221] = new TFn("copyshape", 2, 6,      0,        false,      1);
    SysFn[230] = new TFn("plot",      2, 12,     0,        false,      1);
    SysFn[231] = new TFn("plot3d",    3, 13,     0,        false,      1);
    SysFn[232] = new TFn("graph",     1, 1000,   0,        false,      1);
    SysFn[233] = new TFn("graph3d",   1, 1000,   0,        false,      1);
    SysFn[447] = new TFn("graphtitle",2, 2,      0,        false,      1);
    SysFn[234] = new TFn("header",    1, MaxREFArgs, MaxREFArgs,false, 1);
    SysFn[235] = new TFn("footer",    1, MaxREFArgs, MaxREFArgs,false, 1);
    SysFn[236] = new TFn("labelx",    1, MaxREFArgs, MaxREFArgs,false, 1);
    SysFn[237] = new TFn("labely",    1, MaxREFArgs, MaxREFArgs,false, 1);
    SysFn[238] = new TFn("labelz",    1, MaxREFArgs, MaxREFArgs,false, 1);
    SysFn[239] = new TFn("plotsof",   1, 1,      0,        false,      1);
    SysFn[240] = new TFn("scaleoverx",2, 2,      0,        false,      1);
    SysFn[241] = new TFn("scaleovery",2, 2,      0,        false,      1);
    SysFn[242] = new TFn("scaleoverz",2, 2,      0,        false,      1);
    SysFn[243] = new TFn("scalefudgex",3, 5,     0,        false,      1);
    SysFn[244] = new TFn("scalefudgey",3, 5,     0,        false,      1);
    SysFn[245] = new TFn("moveshape", 3, 7,      0,        false,      1);
    SysFn[246] = new TFn("scaleformatx",1, 2,    0,        false,      1);
    SysFn[247] = new TFn("scaleformaty",1, 2,    0,        false,      1);
    SysFn[248] = new TFn("scaleformatz",1, 2,    0,        false,      1);
    SysFn[249] = new TFn("scaleformat",1, 2,     0,        false,      1);
    SysFn[250] = new TFn("showhairlines",2, 4,   0,        false,      1);
    SysFn[251] = new TFn("scalefit",  1, 4,      0,        false,      1);
    SysFn[252] = new TFn("plotmesh",  2, 14,     0,        false,      1);
    SysFn[253] = new TFn("plotmesh3d",3, 15,     0,        false,      1);
    SysFn[272] = new TFn("paintshape",3, 6,      0,        false,      1);
    SysFn[291] = new TFn("scalejumpx",3, 3,      0,        false,      1);
    SysFn[292] = new TFn("scalejumpy",3, 3,      0,        false,      1);
    SysFn[301] = new TFn("graphkey",  1, 1,      0,        false,      1);
    SysFn[302] = new TFn("graphcolours",1, 7,    0,        false,      1);
    SysFn[381] = new TFn("boardplacemt",1, 1,    0,        false,      1);
    SysFn[366] = new TFn("aspect",    1, 3,      0,        false,      1);
    SysFn[415] = new TFn("pointsof",  2, 3,      0,        false,      1);
    SysFn[418] = new TFn("graphvisible",1,2,     0,        false,      1);
<# magenta>Colour manipulation functions
<# black>    SysFn[299] = new TFn("rgb",       1, 2,      0,        false,      1);
    SysFn[289] = new TFn("hsl",       1, 2,      0,        false,      1);
    SysFn[290] = new TFn("hsl_to_rgb",1, 3,      0,        false,      1);
    SysFn[378] = new TFn("chooseclr", 2, 2,      0,        false,      1);
    SysFn[379] = new TFn("ladderclr", 3, 6,      0,        false,      1);
<# magenta>Menus, key presses, mouse clicks
<# black>    SysFn[144] = new TFn("gfixedclick",1,1,      0,        false,      1);
    SysFn[189] = new TFn("newclick",  1, 1,      1,        false,      1);
    SysFn[268] = new TFn("mouse",     1, 2,      0,        false,      1);
    SysFn[269] = new TFn("gxmenu",    3, 3,      0,        false,      1);
    SysFn[270] = new TFn("gxvisible", 1,1000,    0,        false,      1);
    SysFn[271] = new TFn("gxclick",   1, 1,      0,        false,      1);
    SysFn[304] = new TFn("gfixedvisible",3,3,    0,        false,      1);
    SysFn[285] = new TFn("keyed",     1, 2,      1,        false,      1);
    SysFn[342] = new TFn("keydown",   1, 1,      0,        false,      1);  || Not just for graphs - any key during run of program.
    SysFn[421] = new TFn("keyname",   1, 2,      0,        false,      1);
<# magenta>Computing for plotting
<# black>    SysFn[96]  = new TFn("curvefit",  3, 3,      0,        false,      1);
    SysFn[196] = new TFn("vecdirns",  3, 3,      0,        false,      1);
    SysFn[101] = new TFn("setbins",   1, 5,      0,        false,      1);
    SysFn[222] = new TFn("plotbins",  1, 8,      0,        false,      1);
    SysFn[257] = new TFn("mesh",     2, 3,      0,        false,      1);
    SysFn[341] = new TFn("swing",     2, 6,      0,        false,      1);
<# magenta>Tests
<# black>    SysFn[184] = new TFn("isplot",    1, 1000,   0,        false,      1);
    SysFn[185] = new TFn("isgraph",   1, 1000,   0,        false,      1);

-=====================-

<# red>INTERNALLY ACCESSED ONLY
<# grey>    SysFn[32]  = new TFn(C.ArrayFnRHS,2, MaxArrayDims+1, 0,   false, 1);   || Currently named "__segmt()"
    SysFn[33]  = new TFn(C.ArrayFnLHS,3, MaxArrayDims+2, 1,   true,  1);   || Currently named "__assign()"
    SysFn[254] = new TFn("__array",   1, MaxREFArgs, MaxREFArgs,false, 1);
    SysFn[258] = new TFn("__scalar",  1, MaxREFArgs,MaxREFArgs, false, 1);
    SysFn[320] = new TFn("__importscalar", 1, MaxREFArgs, MaxREFArgs, false, 1);
    SysFn[321] = new TFn("__importarray",  1, MaxREFArgs, MaxREFArgs, false, 1);
    SysFn[38]  = new TFn("__quote",   1, 1,      0,        false,      1);
    SysFn[413] = new TFn("__constant",2, 2,      1,        false,      1);

<# red>NOT YET INSTANTIATED  (tables not yet defined)
<# green>    SysFn[328] = new TFn("table",     2, 3,      0,        false,      1);
    SysFn[329] = new TFn("tableget",  3, 6,      0,        false,      1);
    SysFn[330] = new TFn("tableset",  4, 4,      0,        false,      1);
    SysFn[331] = new TFn("placetable",2, 3,      0,        false,      1);
    SysFn[332] = new TFn("killtable", 1, 1000,   0,        false,      1);
    SysFn[333] = new TFn("tableappend",1, 2,     0,        false,      1);
    SysFn[334] = new TFn("tablecall", 1, 1,      0,        false,      1);
    SysFn[335] = new TFn("tableinfo", 2, 2,      0,        false,      1);
    SysFn[336] = new TFn("tablesetparam",3,1000, 0,        false,      1);
    SysFn[337] = new TFn("istable",   1, 1,      0,        false,      1);
    SysFn[338] = new TFn("tablistget",4, 4,      0,        false,      1);

===================================================================
//USER FUNCTIONS//
<just c><B>USER-WRITTEN FUNCTIONS</B>

<just l>These can go anywhere, and in any order. You can have any number of arguments, or none. You can have scalar or array arguments (but not system lists), and the function may return a sclar or an array. Finally, the function may be void (i.e. not return a value, e.g. if its role is only to display something on the screen).

An example of a function definition: <# blue>
       function Hypotenuse ( base, height ) 
       { return sqrt( sqr(base) + sqr(height) )  }<# black>
Note the curly brackets '{..}' to contain the body of the function.
Note the word 'return', followed by an expression or variable whose value is to be returned. If the function is to be void, simply write 'return' with no following expression, or leave it out altogether. 

(You can leave out 'return' if the function is not to return any value <I>and</I> there is only one route through the function. But if, in such a void function, one branch ends with 'return', then every other branch must also do so, or an error will be raised.)

An example of a call to the above function:
       <# blue>hyp = Hypotenuse(3,4);<# black> 

<U>ARGUMENTS</U>
These must always be enclosed in regular brackets '(..)', both in the function definition and in the call to the function; multiple arguments must be separated by commas. If the function does not take arguments, use the empty brackets '()', both in the function definition and in any call to that function.
<I>Argument types are not specified</I>; the code which you write has the task of deciding whether an argument is scalar or not. (You could easily write code which allowed the argument to be either - if scalar, then respond in one way; if array, in another.)

<B>'ref' arguments:</B>There is one qualifier that can be used with arguments: '<B>ref</B>' (short for 'by reference'). Normally a function simply copies the values passed to it as arguments, and therefore has no effect on the variables used in the call to the function. However if an argument is prefixed by 'ref', then whatever value changes occur in the function will also occur in the variable used in the call to the function. (That variable must indeed be a declared variable, and not an expression or a previously unassigned variable; either of these would end the run with an error message.) In the case of arrays this is a memory-saver, as the function will not create a new array if it is passed an existing array by reference. (In the case of scalars, the function does indeed make its own copy and work with that copy; but at the end of the function's run it places the value in the copy to the original calling code's variable.) It is safe to pass 'ref' arguments through chained functions, but <I>not</I> safe to use them in recursive functions. 

Don't try to return a REF argument as is. (The parser will pick up most attempts to do this, but a hacker could find ways around it.) If you did succeed, you would end up with two arrays in the calling program which share the one data strip in memory - a potential disaster. If, as occasionally happens, it is useful to return a REF argument, modify it, e.g. by adding 0 to it: "return Foo + 0;".

A further caveat for REF arguments: If function A accepts x as a REF argument, and then alters the value of x, the main program's copy of x is not updated until focus returns from function A to the main program. Usually this is not a problem, since MonoMaths runs on a single thread, and focus can only be in one place at one time. But if, after altering x, function A calls function B, and function B also has a REF argument x, then function B will evaluate its argument to the original main program copy value of x, not to the altered value in function A's copy of x. (This is not a desirable state of affairs, and will be addressed in some subsequent major revision.)

<b>Optional arguments</b> are allowed, but must come after obligatory ones. They are distinguished by being given a default value: function Foo(aa, bb, cc=3, dd= 2){...}. If you don't supply values for cc or dd when calling the function ('Foo(x,y)' or 'Foo(x,y,z)'), they will take on the values assigned to them as defaults in the function's definition.
Default assignments may be to literal numbers (as above), to constants (whether native to MonoMaths or user-defined by the 'CONSTANT' directive), or to simple expressions involving these. ('Simple expression' means: you can link values by any combination of arithmetic signs '+', '-', '*', '/' and '^', and can use brackets '(', ')', but no system functions are allowed, or variables. Sign hierarchy is in the order just given, from low to high.) Examples: "cc=PI"; "cc = 2 * (PI + 1)".
Even though the default value can only be scalar, the value passed to it at a function call may well be an array. You can test if this has occurred within your function with the code: "if (isarray(dd)){...}"
Optional arguments obviously cannot be 'ref' arguments.

<U>RETURNED VALUES</U>
Functions are not typed as 'scalar' or 'array' functions; you can easily write a function which returns a scalar in one situation or an array in another. For example, you could write fn. "Sin(angle)" to return a scalar if 'angle' is scalar, or an array if 'angle' is an array. (One point of caution: if the calling code is (say) "x = Sin(ang);" and this line occurs in a loop, then at the end of the loop there should be a line "kill(x);"; otherwise if 'x' was defined as an array in the first loop and in the second loop 'Sin(.)' returns a scalar, a type mismatch error will be raised.)

If you leave out the LHS ('var1 = '), with a non-void function, it will be treated as if it were void (the function's returned value being ignored). Also, if you assign a scalar variable to a void function, it will be given the value 0.

<U>MORE ON THE KEYWORD 'RETURN'</U>
Note the effect of the following:
<# blue>return;<# black> -- simply returns scalar value 0.
<# blue>return x;<# black> -- returns the value of x (which may be scalar or an array).
<# blue>return inc(x);<# black> -- increments x and then returns the incremented value.
<# blue>return x = 5;<# black> -- adds 5 to x and then returns the new value of x.


<U>SCOPE</U>
Variables created inside a function are invisible to the rest of the program; and variables created in the rest of the program are invisible to the function (with the exception of system constants, which have global scope). The normal route for getting data into a function is via the arguments; and the normal route for getting data out of the function is via the returned value, or via any 'ref' arguments. There are, however, a few other <I>backdoor ways to transfer information</I> between a function and the rest of the program:

(1) By the use of System Lists (see Help menu item so named), which ignore scope completely and can be accessed from anywhere. 

(2) By placing in the function these declarations: <B>import scalar</B> and <B>import array</B>. The one or more variable names that follow these declarations must be those of main program function variables. New variables with these names are created in the function, their contents being exact copies of the main program variables. However they are only copies, and changes to them do not affect those main program variables. (If you already declared the variables earlier in the same function, no error is raised; but the 'import' call would overwrite the earlier values.)
<# blue>\tarr = data(10, 20, 30);  brr = data(40, 50, 60);
<# blue>\tx = 70;  y = 80;   
<# blue>\tFoo();

<# blue>\tfunction Foo()
<# blue>\t{   import array arr, brr;
<# blue>\t    import scalar x, y;
<# blue>\t    thelot = data(arr, brr, x, y);
<# blue>\t    show(thelot); <# magenta>// This will display the numbers 10 to 80.
<# blue>\t}
<# black>It is permissible to put the instruction anywhere where an assignment may go. E.g. "if (...) { import scalar SoAndSo; ... }".
This system is intended to make a string of main program constants available to functions other than through tediously long argument lists. It would be unwise to use it for accessing values that can vary between calls; that is the job of the argument list.
<# grey>Small print warning: the array being imported must not be currently held by another function as a REF argument. this can occur if e.g. there is a main program variable Arr;  then function Foo(ref Arr) calls another function Bar(.) which has the line "import array Arr".)
<# black>
(3) By using the function 'lookup(.)'. For example, if - in a function - you want to read the value of some variable 'boodle' in the main program, you would use: "x = lookup('boodle');" - note that the argument is an array of characters giving the name of the variable. (You might, for example, have got this name from a dialog box in which you asked the user what variable value he/she wanted to examine.)

Neither (2) nor (3) will allow access to variables in another user function. Only system lists can cross that barrier.

<U>RECURSION</U> is straightforward. Array 'ref' arguments are allowable, for example where the recursion needs to access data within a huge table without making multiple copies of the table. System lists can also be used for such purposes. ('ref' scalars should not be used; no error raised, but the result will not be predictable. Also, do not use optional arguments.). 
An example of recursion:
<# blue>\ta = 5; 
<# blue>\tp = Factorial(a);
\tq = Factorial(a+1);
\tr = Factorial(a+1) - 2*Factorial(a);
\ts = Factorial(Factorial(3));
<# blue>\tfunction Factorial(num)
<# blue>\t{   if (num < 2)  return 1;  
<# blue>\t\telse { x=num-1;  P = Factorial(x);   return num * P;  }
<# blue>\t}
<# black>It is worth following through the sequence of function calls for this by clicking menu item "Run | Show Sequence of Function Calls" after the run.

All the usual caveats apply about using recursion - you can very easily end up with infinite looping or stack crashing, if your program design does not correctly handle all possible inputs.

<U>DISPLAYING ARGUMENTS</U>
Suppose you have written a function "function Shrdlu(time, weight, distance)". Elsewhere in your code you want to use this function, but you have forgotten the order of arguments. Of course you can simply scroll down (or up) to the definition of the function and refresh your memory. But a quicker way is as follows. Where you are using it - "x = Shrdlu(p, " - have the cursor to the right of the opening bracket (up to 50 chars. away), and then key Cntrl-Shift-Space (or else use the menu item "Edit | Write function argument details"). The results window will then display the arguments of function Shrdlu. As a bonus, if you have immediately preceded your function definition by explanatory lines beginning with '//' (ignoring prior spaces and tabs), those lines will also be copied into the results window (if there are not too many of them).
You can display the arguments of <I>system functions</I> also, using the same method.

<U>FURTHER POINTS</U>
You can build up a library of commonly needed functions. After writing a function in the Variables Window, highlight it and then save it using the menu item 'File / Save Function'. You can later insert it into other programs using 'File / Load Function'.

You can't define a function inside a function. Also you can't overload a function. 

If using a 'ref' array argument, don't also return that argument, or you will end up with two arrays sharing one data strip in memory until one or other is reassigned. (An example is given at the end of this section.)

Variable types and values don't persist between calls to user functions. 
______________________________

<I>Example of creating two arrays with a common data pointer:</I>
Here you end up with two arrays that share the one pointer; change an element of one, and you change the same element in the other. The twinning ends when either array is reassigned.

\t<# blue>arr = data(10,20,30,40,50);
\t<# blue>brr = Foo(arr);
\t<# magenta>// Now, by dint of the special construction  of fn. Foo, arr and brr share the same data pointer.
\t<# magenta>// To test this, we alter brr[4], and find that arr[4] has become the same value:
\t<# blue>writeln("Before:  ",  arr);
\t<# blue>brr[4] = 999;
\t<# blue>writeln("After:  ",  arr);

\t<# magenta>// This function alters its REF argument AND ALSO RETURNS it.
\t<# blue>function Foo(ref aa)
\t<# blue>{\taa[1] += 1.11;
\t\t<# blue>return aa;
\t<# blue>}

===================================================================
//ANONYMOUS FUNCTIONS//
<just c><B>ANONYMOUS FUNCTIONS</B>

<just l>At times you may want to place different functions into the one code position during runtime. For this there are two dummy (or 'anonymous') functions in <I>MonoMaths</I> called <B>func1(.)</B> and <B>func2(.)</B>. Both functions normally do nothing; but by using function <b>setfunc(.)</b> you can cause any system or user function to be substituted for either during runtime, and can unset each or reset each to some other function at any later stage in the same program.

Here is an example:
<# blue>setfunc(1, "sin"); <# magenta>// Henceforth calls to 'func1(x)' will behave as if they were to 'sin(x)'. 
<# blue>y = func1(1); <# magenta>// 'y' becomes 0.8414..., i.e. sin(1). 
<# black>

<B>setfunc( scalar WhichFunc, array FnName [, bool DontCrashIfNotFound [, bool SearchUserFnsOnly ] ] )</B>
This function is not void, but returns values as follows under the various circumstances:

<i>WhichFunc</i> must be either 1 (in which case it is setting an alias for 'func1(.)') or 2 (for 'func2(.)').

(a) <I>Two arguments:</I> FnName is sought first amongst sytem functions, then amongst user functions. If found, 'func1' (or 'func2') will henceforth stand for that function (till the next call to 'setfunc' changes things). Returned: scalar 1 for a system function, 2 for a user function.  If function name not indentified, the function crashes.

(b) <I>Three arguments, the third nonzero:</I>  If FnName identified, the same. If not identified, no crash occurs, but 0 is returned.

(c) <I>Four arguments, the fourth nonzero:</I>  As for (b), except that no search through system functions occurs. (This may save a little time where you are using e.g. 'func1' heavily for user functions.)

(d) <I>Two arguments, but 2nd. argument is either scalar or an array of spaces only:</I>  Any function name set by a previous call to 'setfunc' is invalidated. Returns -1.

Note that the only return of 0 occurs if the function name has not been found, and you have set the 'DontCrashIfNotFound' boolean. The test "if (setfunc(FnName, true) { ... use func(..) .... }" would be sufficient to avoid trouble, for example where the name FnName came in through a user's dialog box.


<B>func1( ... )</B>,  <B>func2( ... )</B> 
If either function is called without a prior successful call to 'setfunc(..)', absolutely nothing happens (except that '0' is returned, as for all void functions). In this case the number of arguments is irrelevant; they will all be ignored. The same occurs where the last use of 'setfunc' was the empty cancelling call 'setfunc()'.

However, once you have set a system or user function name with 'setfunc(.)', then e.g. 'func1(..)' behaves exactly as if it were a call to that function. It therefore expects the same number of arguments, and returns the same sort of data. The substitution will continue until altered by another 'setfunc(.)' call.

NB - it doesn't matter where in your program 'setfunc(.)' and 'func1(.)' etc. are placed; as long as <I>somewhere</I> the focus has passed over a valid 'setfunc(.)' call, thereafter 'func1(.)' will stand in for the indicated function <I>everywhere</I>. Therefore you may consider placing the cancelling call 'setfunc(1, " ")' at the end of any segment of code which has been using anonymous functions.

<B>Further Example</B>
<# blue>funkset = split("sin|cos|tan", '|'); <# magenta>// a matrix whose 3 rows are function names
<# blue>for (i, 10)
<# blue>{	n = rand(3); <# magenta>// randomly choose one of the three functions.
	<# blue>theta = rand(90); <# magenta>//  a random 1st. quadrant angle, in degrees
	<# blue>setfunc(2, funkset[n]);
	<# blue>x = func2( rad(theta) );  <# magenta>// convert the angle to radians first
	<# blue>writeln(funkset[n], "(", theta,  " deg.)  =  ", x); <# magenta>// helpfully prints out a table of 10 trig. assignments.
<# blue>}
<# black>
===================================================================
//DATA I/O AND DISPLAY//
<just c><B>DATA INPUT / OUTPUT DURING A PROGRAM RUN</B>

<just l>Before proceeding, you need to understand the system of <B>tagging arrays as 'character arrays'</B>. Arrays have an internal boolean tag which is TRUE if the array is to be seen as a character array. In all situations except those dealt with below, this tag has no effect at all. Its only influence is on how an array is displayed and on what the 'input' function does with the user's input data; these effects are explained below under the different functions. Arrays start their lives not being character arrays; you have to make them so, by using the void function 'chars(Arr)'. (To go the reverse way, use 'nonchars(Arr)' ).  (If you assign some new array Arr1 to Arr - "Arr1 = Arr" - the internal boolean tag value is copied across to Arr1.)


<just l><U>DATA INPUT via DIALOG BOX</U>
The function to use is <b>request</b>(<# blue>Btn, Heading, BodyText, Label1, Content1 [, Label2, Content2, [ ... ] ] , Buttons <# black>) -- Displays a dialog box requesting data from the user, to be entered into one or more text boxes. The function sets 'Btn' and returns the entered data as explained below.
<i>Btn</i> MUST be a predefined scalar variable; the function will reset its value to the code of the button that closed the dialog box.
<i>Heading</i> is the short snippet of text which goes inside the title bar of the dialog box. (No formatting tags are valid.)
<i>BodyText</i> is explanatory text which can be much longer; it will be printed above the textboxes. Only Pango text formatting can be used, which includes the following tags, all of which must be strictly paired: "\<b> .. \</b>", "\<i> .. \</i>", "\<u> .. \</u>", superscript "\<sup> .. \</sup>", subscript "\<sub> .. \</sub>". For more Pango options (including colouring), enter 'format' into the Assignments Window and press F1; scroll to the end of the display.  (The same information is also in the main menu item "Help | Formatting with Text Tags".)
<i>Label - Content pairs</i>:  Any number allowed (but at least one pair). The number of text boxes is set by how many pairs you supply. 'Label' is the text displayed to the left of the text box, and 'Content' is its initial content. If either is scalar, the corresponding string in the dialog box will be the empty string. 
<u>Special Case:</u>  It is possible to condense several label - content pairs into a single pair, using the 3-character delimiter <b>{|}</b> between labels in Label1, and the same number of instances of the same delimiter in Content1. (Of course in such a case, there must be no Label2 and Content2 as further arguments.)  The purpose of this is to allow you to set the number of text boxes at run time, if necessary, rather than design time. Empty content is allowable; for example, if you have chosen three text boxes and want them all to be blank, you can set Content1 to "{|}{|}".
<i>Buttons</i> - A set of button titles delimited by '|'; e.g. "ACCEPT|CANCEL". You can have any number of buttons, but at least one. Buttons are displayed from left to right on the dialog box in the order supplied.
<b>RETURNED</b>
(a) The button click which closed the dialog box is automatically stored in the named argument variable Btn. It will be 0 if the user closed the box using the corner icon; otherwise it will be the number of the button, the leftmost button (and the first referenced in argument 'Buttons') being 1.
(b) The data in the text boxes when the dialog is closed.
If only one text box was present, this will be a chars. array, trimmed of white spaces at both ends. If the text box was empty, it will be an array of size 1, containing the space character.
If there were multiple text boxes, the return is a 'jagged matrix' containing the contents of all boxes, the first box corresponding to row 0. Before the jagged matrix is built, the text box content is trimmed at both ends. In the process of building the jagged matrix, MonoMaths pads smaller rows out to the size of the longest text, using the space character for padding. In the event that all boxes were empty at the time of closure, the matrix will have size (No. boxes x 1), each row consisting of a single space.
<b>PROCESSING THE DATA</b>
There is <b>no internal parsing</b> of data by this function; whatever is typed (or not) in the box is returned. However you may parse scalar and array data using the function <# blue>stringtovalue(..)<# black>. Here is an example, where an array is expected:

<just l><U>DATA INPUT via KEYBOARD</U>
The function to use is <b>keydown</b>(<# blue>bool AsCharArray<# black>) -- returns the code for the key currently held down, or zero if none. If the boolean is false, an integer is returned; otherwise a string identifying the key in human speak. The Hints file has lots of detail - press F1 while the cursor is at the word 'keydown'.

<U>DATA DISPLAY</U>
There are three functions which all take the same arguments: 
<bullet><B>write(..)</B> -- displays text in the Results Window.
<bullet><B>writeln(..)</B> -- the same, but a line feed is supplied at the end.
<bullet><B>show(..)</B> -- displays the data in a message box, in which the 'OK' button must be clicked before program flow continues.

<B>Arguments:</B> You can supply any number of arguments, array or scalar. The rules of their interpretation are optimized for a maths program, rather than for one built for lots of string-handling. They are:
<U> Scalars</U>
If a standalone literal numeral (like "65"), it will be displayed as the corresponding unicode character (in this case, "A").
Otherwise its value will be converted to string form and printed.
<U>Arrays</U>
All depends on the 'characters' rating of the array. If it is a 'characters' array, its values will be interpreted as a string of unicode characters; otherwise its values will be printed as a sequence of numbers delimited by " ,".

Examples:
\t<# blue>writeln(65);  <# magenta>//  displays "A" (which has unicode value 65).
\t<# blue>writeln(64+1);  <# magenta>//  displays "65" (because an expression, not a standalone literal).
\t<# blue>x = 1.2;   writeln("X = ", x);  <# magenta>//  -->  "X = 1.2".
\t<# blue>writeln("ABC");  <# magenta>//  -->  "ABC"
\t<# blue>Arr = data(65, 66, 67);    writeln(Arr);    chars(Arr);    writeln(Arr); 
\t\t<# magenta>//  --> "65, 66, 67" on the first line, "ABC" on the second line.

<# black>Note that the number '10' corresponds to the Unicode linefeed character, so that "write('A',10,'B') will cause A to be written on one line and B on the next. This is the easiest way to break your text up into separate lines.

You can force all values to be taken as unicode characters by using the function  <B>unicode(.)</B>.

You can <B>dictate precision</B> (say, to 3 decimal digits) either the long way (by writing 'round(x,3)' instead of just 'x') or the short way, using a colon ('x:3'). (The parser in fact simply converts the short form into the long form). The number dictates the maximum number of digits after the decimal point (trailing zeroes are suppressed):  'write(1.56789:3)' --> '1.568';  'write(12.1:4)' --> '12.1'. (The colon notation works only with a literal or a variable name or any expression in brackets. E.g. these work: "1.34:3" , "X:3", "Arr:3", "(Arr[0]):3",  "(sin(x)):3"; but these fail without brackets - "sin(x):3", "Arr[0]:3".)

If you wish to <B>display a matrix</B> with each row on a separate line, use the function 'neat(..)' - "show(neat(Arr))". This function also displays higher-order structures meaningfully.

<u>Further points re function <b>show</b></u>
You can dictate the size and/or position of the dialog box by first calling function 'setbox', which see.

You can use <b>formatting tags</b> to make your text look prettier. For information on these, enter 'format' into the Assignments Window and key F1; or consult main menu item "Help | Formatting with Text Tags".

Note that <b>show()</b> always returns a chars. array. Normally it consists of a single space character. But if any text is highlighted in the dialog box at the time of its closure, then the highlighted text is returned.

This goes hand in hand with another capacity of <b>show()</b>: it can be made editable. To do this, make sure that the first 10 characters in the argument are exactly: "[EDITABLE]". E.g. <# blue>show("[EDITABLE]Edit me!")<# black> will display "Edit me!", and you will find you can change the text. These two extra capabilities of <b>show</b> mean that you can prompt the user to enter some text, direct him to select the text, and so retrieve that text for processing.


<U>OOPS! CAUGHT IN A LOOP...</U>
Normally if a program is going too long - possibly caught in an endless loop - you click on either  the 'GO' button (for the holding state) or the 'ABORT' button. But try this:
\t<# blue>while(true) { show("Gotcha!"); }
<# black>You can't get at the magic buttons to interrupt the loop, so the confounded message box won't go away. But there is a way out! If you close the 'show(.)' message box by its top corner icon instead of by the button, you force the program into 'hold' mode, where you are given a choice to abort the program (or to continue, so that you can go on looking at the message box forever).

<U>FORMATTING DATA IN THE DATA DISPLAY</U>
You can use a tagging system, rather like a much-simplified HTML system, to format displayed text. To find out how, enter 'format' into the assignments window and then keying F1; or else, consult main menu item "Help | Formatting with Text Tags".  ('label(.)' only supports 'Pango' tags, which are described at the end of the help sections just mentioned.)


<U>SAVING TO / LOADING FROM A DISK FILE</U>
The functions to use are <b>load(.)</b> and <b>save(.)</b>. Each has several different modes of use.  See the 'System Functions' section for details on these functions, or else enter 'save' or 'load' in the Assignments Window and click on F1.

Other functions that are useful in relation to the handling of disk files: 
	<B>choosefilename</B>(<# blue>DirectoryName [, scalar AllowMultipleFileChoice]<# black>). 
	<B>currentdirectory</B>(<# blue>array DirectoryName OR scalar Dummy<# black>).
	<B>checkdirectory</B>(<# blue>DirectoryName<# black>). 
	<b>filesize</b>(<# blue>PathAndName<# black>).

<just c>_________________________________________________

<just l><U>RULES FOR THE FORMATTING OF DATA IN A TEXT FILE</U>
When you save data using the mode "save('F', ...)", it is saved in the format described below; the resulting file is easily readable from a text editor. The analogous function "load('F', ...)" knows how to decode this data and returns it in the original form (structured array, list array or scalar). Normally you need not worry about the format used; but for the curious, here are the details. I suggest that you save a couple of variables to a test file (say, a 2x3 matrix and a scalar) and then peruse the resulting file while reading what is written below.
   
Any number of variables may coexist in the one file, as each use of 'load(..)' will only read its own variable's data and will ignore the rest of the file.
Blanks at the beginning of a line are ignored, but all other blanks are significant (except where stated otherwise below).
All blank lines are ignored, and all lines not within a 'variable section' (see below) are ignored. E.g. you can have a file header and an introductory descriptive paragraph in the file.
A '<I>variable section</I>' <B>begins</B> with a line that starts with the variable name followed immediately by a colon: e.g.  "X:" or "Distances (kilometres):". (The 'variable name' does not need to be the same as the variable in your program. This name may contain any printable characters except the colon, and may contain internal or even final spaces.)
A '<I>variable section</I>' <B>ends</B> with a line that starts with at least 3 dashes.
Anything after the colon of the start line or the dashes of the end line is ignored.

<U>Formatting within a variable section:</U>
<I>Scalar variables:</I>
Some line after the first must begin with "Scalar" (case unimportant), and that line must end with the variable's value. (The first digit or dash after the word will be taken as the beginning of the number. Anything in between "Scalar" and that digit is ignored.)
<I>Arrays:</I>
Some line after the first must begin with "Array" (case unimportant), and must end with dimensioning information, written like these examples: "3" (for a list array), "4 x 3" (for a matrix), "2 x 3 x 4" (for a higher order structure). Spaces are allowed, and 'X' may replace 'x'. (Anything between "Array" and the first digit will be ignored.) Zero dimensions not allowed.
Subsequent lines will be ignored UNLESS they start with a digit, a minus sign, or '['. Lines that do so will be cumulated. Such lines must contain nothing else but numbers, passages in square brackets (which will be ignored), and either commas or semicolons as number separators. Internally semicolons will be converted to commas. (They would usually be there for visual help only, to show someone reading the text file where a row ends. Likewise the parts in square brackets would usually be to indicate to a reader what data is what.)


==================================================
//GRAPHING - BASIC//
<just c><B>GRAPHING -- 2D and 3D</B>

<just l><U>GRAPHING DURING THE PROGRAM RUN</U>
Graphing in two dimensions (2D) is described first. Graphing in 3D is basically the same; a section at the end of this 'help' page deals with the differences.

There are two stages to displaying a graph. First you define a 'plot' and assign it to a scalar variable. Then you define a 'graph' - the axes and other adornments - in which the graph will be displayed, also (usually) assigning it to scalar variable. As you define this graph you (usually) pass the plot to it as an argument.

The plotting functions for 2D are:  <B>plot(.), plotmesh(.), plotshape(.).</B>
The plotting functions for 3D are:  <B>plot3d(.), plotmesh3d(.).</B>

Here is a simple example:
\t<# blue>xx= data(0,1,2,3,4);
\t<# blue>yy=xx*xx;
\t<# blue>p = plot(yy,xx); <# magenta>// xx holds horiz. axis values, yy holds corresponding vert. axis values.
\t<# blue>g = graph(p);

<# black><U><B>FUNCTION  plot(..)</B></U>
This takes at least two arguments, but can take up to twelve arguments, depending on the amount of sophistication you want in your plot. The function returns a unique scalar identifier:

\t<# blue>p  =  plot(<# red>YValues,  XValues,  <# green>PointType, PointWidth, PointColour, <# magenta>LineType, LineWidth, LineColour,
\t\t\t\t\t\t<# orange>PointFamily, LineFamily,  <# brown>Texts, FontName);

<# black><B>Arguments</B>

<I>YValues, XValues:</I>  Usually two arrays of equal length, the first holding the vertical axis values and the second holding the horizontal axis values.

Four other variants are allowed: 
(1)  <I>YValues and XValues are both scalar</I>: The plot will consist of a single point.
(2)  <I>YValues is an array, and is the <b>only</b> argument</i>:   A machine-generated array will be used for the horizontal axis values, starting from 0, and adding 1 on each time (so the generated array is: [0, 1, 2, 3, ...] ). Used where you want an instant but unadorned survey of the array.
(3)  <I>YValues is an array, but XValues is scalar</I>: As for (2), but the machine-generated array starts at XValues (incremented again by 1 each time). This has the advantage over (2) that further arguments can be supplied to make the graph more visually presentable.
(4)  <I>Both are arrays, but they are not equal</I>: Whichever is shorter will be recycled, leading to curve duplication either in the X direction (YValues shorter) or in the Y direction (XValues shorter). HINT: The first may be a matrix, its <i>row</i> size being the size of XValues. In that case you will get a family of curves, maybe corresponding to different values of some parameter. <i>However</i> the last point of one curve will be joined to the first point of the next - not very nice. To avoid this, use 'plotmesh' instead (see below).

<I>PointType:</I>
Determines the shape of the point. Supply a single character, which is one of the following:
<bullet>' . ' (fullstop) -- a dot (solid circle).  This is the default for the two argument form "plot(yy, xx)".
<bullet>' o ' (small letter 'O', not a zero) -- an outlined circle.
<bullet>' O ' (capital letter 'O') -- a thicker outlined circle.
<bullet>' [ '  --  a solid square. 
<bullet>' ] ' -- an outlined square.
<bullet>' x ' -- a cross. 
<bullet>' X ' -- a thicker cross.
<bullet>' + ' -- a plus sign.
<bullet>' # ' -- a thicker plus sign.
<bullet>' $ ' -- display some text (see below re how to assign the text).
<bullet>'    ' (a space) -- points will not be visible.  (Any unrecognized character has the same effect.)
<bullet> scalar 0 -- points also not visible, but also completely skips the point-plotting loop in MonoMaths, so saving time.

This argument may be scalar; if so, it should be the unicode value for one of the above.

<I>PointWidth:</I>
The number of pixels per side of the shape's containing square. The default is 3. (Where characters are plotted, PointWidth is the font size instead.)
colour
<I>PointColour:</I>
You can specify colour in several different ways.
<bullet>Use a standard colour name (e.g. 'blue'). There are 141 names currently stored; they are those recognized by .NET. Letter case is not important. To see the list, with demonstration of the colours, enter 'colour' into the Assignments Window, select it, and then press the F1 key. Scroll to the bottom of the message box that appears.
<bullet>Use a scalar value, which will be taken as an index to the system palette, as explained below. Or directly use the function itself...
<bullet>System function "palette(n)" to return one of 10 colours in the system palette. ('palette(.)' returns a chars. array holding the colour name.) The modulus of the rounded absolute value of 'n' is used, so that out-of-range values do not cause a crash. Colour names returned for different values of 'n' are: <# blue>0:"blue"; <# red>1: "red";  <# green>2: "green";  <# orange>3: "orange";  <# magenta>4: "magenta";  <# darkviolet>5: "darkviolet";  <# deepskyblue>6: "deepskyblue";  <# brown>7: "brown";  <# grey>8: "grey";  <# black>9: "black"; <# black>10: "white". 
<bullet>Use a hexadecimal number, exactly 6 digits long, prefixed by "0x" - e.g. "0xff00ee". Letter case not important. (The initial '0' is the cipher zero, not the letter 'o'.) The first two digits ("ff" in the example) are for the red component, the next two for the green, the last two for the blue component.
<bullet>Use a <I>non-</I>character row vector of length 3 ( i.e. matrix 1 x 3); then it will be interpreted as an opaque RGB colour - [0] holding the red value, [1] the green, [2] the blue. E.g. 'rowvec(255, 255, 0)' would give you yellow points. Each value must be in the range 0 to 255.

<I>LineType:</I>
Determines the form of the line. Supply a single character, which is one of the following:
<bullet>' _ ' (an underscore) -- a continuous line. 
<bullet>' - '  (a dash) --  a dashed line " - - - - ". 
<bullet>' . ' (a fullstop) -- a dotted line  ".........".
<bullet>' ! ' -- a line of alternating dots and dashes:  " -.-.-.-.-". 
<bullet>' : ' -- a 'dash-dot-dot' sequence:  "-..-..-..-..-".
<bullet>'    ' (a space) -- no line at all.

<I>LineWidth:</I> 
The width of the line, in pixels. The default is 1.

<I>LineColour:</I>
As for PointColour above.

<I>PointFamily and LineFamily</I>
Not often needed, but valuable when they are. Suppose you want some points and/or connecting lines to look different to others. For example, you want points to be alternately shaped like a cross 'x' or like a circle 'o'. For the PointType field use a 2-character array with the two point shape cues as listed above: "xo". Then set PointFamily to to the array 'data(0,1)':
\t<# blue>xx= ladder(11, 0, 1);   yy=xx*xx;
\t<# blue>p = plot(yy,xx,  "xo", 10, 'red',   '_', 1, 'blue',  data(0,1)); 
\t<# blue>g = graph(p);

<# black>To make the graph look even uglier, make every third connecting line a dotted line:
\t<# blue>xx= ladder(11, 0, 1);   yy=xx*xx;
\t<# blue>p = plot(yy,xx,  "xo", 10, 'red',   "__.", 1, 'blue',  data(0,1),  data(0,1,2)); <# magenta>
\t<# blue>g = graph(p);

<# black>It might seem from these that there is no point in the fields PointFamily and LineFamily; all you need to do is to add more elements to PointType and LineType. Not so. These arrays PointType and LineType are <I>data bases</I> of the available types; the actual <I>deployment</I> of the types is the duty of arrays PointFamily and LineFamily. For example, suppose you want points to be shaped 'x' if y is 0.5 or less, and 'O' if greater. You could work like this:

\t<# blue>xx= ladder(11, 0, 1);   yy=xx*xx;
\t<# blue>ptfamily = is(yy, 0.5); <# magenta>// ptfamily is now { 0, 0, .., 1, 1, ...}
\t<# blue>p = plot(yy, xx,  "xO", 10, "red",   '_', 1, "blue",  ptfamily); <# magenta>
\t<# blue>g = graph(p);

<# black>What is happening is that MonoMaths is counting points as it plots them; at the nth. point, it looks in ptfamily for the nth. value, which in this case will be either 0 or 1. If it is 0, then PointType[0] is accessed; if 1, PointType[1] is accessed.

You can do this with colours also; only this time you separate colours by the vertical divider '|'. This is a rehash of the above, but this time with points being red if y is 0.5 or greater:

\t<# blue>xx= ladder(11, 0, 1);   yy=xx*xx;
\t<# blue>ptfamily = is(yy, 0.5); <# magenta>// ptfamily is now { 0, 0, .., 1, 1, ...}
\t<# blue>p = plot(yy, xx,  'x', 10, "blue|red",   '_', 1, "blue",  ptfamily); <# magenta>
\t<# blue>g = graph(p);

<# black>Here, more formally, are the rules for PointFamily:
<bullet>If PointFamily is supplied, and has length L, then when the nth. point is being plotted MonoMaths will reference PointFamily[n modulo L]. (The effect of the modulus is to recycle values in PointFamily; that is why, in order to alternate point types, we supplied just a two-valued PointFamily.)
<bullet>Once some value  ndx = PointFamily[..] has been extracted, MonoMaths will then look at each of the three fields PointType, PointWidth and PointColour; and it will use PointType[ndx modulo {length of PointType}],  PointWidth[ndx modulo {length of PointWidth}],  PointColour[ndx modulo {no. of colours in PointColour}]. (If PointWidth or PointColour is scalar, the effect will be the same as if it was an array of length 1; i.e. the same value will be used for every point.)

Warning: don't use scalar 0 in array PointType; if PointType[0] is 0, then no plotting of any points occurs, whatever is the value of PointFamily. This problem doesn't arise if you use the space character in PointType[i] to indicate that some points should not be plotted. 

The rules for LineFamily are exactly analogous. 
If you want to set LineFamily but don't want to vary points, simply use a dummy scalar value for argument PointFamily, e.g. 0.

 
<I>Texts:</I>
If you supplied '$' as the point type, then this argument will be accessed to find out what text to place on the graph. If you want the same text for each point, just use a single text, e.g. "hello". If you want successive points to have different texts, separate entries with the vertical bar '|'. For example, if you have five points and want them to be numbered, you would use the string "1|2|3|4|5". As with PointFamily, recycling occurs, so that if you had ten points with this value of Texts, then the sixth point would display "1" again.
(It is permissible to have adjacent delimiters: "1||3|4". The program will not try to display text at the second of the four locations, in this case.)
Here is an example, which prints the numbers 1 to 12 for a clock face:

\t<# blue>angle = fill(12, 60, -30); <# magenta>// angle in degrees: 60, 30, 0, -30 ...  - for placement of numbers 1 to 12.
\t<# blue>angle = rad(angle); <# magenta>// convert from degrees to radians.
\t<# blue>xx = 0.95 * cos(angle);   yy = 0.95 * sin(angle); <# magenta>// The factor ensures that the numbers fit fully onto the graph.
\t<# blue>p = plot(yy, xx, '$', 16, 'red',  ' ',0,0,   0,0,  "1|2|3|4|5|6|7|8|9|10|11|12"); <# magenta>// no lines, just points.
\t<# blue>g = graph(p);
\t<# blue>graphresize(g, 500, 500); <# magenta>// just to make the clockface circular rather than elliptical.
<# black>
If you want a different delimiter (because you would like '|' to be printed as part of some text), then prefix the string with these three characters: "}c{" - where 'c' is replaced by any character you would like to use as the delimiter instead. E.g. "}‖{string1‖string2‖string3".

<# black><I>FontName:</I>
Supply the name of a font that is on your system. You can use a comma-separated list of font names in the order of your preference (most preferred first); if the first is not present, the 2nd. will be used; etc.  E.g. you could use: "Comic Sans MS, Arial, Verdana, Sans". Note that all texts of the plot will have the same font.


<# black><U>FUNCTION  <B>graph(..)</B></U>
Once you have generated one or more plots as above, you can make them visible with this function, which generates a single graph containing one or more plots, and returns a unique graph identifier:

\t<# blue>g  =  graph(any number of plot identifiers);

<# black>Arguments may be any mix of scalars and arrays; in other words, if you have generated lots of plots and it pleases you to store their identifiers in arrays, then you are free to use such arrays as arguments. If you supply no arguments at all, or if none of the plot identifiers turn out to be valid, a blank graph will result.

<U>CHANGING GRAPH VISIBILITY</u>
<b>graphvisible</b>(<# blue>scalar GraphID [, bool NewVisibility ] <# black>) -- Always returns the final visible status of the graph as 'true' or 'false'. If NewVisibility is present, then 'true' forces the graph to be visible, 'false' forces invisibility. If no graph GraphID exists, the function returns 'false' (with no indication that the graph does not exist).

<U>SETTING THE SCALE, POSITIONING THE HAIRLINES</u>
As in the example at the start, you can leave it to the program to generate its own values for the axis limits and the number of hairlines. But more usually you would control these using the functions <B>gridx(..)</B> and <B>gridy(..)</B>, or the function which combines these two, <B>grid(..)</B>.

The syntax is as follows. 'graphID' is the number returned by the 'graph(..)' function above; 'lo' and 'hi' represent values at the low and high end of an axis, and 'segmts' the number of segments into which hairlines should cut the axis extent:
\t<# blue>gridx(graphID, lo, hi, segmts ); <# magenta>// Set the X-axis extremes and hairlines
\t<# blue>gridy(graphID, lo, hi, segmts); <# magenta>// Set the Y-axis extremes and hairlines
\t<# blue>grid(graphID, Xlo, Xhi, Xsegmts, Ylo, Yhi, Ysegmts); <# magenta>// Set for both axes at once.
<# black>(Note that 'lo' does not have to be less than 'hi'; reversed order is allowed on axes. However the two values must not be equal, and 'segmts' must round to 1 or more.)

Obviously the graph will have to be drawn twice by using these functions: first, at creation, it will use default axis parameters, then it will be redrawn using your supplied grid values. This usually happens far too fast for you to notice.  If you want to avoid this double-dealing, in the case of 'grid(.)' alone you can omit the graphID, and place the instruction just before the graph definition.

Although the grid functions are usually used in a void manner, as above, they do return an array. If there is no error, it simply holds the values of the arguments (not including the graph ID). For an error it has length 1, value NaN; and a call to 'empty(.)' would return TRUE.

<U>HIDING THE HAIRLINES</u>
You can choose to have full hairlines (the default), or hairlines reduced to just stubs on the axis, or no hairlines or stubs. The function is <b>showhairlines</b>(<# blue>GraphID, scalar HowX [, HowY [, HowZ ] ] <# black>). If e.g. HowX is zero, the graph's X axis will have no hairlines or scale markers; if 1, no hairlines but small scale markers will occur where hairlines would go; if 2 (the default) - or any other value - full hairlines are present. Note that scaling strings at hairline locations are not affected by this function.

<U>TEXT EMBELLISHMENTS</U>
For all of the following text functions, the first argument must be the graph ID.

You can display a <b>window title</b> in the blue upper border of the window, using <b>graphtitle(GraphID, array TheTitle)</b>. The main point of doing so is so that the same title will appear in the panel button representing the graph, vital if there are many graphs present at once (otherwise you have a row of empty buttons in the panel). Note that there are exactly two arguments.

You can apply <B>heading text</B> to the top of the graph using the nonvoid function <B>header(GraphID [, array(s) / scalar(s) Text] )</B> . The composition of 'Text' is exactly as for the argument(s) of functions 'write(.)' and 'show(.)', with the proviso that different rules apply for formatting tags, as the underlying Gdk uses Pango tags only.  You can use the following: \<b> ... \</b>, \<u> ... \</u>, \<i> ... \</i>, \<^> ... \</^> (for superscript), \<v> ... \</v> (subscript).  (Exact pairing is essential, as these are translated into Pango tags - which you would have to google, for details. You can actually use any other Pango tags, but I do not list them here.) 
If GraphID is not identifiable, this function returns the 'empty array' (size 1, value NaN; testable with function 'empty(.)' ). Otherwise, it ALWAYS returns the current heading. If the only argument is the graph ID, the last set heading for this graph is returned, and nothing is changed. Otherwise what is returned is exactly what you have just put in (probably not very useful).

You can put <B>explanatory text under the graph</B> using the nonvoid function <B>footer(.)</B>.
There are two forms:
<i>footer(GraphID, <some text>)</i> -- where 'some text' is any mix of arrays and scalars, and is treated exactly as is the argument of 'write(.)' or 'show(.)'. All of the MonoMaths tags are allowed here; to see the options, type 'format' into the Assignments Window and key F1; or consult main menu item "Help | Formatting with Text Tags". (If 'some text' consists of a single scalar argument, it is treated as the second form instead.)
Normally no cursor is visible in the footer, though it is editable, so that if you type, characters will appear there. If the values "<some text>" begin with exactly the three unicodes of "|+|", then the cursor will be made visible. It will remain visible with further calls to 'footer(.)' for this graph, until a call for which "<some text>" begins with "|-|", switching cursor visibility off. (In both cases, these three initial characters will not be displayed.)

<i>footer(GraphID [, bool FinalVersion])</i> -- returns the existing footer for the graph. If FinalVersion is absent or 'false', the value is the last that was set for this graph using this function 'footer'. It will be complete with any formatting tags. If FinalVersion is 'true', (a) what you get back is whatever is <i>now</i> displayed on the graph; the user may have altered this by typing directly into the graph (as the footer is editable, even though no cursor is visible); and (b) whether altered or not, what you get back is <i>bare text</i>, devoid of all (valid) inserted formatting tags.
If GraphID is not identifiable, this function returns the 'empty array' (size 1, value NaN; testable with function 'empty(.)' ). Otherwise, it ALWAYS returns a chars. array. For the first form, this is simply what you have just put in (probably not very useful).

You can add a few words beside the scale markings to explain what the scale is - e.g. 'miles per hour' - using void functions <B>labelx(.)</B> and <B>labely(.)</B> (for X and Y axes respectively). No formatting tags are valid here. If you use the function with only the one argument - the graph ID - then the function is no longer void, but returns whatever is the current axis label.


<U>MODIFYING THE GRAPH BOX - SIZE, POSITION, COLOUR</U>
By default, graphs have a size much smaller than the full screen, and can end up anywhere on the screen according to an algorithm which is part of .NET. You can of course tow a graph away with the mouse, or drag its borders around, or minimize or maximize it, or close it down, as with most other Windows windows. But you also have some programmatic control over things.

<b>Find the current size of the plot surface</b>
The function <b>pixels(<# blue>Scalar GraphID<# black>)</b> returns an array of size 4. For 2D graphs, [0] = width of a pixel in terms of the X axis variable; [1] = height of a pixel in terms of the Y axis variable; [2] = number of pixels from left to right of the plottable surface; [3] = same, vertically. For 3D graphs, [0] and [1] are always simply 0, and [2] and [3] give the width and height of the blue-lined box which contains the actual 3D plot region together with the region to its right where descriptive data goes. If the graph cannot be identified, the return is { -1, -1, -1, -1 }.
<i>Caveat:</i>  If used after 'graphresize(.)', you have to allow time before calling 'pixels(.)', or you are given the sizes that predated the 'graphresize(.)' call. Insert a step like this:  "starttimer();  while (timer() < T) { dummy = 1; }", where T  is found by experiment. (On my current computer, T = 100 (msecs) is safe;  T = 40 to 60 fails some of the time;  smaller T always fails.)
<i>Special use:</i> <b>pixels(<# blue>"screen"<# black>)</b>  -- Returns an array of size 2; [0] = the screen width, in pixels; [1] = the screen height.

<B>Set a new size for the plot surface</B> of the graph (i.e. excluding headers, scaling etc.) using function <B>graphresize(<# blue>GraphID, PixelsWide, PixelsHigh<# black>)</B>. This is especially useful if you want the plot surface to be exactly square, for example to correctly show angles, or to make a circle not look like an ellipse. Both arguments must be > 20, or else no resizing occurs. You may have to experiment, as Mono's Gtk sometimes disagrees with your values by a few pixels, and ignores them if they are too large. (If you are more interested in the size of the whole form holding the graph, use function <i>boardresize(.)</i> instead.)

<B>To change the screen position</B> and size of the whole form containing the graph, use function <B>placeboard</B>(<# blue>Scalar GraphID, Values Left, Top, Width, Height<# black>). Values <= 1 are taken as a fraction of screen width or height; values > 1 as pixels. To produce a full-screen graphing form, use arguments { GraphID, 0, 0, 1, 1 }. Negative value: original parameter remains unchanged. Alternative version: <B>placeboard</B>(<# blue>scalar GraphID, char. array PutItWhere), which leaves the graph dimensions unchanged but places it in one of nine positions on the screen, depending on the value of 'PutItWhere'. Nine values are valid:  "top_left", "top_mid", "top_right", "mid_left", "mid_mid",  "mid_right", "btm_left", "btm_mid", "btm_right".

<b>To retrieve the current colours</b> of graph features, the function is <b>graphcolours(<# blue>GraphID<# black>)</b> - just one argument. This returns  a matrix 6x3, each row being the RGB values of the colour of the corresponding graph item. The six rows in order give the colours of the following structures: [0] -- the plotting surface (background to the curves);  [1] -- the hairlines;   [2]: the thin line forming the perimeter of the plotting surface;  [3]: the background outside the plotting surface, where scaling information goes;  [4]: scaling text at hairlines ("10, 15, 20, ...");  [5]: text of axis scale descriptor (e.g. "velocity (kms.)" ).

<b>To change colours</b> of graph features, use the same function with extra arguments: <b>graphcolours(<# blue>GraphID, one to six colour arguments (arrays)  in the order given below<# black>)</B>. (The cue for "don't change the colour" is to provide a scalar rather than an array for that colour.) Such arrays would usually be colour names (e.g. "light blue"), but to see other possibilities enter 'colour' into the assignments window and key F1. The function always returns a matrix 6x3, exactly as above, representing the situation after changes have been made.
 

<# black><U>MODIFYING OR OVERRULING AUTOMATIC SCALING</U>
In all of the following functions, <B>the graph ID must be present</B>.
Also, only the X axis versions are described; in each case, change the 'x' in the function name to 'y' or 'z' for use with other axes.

<B>(a) Don't have every hairline labelled.</B>
You can cause some automatic scaling tags to be dropped. Suppose we count the left extreme of the X axis as division 0, and then call the successive hairlines division 1, 2, 3, ... We require that the first hairline to be labelled will be hairline 1, and thereafter every 3rd. hairline: { 1, 4, 7, ...}. The function call is:
\t<# blue>firstLabelled = 1;  hairlineJumps = 3;
\t<# blue>scalejumpx(graphID, firstLabelled, hairlineJumps);
<# black>
<B>(b)  Multiply automatic scaling values by a scaling factor and a suffix</B>
Suppose you are graphing a trigonometric function; the X axis is to extend from 0 to 2 π. You want four segments between these two limits. If you use the function "gridx(0, 2*π, 4), the automatic scale generation will supply these scale tags: "0,  1.571,  3.142,  4.712,  6.283". You can change this to "0 π,   0.5 π,   1 π,   1.5 π,   2 π " using this function call:
\t<# blue>scalefudgex(graphID, 1/π, " π"); <# magenta>// note the leading space before 'π'. You must supply such a space, if you want it.

<# black>But you have two further arguments to refine this.
<bullet>If you want to replace "0 π" with just "0", add a boolean argument:
\t<# blue>scalefudgex(graphID, 1/π, " π", 1);  <# magenta>// Now the scale will be: "0,   0.5 π,   1 π,   1.5 π,   2 π "
<bullet><# black>If you also want to replace "1 π" by just "π", add a second boolean argument:
\t<# blue>scalefudgex(graphID, 1/π, " π", 1, 1);  <# magenta>//Now the scale will be: "0,   0.5 π,   π,   1.5 π,   2 π "

<# black>The program doesn't let you use a scaler (like 1/π here) in the absence of a suffix; this, for example, will achieve nothing:
\t<# blue>scalefudgex(graphID, 1/π, "   ");
<# black>It's not that we don't trust you; it's just that it is too risky - you could make the adjustment to the wrong graph, for example, and have no way of knowing that the scale was actually false. If you <I>must</I> fudge the purely numerical results, you can use method (c) below.

<# black>You can't use formatting tags in 'scalefudgex'. However you can implant special characters (as we did with 'π' above) simply by copy-and-paste from a character source.

<B>(c)  Supply a characters array that overwrites the machine-generated values</B>
The function to achieve this has exactly two arguments - the graph identifier (which cannot be omitted), and the characters array of tags, using commas as separators. (Spaces are significant.)
Suppose that the naturally generated scale numbers were "1, 2, 3, 4, 5". You could alter this as follows:
\t<# blue>scaleoverx(graphID, "cat,dog,rat,hog,bat"); <# magenta>// The scale tags will be: "cat, dog, rat, hog, bat".
<# black>If too few new tags are supplied, naturally generated numbers make up the rest:
\t<# blue>scaleoverx(graphID, "cat,dog,rat "); <# magenta>// The scale tags will be: "cat, dog, rat, 4, 5".
<# black>If too many new tags are supplied, excess tags will be ignored:
\t<# blue>scaleoverx(graphID, "cat,dog,rat,hog,bat,sat,mat,hat"); <# magenta>// The scale tags will be: "cat, dog, rat, hog, bat".
<# black>Empty tags are permitted. For example you could blank all five scaling tags with:
\t<# blue>scaleoverx(graphID, ",,,,");
<# black>An easier shorthand for blanking ALL scaling tags is to supply as argument a single '#' (no blanks):
\t<# blue>scaleoverx(graphID, "#");

<# black>You can't use formatting tags in 'scaleoverx', however as with 'scalefudgex' you can implant special characters simply by copy-and-paste from a character source.

<# black>Function <I>scalejumpx(.)</I> is ignored for the scaling extent which is overwritten by this function.

One other set of functions occasionally of use is <B>scaleformatx(GraphID, char. array)</B>, and the -y(.) and -z(.) equivalents. the array is any format string as recognized by .NET. These are not listed here, save to say that the default is "G4", which allows for 4 significant digits, and presents them either in decimal format or scientific format, whichever is shorter. (1234567 --> '1.235E+06';  123.4567 --> '123.5';  0.1234567 --> '0.1235';  0.00012345 --> '0.0001235'.).


<U>PLOTTING A SET OF CURVES, WITH OR WITHOUT A MESH</U>

(If you don't want a mesh but just a family of curves, you might do better with function <b>plotmx(.)</b>, which is described separately; key F1 with the cursor on the word in the Assignments Window for details.)

You can use the function <B>plotmesh(.)</B> to draw a family of curves, all with the same number of points; if you wish you can also join corresponding points in the different curves so as to develop a mesh. I will describe the case for the mesh; then I will point out how to do away with the joins between curves.
In what follows, the original family of curves is called the 'forward' curves, and the lines that cross-link them will be called the 'transverse' curves.
Here is a simple example, to illustrate the point.
\t<# blue>PtsPerCurve = 5; <# magenta>// The number of points on a 'forward' curve.
\t<# blue>xx = ladder(PtsPerCurve, 0.2, 1); <# magenta>// X-coordinates for the first forward curve.
\t<# blue>yy = xx^2; <# magenta>// Y-coordinates for same.
<# magenta>// Now build two matrices, one for X-coords and one for Y-coords, each with a separate row for each forward curve:
\t<# blue>NoCurves = 3;
\tdim(MX, MY, NoCurves, PtsPerCurve);
\tMX[0] = xx;    MX[1] = xx - 0.02;    MX[2] = xx - 0.05; <# magenta>// We choose to vary the X-coords. slightly for the three curves.
\t<# blue>MY[0] = yy;    MY[1] = yy + 0.1;     MY[2] = yy + 0.2;
<# magenta>// Construct a basic mesh graph - no embellishments:
\t<# blue>p = plotmesh(MY, MX);
\tg = graph(p);
<# black>
If you want corresponding points on  curves to share the same X value, then the second argument need only be a list array of the X values. To see this at work, replace "plotmesh(MY, MX)" in the above code with "plot(MY, xx)".

Here is the full format for function 'plotmesh(.)'. It has exactly the same arguments as function <b>plot</b>(.), but with two extra arguments (underlined). Only the first two arguments are obligatory.

\t<# blue>p  =  plotmesh(<# red>YValues,  XValues,  <# green>PointType, PointWidth, PointColour, <# magenta>LineType, LineWidth, LineColour,
\t\t\t\t\t\t<# orange>PointFamily, LineFamily, <b><u>TransverseLineFamily</u>,  <u>Looping</u></b>,  <# brown>Texts, FontName);

<# black>All arguments in common with 'plot(.)' have exactly the same interpretation as for function 'plot(.)' above. <i>PointFamily</i> and <i>LineFamily</i> apply to all forward curves (there is no way of making different curves appear differently).
New argument <b>TransverseLineFamily</b> applies to lines linking the curves transversely. Again, all transverse curves will be the same as one another.
The other new argument <b>Looping</b> acts as a boolean array. If Looping[0] is 'true' (nonzero), then the forward curves all loop (that is, the last point of each curve is joined back to the first point). If Looping has two elements and [1] is 'true', the transverse curves all loop. (If Looping is scalar, it is ignored, leading to the default - no looping of any curves.)

If you <i>don't want a mesh</i> - just a set of forward curves - set <i>TransverseLineFamily</i> to the array "data(-1)" (NB, not just to scalar "-1"), and unwanted prior values (e.g. point family, line family, if not using them) to -1.


<U>PLOTTING A SHAPE</u>
There are four functions involved; <b>plotshape(.)</b> creates the shape; if necessary, <b>moveshape(.)</b> can later be used to redeploy the same shape, <b>paintshape(.)</b> can change its outline and fill colouring, and <b>copyshape(.)</b> can be used to duplicate the shape. Enter any of these function names into the Assignments Window and key F1 for details of use.


<U><# black>KILLING, REMOVING AND PRESERVING </U>
<B>Does it exist?</B> Two functions for existence are used: <B>isgraph</B>(<# blue>scalar GraphID<# black>) -- if the graph exists, evaluates to 2 (for 2D graphs) or 3 (for 3D graphs). Otherwise returns 0, so can be used like a boolean in conditional statements. And <B>isplot</B>(<# blue>scalar PlotID<# black>) -- which also evaluates to 2 (2D) or 3 (3D), or 0 if nonexistent. 

A third function is useful to find what plots are present in a graph. <B>plotsof</B>(<# blue>GraphID<# black>)  returns an array. If the graph exists and has plots, the array length is the number of plots in the graph, and the array elements are the plot IDs. Failure produces an array of size 1, value NaN; a call to 'empty(.)' returns TRUE.
It is safe to use this function inside 'addplot(.)', 'killplot(.)' and 'removeplot(.)', even if 'plotsof(.)' returns the failure array just mentioned. For example, "addplot(Graph2, plotsof(Graph1));" can be used to copy all the graphs of Graph1 across to Graph2.


<B>Removing plots</B>. Two functions are used. The first - <# blue>removeplot(GraphID, plotIDs)<# black> - simply removes given plots from a particular graph, but leaves them elsewhere intact and reusable. The second - <# blue>killplot(plotIDs)<# black> - removes all trace of them in memory, including from any graphs currently displaying them. In both cases, the arguments 'PlotIDs' may be any mix of arrays and scalars.

<B>Killing graphs</B>.  You can kill graph 'g', together with all the plots which it contains, by the instruction <# blue>killgraphs(.)<# black>, which see for details.

<B>Preserving graphs between runs</B>. At the end of your program run, the graphs will still be there, but will vanish when next you click on 'GO'. If you want them instead to be preserved, use the menu setting "Graphing | Preserve old graphs...". (On the subject of the graphing menu, note that you can also use it to kill all the graphs that have persisted after the run. This is useful if your run generated, say, ten graphs, and you don't want to be bothered with closing these windows one by one.)


<U>ALTERING EXISTING GRAPHS</U>
You can change the plots on an existing graph, for example to produce animation effects. The subject is too long to put here; read all about it in Help menu item <I>Graphing - Interactive</I>.

<U>COPYING A GRAPH</U>
<B>graphcopy</B>(<# blue>scalar OriginalGraphID, bool UseStartupDimensions<# black> ) -- Draws a copy of the original graph, but without any plots. The graph ID is returned (or 0, if the original graph was not identified). If <i>UseStartupDimensions</i> is TRUE, the new graph will be sized according to the dimensions of the old graph <i>when it was created</i>. (In the case of 3D graphs, it will also revert to the original graph's startup cage orientation.) If you want to reproduce any changes to that size (as produced by dragging the old graph's margins, or by funtion 'graphresize(.)'), set this argument to FALSE. (In this case, be warned that if there is less than around 0.1 seconds between a call to 'graphresize(.)' on the original graph and a call to this function, the new graph will not reflect that graph-resize operation. I have tried various tricks to overcome this quirk of the underlying Gtk drawing system, but have so far failed.)
_______________________________

<B>GRAPHING IN 3D</B>

The functions involved are <B>plot3d(.), plotmesh3d(.)</B> and <B>graph3d(.)</B>.

They take  the same arguments as <B>plot(.), plotmesh(.)</B> and <B>graph(.)</B>, <I>except</I> that 'plot3d' and 'plotmesh3d' start with three array arguments, rather than two:

\t<# blue>p  =  plot3d(<# red><b><u>ZValues</u></b>,  YValues,  XValues,  <# green>PointType, PointWidth, PointColour, <# magenta>LineType, LineWidth, LineColour,
\t\t\t\t\t\t<# orange>PointFamily, LineFamily,  <# brown>Texts, FontName);

\t<# blue>p  =  plotmesh3d(<# red><b><u>ZValues</u></b>,  YValues,  XValues,  <# green>PointType, PointWidth, PointColour, <# magenta>LineType, LineWidth, LineColour,
\t\t\t\t\t\t<# orange>PointFamily, LineFamily, TransverseLineFamily,  Looping,  <# brown>Texts, FontName);

<# black>Only the initial three arguments are obligatory; any number of remaining arguments can be supplied.

In the case of <b>plotmesh3d(.)</b>, <i>ZValues</i> must always be a matrix, dimensioned as (no. of forward curves x no. of points per curve). <i>XValues</i> and <i>YValues</i> may also be matrices of the same dimensions. However if you are content for the lines of the mesh to be strictly and regularly alligned with the X and Y axes - so that a vertical view of the mesh from above the XY plane will appear like a piece of graph paper - then <i>XValues</i> can be an array with one value per forward curve (forward curves being those which start from the X axis and are in a plane parallel to the ZY plane), and the <i>ZValues</i> can be an array with one value for corresponding points on all forward curves. In other words, the length of <i>XValues</i> must be the number of <i>rows</i> in <i>ZValues</i>, and the length of <i>YValues</i> must be the number of <i>columns</i> in <i>ZValues</i>. 

<# black>See above for all the details of the remaining arguments.

<U>Setting the axis limits and hairlines</U> uses the function <B>grid(.)</B> exactly as for 2D graphing, but with the obligatory addition of three extra arguments:
\t<# blue>grid([graphID,] Xlo, Xhi, Xsegmts, Ylo, Yhi, Ysegmts, Zlo, Zhi, Zsegmts);
<# black>As with 'grid(.)', the argument values may be presented all together in one array (or in any mix of scalars and arrays, as long as the total number of values is 9 or 10). If GraphID is not present, the parameters will be applied to the next graph created (but not to subsequent graphs). On the other hand, <b>gridx(.), gridy(.)</b> and <b>gridz(.)</b> all require the GraphID, each taking arguments in the form (GraphID, LoValue, HiValue, NoSegments).

'graphresize(..)' works for 3D, affecting the graph margins but only indirectly affecting the size of the contained 3D axis grid.

<B>header(.)</B> and <B>footer(.)</B> work exactly as for the 2D case; no special 3D function is needed. Other functions working in 3D as for 2D include <B>isgraph(.), isplot(.), killgraphs(.), killplot(.), scaleformatx(.)</B>. However <b>scaleoverx/y/z(.)</b> work differently, as 3D graphs have the scale summarized to the right of the plotting surface of the graph. Each must have exactly three values in the argument array: the 'from' value, the 'to' value and the 'step' value. Also because of this, functions <b>scalefudgex/y(.)</b> have no effect in 3D. Functions <b>labelx(.)</b> etc. work as for 2D graphs, but their text will also be printed to the right of the plotting surface.

<b>Setting the initial viewpoint:</b> If you don't want the default viewing angles, use function <b>aspect</b>(<# blue>[graphID, ] scalar Declination, scalar RightAscension)<# black>. Imagine that your graph is of a man standing and facing you, and consider the plane of your table top as you view him on your vertical computer screen. <i>Declination</i> would then be the angle between the man and the table plane (0 when he is prone before you in an act of adoration; PI/2 when he is standing proud and vertical). The man can be rotated through a full circle, to face all directions; in doing so, his declination is unaltered. Now return him to face you, at whatever rakish declination angle he is standing relative to the table. His <i>RightAscension</i> is now 0. Rotate him through a right angle to face the wall to your right; his RightAscension is now PI/2. 
The default settings for 3D graphs are: Declination = PI/3;  Ascension = PI/6. If you want to use a default and cant remember these, write the system constant NaN in place of the angle.
If you omit graphID, then the settings apply to the next 3D graph to be drawn.
You can also retrieve the current settings by calling with only one argument: <b>aspect(graphID)</b>. This will return an array of length 2: [0] = current Declination, [1] = current Ascension. If graphID could not be identified or is 2D, the return is an array of size 1, value NaN, and a subsequent call to 'empty(.)' returns 'true'. (The 3-argument version also returns these values; but the 2-argument version is void.)
Note that you can also read the current aspect, and optionally alter it as well, by invoking the graph menu item "Scaling | New Aspect".

<B>Two 3D mesh examples:</B> The first example uses a 'graph paper' mesh - when you look down vertically on the XY plane, all lines are parallel to the X or Y axis, evenly distributed. The second has no such restriction; each node of the mesh has its own X, Y and Z coordinates without restrictions.

<# magenta>// FUNCTION GIVING THE HEIGHT OF THE MESH above each point in the XY plane:
<# blue>function ZMesh(x,y){ return (1 - x^6)*(1 - y^2); }
<# magenta>// PREPARE THE MESH:
<# blue>xnodes = 21;  ynodes = 20; <# magenta>// no. of axis intercepts of mesh wires.
<# blue>xmin = -1;  xmax = 1;  ymin = -1;  ymax = 1;  zmin = 0;  zmax = 2; <# magenta>// axis extremes
<# blue>rowNo = ladder(xnodes, xmin, xmax); <# magenta>// a locn. for every X-axis wire intersection in the mesh.
<# blue>colNo = ladder(ynodes, ymin, ymax); <# magenta>// same for the Y- axis.
<# blue>populate MeshArr through rowNo, colNo using ZMesh; <# magenta>// The array MeshArr is not predefined, but is created by this statement.
<# blue>grid(xmin, xmax, 5, ymin, ymax, 5, zmin, zmax, 5);
<# magenta>// PLOT THE MESH:
<# blue>p = plotmesh3d(MeshArr, colNo, rowNo, ' '); <# magenta>// Note the order of axis arrays; the dims. of MeshArr must be (size of rowNo) x (size of colNo).
<# blue>graph3d(p);

<# black>The second example:

<# magenta>// Draw the skeleton of a hemisphere (lines of latitude and longitude)

<# magenta>// Function to return the X,Y coordinates of a circle in the XY plane:
<# blue>function Circle(centreX, centreY, radius, angle) <# magenta>// Returns array of size 2: [0] = x, [1] = y.
<# blue>{	dim(result,2);
	result[0] = radius*cos(angle) + centreX;
	result[1] = radius*sin(angle) + centreY;
	return result;
}

<# magenta>// Program proper.
<# blue>centreX = 0.5;  centreY = 0.5;   sphereRadius = 0.5;
norows = 9;  nocols = 37;  
dim(mX, mY, mZ, norows, nocols);
for (i=0; i < norows; i++)
{	for (j=0; j < nocols; j++)
	{	radius = sphereRadius*cos(PI*i/(2*norows));  <# magenta>// radius of a latitude circle as projected onto the XY plane.
		<# blue>angle = 2*PI*j / (nocols-1); <# magenta>// On the XY plane, points on the latitude circle are taken at regular angles of 10 degrees around it.
		<# blue>xy = Circle(centreX, centreY,   radius,   angle); <# magenta>// returns each point on each projected circle in the XY plane.
		<# blue>mX[i,j] = xy[0];  mY[i,j] = xy[1];  
		mZ[i,j] = sqrt(sphereRadius*sphereRadius - radius*radius); <# magenta>// successive circles as defined above are elevated to where they would lie on the hemisphere, at 10 degree intervals.
	<# blue>}
}
grid(0,1,5,  0,1,5,  0,1,5);
p=plotmesh3d(mZ, mY, mX,    ' ', -1, -1,    '_', 1, "blue",   '.', 1, "magenta" ); <# magenta>// Points: don't show. Main lines: blue, continuous. Cross connections: magenta, dotted.
<# blue>graph3d(p);



===============================================
//GRAPHING - INTERACTIVE//
<just c><B>Graphing - Interactive</B>

<just l>It is possible to get feedback from existing graphs (such as information about a mouse click or a menu click on the graph tablet). It is also possible to change the characteristics of existing graphs (such as the scaling, or the data being displayed). As a result, animation is possible. Examples of useful graph interaction will follow, but first we have to run through the available system functions. (The best way to understand their action is to copy and run the sample programs given below.) 

Note that every graph (the surface on which a set of curves is plotted) has its <B>unique 8-digit identifier</B>, never zero. You need this identifier in nearly all of the functions below. To obtain it, use 'graph(.)' or 'graph3d(.)' in a non-void manner:
<# blue><B>g = </B>graph(plot1, plot2, ...);  <# magenta>// where plot1 etc. are plot ID numbers.
<# black>
<U>FUNCTIONS WHICH PROVIDE FEEBACK FROM EXISTING GRAPHS</U>

<B>(a)  Graph menu-handling functions</B>
<B>lastclosed()</B> -- used to detect closure of a graph. If any graph has closed, this function will return its identifier (by reading an internal 'interrupt request' issued by the closing graph); if none has closed, it returns 0. A call to this function automatically resets the interrupt request, after reading it, so that a second call immediately afterwards would return 0. If you just want to check whether a particular graph still exists or not, it is better to use '<# blue>isgraph(graphID)<# black>', as 'lastclosed()' only provides the ID of the latest graph to close.

<B>gfixedclick()</B> -- used to detect clicks on submenus of the fixed graph menus ('fixed' meaning the ones that are there already; the user may add another menu item - see next section.) A chars. array is returned. Element [0] = a status indicator; [1] = time when the click occurred (milliseconds since the start of 1 AD); and from [2] to the end is what is written on the menu, but with spaces removed - e.g. a click on "Viewpoint | Move Left" will return the string "MoveLeft". If the status indicator is 1, there has been a new click since the last call to this function; if 0, then this was already handled by this function (though elements [1] up are unaltered.).
If the graph does not exist, the return is of size 3: { -2, -1, 32 } (the last being the space character). If the graph exists but no fixed menu's submenu has yet been clicked, the return is of size 3: { -1, -1, 32 }. 
This function does not respond to clicks on submenus of the user-added menu (see below), and also not to the 'File | Exit' submenu. 
<b>gfixedvisible(GraphID, array MenuName, bool Visibility)</b> -- void; changes the visibility of the graph's <i>main menu items</i>. Only the first letter of MenuName is accessed (case-insensitive); this should be one of 'F' (File), 'Z' (Zoom), 'V' (ViewPoint), or 'S' (Scaling). You can only change the visibility of one item per function call, and you can't make individual submenu items invisible.

<b>Extra Menu:</b> In the graph's main menu there is a hidden menu item which the user can invoke, equipping it with up to 20 submenus (but at least one). This extra menu system is invoked with void function <b>gxmenu(GraphID, Title, Subtitles )</b>, where 'Title' is the title of the added main menu item, and 'Subtitles' is the accumulated titles of its successive submenus, delimited by '|'. E.g. <# blue>gxmenu(thisGraph, "Change Colour", "Red | Green | Sky Blue" )<# black> will produce a menu named 'Change Colour' with three submenus. Note that spaces at the start and end of titles are ignored, but internal spaces (as in "Sky Blue") are preserved. To change even one title or subtitle, or the number of submenus, you have to call "gxmenu(.)" again with all arguments, as if calling it for the first time. Empty titles and subtitles should be avoided. The function is not void, but <i>returns a boolean</i>, which is only ever false if GraphID could not be identified.
All submenus are automatically visible after the above. To alter visibility, use <b>gxvisible(GraphID, Visibility)</b>, where 'Visibility' is a set of values (in any mix of arrays and scalars). Its elements are nonzero ('true' - for 'make visible') and zero ('false' - for 'make invisible'). Visibility[0] applies to the main menu item, and Visibility[1+] to the submenus. If there are less argument values than menu items, only those addressed will have visibility affected. If there are more argument values, the excess will be ignored.
The function <b>gxvisible(.)</b> is not void, but always returns the final visibility state of all items as an array. So if you don't want to change the visibility of the second submenu but just want to read its visibility, use <# blue>arr = gxvisible(GraphID);<# black> and then test arr[2]. In the event that GraphID cannot be identified, the function returns an array of size 1, value -1.
To read clicks, use <b>gxclick(GraphID)</b>. This returns the index of the submenu clicked, and then immediately resets the internal flag raised for GraphID by that click, so that a second call to 'gxclick(GraphID)' would return -1 instead. If no click has occurred in the lifetime of the program, this function returns -1. If the graph cannot be identified, it returns -2. Note that submenus are <i>numbered from 1 upwards</i>, as they are for function 'gxvisible(.)'. Note also that this function does not detect a click on the main menu item itself.

<B>(b) Other event-handling functions</B>
<B>arr = readgrid(g) </B> -- where 'g' is the tablet identifier. This returns exactly the array that you would use as an argument for 'grid(...)'. In other words, for the 2D case, the array has size 6, and is: [X minimum, X maximum, No. of X segments, Y minimum, Y maximum, No. of Y segments]; and for the 3D case, an array has size 9, the first 6 elements being the same, and the remainder being: Z minimum, Z maximum, No. of Z segments.
If graph 'g' doesn't exist,an array of size 1, value NaN is returned, and a call to 'empty(.)' would return TRUE.

<B>arr = pixels(g) </B> -- Returns an array of size 4. For 2D graphs, [0] = width of a pixel in terms of the X axis variable; [1] = height of a pixel in terms of the Y axis variable; [2] = number of pixels from left to right of the plottable surface; [3] = same, vertically. For 3D graphs, [0] and [1] are always simply 0, and [2] and [3] give the width and height of the blue-lined box which contains the actual 3D plot region together with the region to its right where descriptive data goes. If the graph cannot be identified, the return is { -1, -1, -1, -1 }.
<i>Caveat:</i>  If used after 'graphresize(.)', you have to allow time before calling 'pixels(.)', or you are given the sizes that predated the 'graphresize(.)' call. Insert a step like this:  "starttimer();  while (timer() < T) { dummy = 1; }", where T  is found by experiment. (On my current computer, T = 100 (msecs) is safe;  T = 40 to 60 fails some of the time;  smaller T always fails.)
<B>arr = pixels('screen') </B> -- Returns an array of size 2; [0] = the screen width, in pixels; [1] = the screen height.

<B>bool = newclick(g)</B> -- where 'g' is the tablet identifier. Simply returns TRUE (i.e. 1) if the particular graph has been clicked; the call to the function resets the flag in the graphing unit which signals the click, so that a second call immediately following would instead return FALSE. FALSE is also returned if the graph does not exist. The internal flag which it reads becomes TRUE from the time of button-down, so the function returns TRUE even while the button is still being held down.

<B>mx = mouse(.)</B> -- This gives information about where the mouse pointer is when a mouse button goes down, which button it is, and where the mouse pointer is when the button goes up again, and the times involved. It can also, if desired, give details of up to the last five clicks. For full detail on the function, either go to the end of this section or enter the name into the Assignments Window and click F1.

<b>graphkey(g)</b> -- Returns the latest keypress occurring while graph 'g' is in focus, and in the process removes the internal record of it. In fact, the internal record consists of a stack of the 10 latest keypresses; each call to graphkey(.) pops one keypress permanently off the stack.
The return is always an array of size 3: [0] is the basic key value, [1] is the helper-key combination code, and [2] is the number of unprocessed keypresses left on the stack after this call. (If no keypress since startup, or since all extant keypresses have been handled, the returned array is {0, 0, 0]. If 'g' does not exist, the return is [-1, -1, -1].)
More on [0]: This holds the value assigned by .NET to the key. Common ones: 'A' (or 'a') - 65; '0' - 48;  TAB - 9; Enter - 13;  Space - 32;  Arrows: left - 37, right - 39, up - 38, down - 40;  Cntrl - 17; Shift - 16; Alt - 18. (Use the code example below to get values for keypresses that you want to recognize.)
More on [1]:  Using abbreviations 'c'(ontrol), 's'(hift) and 'a'(lternate), the returned code (0 to 7) corresponds to the following helper key combinations:   0="", 1="a", 2="c", 3="s", 4="ac", 5="as", 6="cs", 7="acs".
Sadly the keying (if printable) will be printed in the description section below the graph, as this section is editable; but you can easily remove it with the 'delete' key, as in any other editable box. 
Run the following example code. Once the (empty) graph is in focus, do key presses, and see the results appear in the status bar below the Results Window (not on the graph itself). You may have to drag the graph away to see it. (Don't test the TAB key, as this will shift focus away from the graph's hidden textbox for key testing. But two further TABs would bring focus back there.)
\t<# blue> g = graph();  <# magenta>// Create and focus an empty graph.
\t<# blue>while (true)
\t<# blue>{\tif (lastclosed() ) break;  <# magenta>// End the program by closing the graph.
\t<# blue>\tarr = graphkey(g);
\t\t<# blue>if (arr[0])  label('C', "Base key: ", arr[0], 10, "Helper key combination code: ",arr[1]);
\t<# blue>}
<# black>
Although function <b>keydown(.)</b> is not specific to graphing, it can be useful, for example to detect whether or not a helper key is being held down when a mouse click occurs on the graph. (For example, you might want to decree that the nearest point is removed from the graph when you mouse-click with 'Cntrl' held down.) Here is some sample code:
<# blue>g = graph(); <# magenta>// Generate a blank graph
// Loop, waiting for mouse clicks
<# blue>while (true)
{	if (lastclosed() != 0) break; <# magenta>// The only way out of the loop is to close the graph.
<# blue>	if (newclick(g))
	{	ss = keydown(true); <# magenta>// Get the name of the key as a chars. array 
<# blue>		foot = "At the time of the mouse click, ";
		if (ss == "#0") foot = text(foot, "no key"); 
		else foot = text(foot, "the '",  ss,  "' key");
		foot = text(foot, " was being held down.");
		footer(g, foot);
	}
}		
<# black>For full information on 'keydown(.)' and the values which it returns, enter the function name into the Assignments Window and press F1. Also, note that the one key which will not work for the above code is the "Alt" key, as this is reserved by the underlying Gtk# environment for use with invoking graph menus.

It is also possible for the user to <b>send typed text back from the graph to the program</b> as follows. If you start typing while a graph is in focus, you will find yourself adding to the contents of the graph's footer (even though you can't see a cursor there). It is fully editable. If the program is polling "str = footer(GraphID);", then it can be testing 'str' for the results of such editing. Note that what you get with 'footer(GraphID)' is bare text; any formatting tags  present in the footer's preexisting text will be lost.


<U>OTHER FUNCTIONS IMPORTANT IN RESPONDING TO GRAPH FEEDBACK </U>
(You'll find out why as we work through examples.)

<B>killplot(p1, p2...)</B> -- plots p1, p2..., if identified, are removed from memory, and from all graphs containing them.
 
<B>addplot(g, p1, p2, ...)</B> -- If graph g can be identified, then plots p1, p2... are added to the graph (if in existence). No error is raised if graph or plot IDs are not identifiable. Any number of plot IDs can be supplied, as any mixture of scalar or array values. You would use this function in conjunction with <B>killplot(.)</B> to gradually move a point or curve or shape across the graph surface. Suppose your graph displays plot p1, and that you wish to make the plot slightly different, as the next step in an animation. You would devise plot p2 as the slightly different version of p1, and then call 'killplot(p1);  addplot(g, p2);'. The function applies to both 2D and 3D graphs. Duplication is not a problem; an attempt to add a plot already present in the graph is simply ignored.

<B>removeplot(g, p1, p2, ...)</B> -- removes the plots (if identified) from graph 'g'; but unlike 'killplot(.)', it does not remove them from memory or from other graphs; you could install p1, p2... into future graphs, if you wished. As with the above functions, any number of plot IDs can be supplied, as any mixture of scalar or array values.
NB: in animation sequences, <I>don't</I> use "removeplot(g,p1); addplot(g,p2);". The graph will show the animation just fine, but meanwhile hundreds of undestroyed and useless plots are filling up computer memory, which is indeed a Bad Thing!

<U>EXAMPLES OF USE</U>
<B>1.  A curve which moves to wherever on the graph you mouse-click.</B>
The graph is of y = x*x + C, where the constant C is initially 0, but is reset after mouse clicks such that the new curve passes through the point just clicked.

<# magenta>// Set up 101 X-values from 0 to 1, and corresponding Y values (X squared):
<# blue>xx=ladder(101,0,1);    yy=xx*xx;
<# magenta>// Draw the initial plot, using a nonvoid call to 'plot(.)', to get the graph no.:
<# blue><B>p = plot</B>(yy, xx);    g = graph(p);
<# magenta>// Enter a WAITING LOOP:
<# blue>while (TRUE)
{	if (<B>lastclosed()</B> != 0) { break; } <# magenta>// closing a graph sets this to the graph's identifier.
				<# magenta>// If you had more than one graph, you would use: " == p" as the condition instead.
	<# blue>if (<B>newclick(g)</B> ) <# magenta>// a click happened:
	<# blue>{	squeak = mouse(g)</B>; <# magenta>// retrieves data re this latest click:
	<# blue> 	clickX = squeak[10]; clickY = squeak[11];  <# magenta>// the point clicked by this latest click.
		<# magenta>// Find the nearest xx[i] to the click point:
		<# blue>n = place(xx, clickX); <# magenta>// find the first index i of xx[i] such that xx[i] <= xclick
		<# blue>if (n >= 0) <# magenta>// = -1 if could not place xclick
		<# blue>{	ydel = clickY - yy[n]; <# magenta>// vertical distance between curve and click point
		<# blue>	yy += ydel;
			killplot(p); 
			p = plot(yy, xx); 
			addplot(g, p); 
		}
	}
}

<# black><B>2. Simulation of Brownian Motion. All points start at the origin, then gradually move away by random walk.</B>
<# magenta>// Set up a population of points, all at the origin:
<# blue>NoBlobs = 200;
<# blue>dim(xx, yy, NoBlobs); <# magenta>// To compute new positions, we will use a random radius and a random direction.
<# magenta>// These will require the following further arrays:
<# blue>delrr = xx;  delang = yy; <# magenta>// radius and angle increments will be in these.
<# blue>delxx = xx;  delyy = yy; <# magenta>// XY coordinate increments will be in these
<# blue>Step = 0.01; // <# magenta>maximum step size for a blob
<# blue>grid(-1.5, 1.5, 6, -1.5, 1.5, 6);
<# magenta>//----------------------------------------------------------------------
<# magenta>// OUTER LOOP: Iterates every time the plotting arrays are updated.
<# blue>firstloop = true;   
p = 0; <# magenta>//  dummy declaration, so 'killplot(p)' won't raise a parsing error.
<# blue>while (true)
{	if ( not(firstloop) ) { killplot(p); }
	p = plot(yy, xx,   '.', 5, 'red', ' '); <# magenta>// Big red points, no connecting lines.
	<# blue>if (firstloop) 
		{ g = graph(p);   graphresize(g, 500, 500);  firstloop = false; } <# magenta>// Make the graph square, so the circle looks like a circle.
	else { addplot(g, p); }
	FrameReady = FALSE;
	TimeStep = 20; <# magenta>// millisecs between frames. (Once you go above a few hundred points, the time
			<# magenta>// taken for graphing will be longer than this, but this will not cause any problem.)
	<# blue>starttimer(1); <# magenta>// Sets timer '1' to 0 milliseconds. (timer no. can be 0 to 9.)
		<# magenta>// INNER TIMER LOOP: waits for the timer to count up from zero to TimeStep.
	<# blue>while (timer(1) \< TimeStep) <# magenta>// (If something goes wrong, so this loop
 		//  never ends yet no graph appears, remember to click on 'GO' to abort action.)
	<# blue>{	if (not(FrameReady))
		{	rand(delrr, 0);   delrr *= Step;    rand(delang,0);  delang *= 2*PI;
			delxx = delrr * cos(delang);   delyy = delrr * sin(delang);	
			xx += delxx;       yy += delyy; 
			FrameReady = TRUE; <# magenta>// You only need to recalculate the arrays once during the waiting loop. 
		<# blue>}		
	}
	if (lastclosed() == g) { break; } <# magenta>// Outer loop exit occurs when the user closes the graph.
<# blue>}

<# black>You could add a scale adjustment to the above. For example, once the outermost particle has an |X| or |Y| value exceeding the current axis limit of 1.5, you could use 'grid(.)' to zoom out.

<# black><B>3. Simulation of Brownian Motion in 3D. All points start at the origin, then gradually move away by random walk.</B>
<# magenta>// Particles undergoing random walk in 3D, visually resembling Brownian motion. 
// Points are in a cube which has one corner at the origin, and side 1.
// Set up a population of points, all in the centre of a cube - i.e. at (0.5, 0.5, 0.5):
<# blue>NoBlobs = 20;
xx = fill(NoBlobs, 0.5);  yy = xx;  zz = xx;
dim(delxx, delyy, delzz, NoBlobs);  <# magenta>// increments will be in these.
<# blue>Step = 0.01; <# magenta>// maximum step size for each blob per loop.
<# blue>grid(0, 1, 5,   0, 1, 5,   0, 1, 5);
<# magenta>//----------------------------------------------------------------------
// OUTER LOOP: Iterates every time the plotting arrays are updated.
<# blue>TimeStep = 10; <# magenta>// millisecs between frames. (Actually once you go below around 50, the time taken
     // by graphing takes longer than this - on my computer, at any rate - but no problem arises.
<# blue>firstloop = true;   
p_old = 0;  g = 0;
while (true)
{	p = plot3d(zz, yy, xx,  '.', 5, 'red',  ' ');
	if (g == 0) g = graph3d(p);
	else 
	{	addplot(g, p);
		killplot(p_old);
		p_old = p;
	} 
	<# magenta>// INNER TIMER LOOP: waits for the timer to count up from zero to TimeStep.
<# blue>	FrameReady = false;
<# blue>	starttimer(1); <# magenta>// Sets timer '1' to 0 milliseconds. (timer no. can be 0 to 9.)
<# blue>	while (timer(1) \< TimeStep) <# magenta>// (If something goes wrong, so this loop
<# blue>	{	if (not(FrameReady))
		{	rand(delxx, 0);   rand(delyy, 0);   rand(delzz, 0);   	
			delxx = Step*(2*delxx - 1);  delyy = Step*(2*delyy - 1);  delzz = Step*(2*delzz - 1);  
			xx += delxx;       yy += delyy;   zz += delzz;
			FrameReady = true; // You only need to recalculate the arrays once during the waiting loop. 
<# blue>		}		
	}
	if (lastclosed() == g) break; <# magenta>// Outer loop exit occurs when the user closes the graph.
<# blue>}

<# black>In animation scenarios, note that you can <B>manually change the value of a main program scalar parameter during looping</B>. Stop the animation loop by clicking on the 'GO!' button, and then on the 'HOLD' button that appears. Animation is frozen. Then on the MonoMaths menu (not the graph menu), click on "Other | Change Value of a Scalar", and change the required value. Then reclick on the 'GO!' button; the animation loop resumes, now using the new value of the parameter for calculations.
                      __________________________________

<B>MORE ON FUNCTION mouse</b>(<# blue>scalar GraphID [, bool ReturnHistoryMatrix ]<# black> )
If you provide a positive GraphID, this will only return data for click(s) on that particular graph; but if GraphID is 0 (or negative), it returns data on any graphs clicked.  
Usually you just want information about the latest mouse click. If so, don't provide a second argument. We will look at that case first.

<u>(Case 1) Just the Last Click</u>
The return is a <i>list array</i> of size 18, made up as follows. Note that after a mouse button has gone down, some fields have different values before and after it then goes up.
<i>All fields default to 0</i> where there has been no click yet on the graph. (To check for this state, either element [0] or [1] are suitable.)
If you supplied a particular GraphID and that graph could not be identified, the return array will consist entirely of values -1.
<bullet>[0]: ID of clicked graph.
<bullet>[1]: Button: 1 = left, 2 = middle (if none, usually simulated by pressing left and right buttons simultaneously); 3 = right button.
<bullet>[2]: TRUE (i.e. 1) if the button is still down; otherwise FALSE (0). 
<bullet>[3]: Time at which the button went down, in milliseconds since the beginning of 1 AD. Can be compared with the present time, as returned by (datetime())[9].
<bullet>[4]: Period in milliseconds for which the button was down; 0 if the button is still down.
<bullet>[5] to [9]: Currently unused.
The rest are mouse pointer coordinates:
<bullet>[10], [11] are the x and y SCALED coordinates of the pointer at the instant when the button went DOWN. (Always (0, 0) for 3D graphs.)
<bullet>[12], [13] are x and y PIXEL coordinates corresponding to the above. (The reference point (0, 0) is the top left of the whole Drawing Area, not of the plotting surface; the Drawing Area covers all below the header label and above the footer label and between the side margins of the window.)
<bullet>[14], [15] are the x and y SCALED coordinates of the pointer at the instant when the button went UP. (Always (0, 0) for 3D graphs.) 
<bullet>[16], [17] are x and y PIXEL coordinates corresponding to the above. Both the last and this set of coordinates are all zero while the button is still down.
  
<u>(Case 2) Click History Required</u>
This returns a matrix of five rows, each of length 18, and each with data corresponding to the above schema. Row [0] corresponds to the latest click, and is exactly as above. Higher rows however will have no UP coordinates and no button-down period (i.e. elements [4], [14] to [17] will all be zero). Where there have not yet been five clicks, rows above the latest click (if any) will consist entirely of zeroes.

<U>What about double-clicks?</U>
You would have to write a double-click detector in your code, using the times provided by 'mouse(.)'; your code would decide if two clicks were close enough together to constitute a double-click. Also, your code should delay the response to a single click until sure that it is not the first of a double-click pair.

===============================================
//FORMATTING WITH TEXT TAGS//
<B>FORMATTING TEXT FOR DISPLAY</B>
<stops 20, 200, 220>
<left 20><in -20>The following applies for system functions <B>write(.), writeln(.), show(.)</B>. At the end there is a further formatting instruction which applies only to <B>show(.)</B>, which allows you to specify the size of the displayed message box.

Tags are used more or less in the same way as in HTML; but there are far fewer tags available, and some are quite different. One <I>major difference</I> between the system here and HTML is that with HTML runs of spaces in the text are treated as if they were a single space; with our system, all spaces are faithfully reproduced.

Tag contents are NOT case-sensitive.

PAIRED TAGS THAT DO NOT ALTER TEXT: (If any of these tags are unpaired, the tag is still removed from the displayed text, but no formatting occurs.)
	BOLD	\<b\> ... \</b\>
	ITALIC	\<i\> ... \</i\>
	UNDERLINE	\<u\> ... \</u\>
	DOUBLE UNDERLINE	\<uu\> ... \</uu\>
	STRIKETHROUGH	\<x\> ... \</x\>

TAB STOPS: "\<stops 50, 100, 200, 220\>". (Further tabs replicate the distance between the last two tab stops.)
    Tab stops apply till (a) a new setting of stops; or (b) the closer tag "\</stops\>"; or (c) to the end of text.

PARAGRAPH JUSTIFICATION: "\<just yak\>" where only the first letter of 'yak' (case-insensitive) is checked, and must be one of:
    'l'(eft - the default, so only useful to negate another justification), 'c'(entre), 'r'(ight), 'f'(ill - both margins
    flush).
The setting stays in force till the first of: (a) another setting of the same type; or (b) the cancelling tag "\</just\>"; or (c) the end of text.
The closing tag, if present, should be the last entry in the last paragraph to which it applies, or else the very first entry in the next paragraph.

PARAGRAPH INDENTING: the indenting of the FIRST LINE of the paragraph relative to the margin set for the paragraph; can be negative (for hanging paragraphs).
	"\<in 30\>" (for 30 pixels); or just "\<in\>" for the default indent of 20 pixels.
The setting stays in force till the first of: (a) another setting of the same type; or (b) the cancelling tag "\</in\>"; or (c) the end of text.
The closing tag, if present, should be the last entry in the last paragraph to which it applies, or else the very first entry in the next paragraph.
Note that the setting is <i>relative to the previous paragraph's indenting</i>; hence negative indents are allowed, after earlier positive indents: "\<in -30\>".

PARAGRAPH MARGIN SETTING:
  LEFT MARGIN: "\<left 30\>" (for 30 pixels).  Cancelled by a new left margin setting, or else applies to end of text. There is no closer tag.
  RIGHT MARGIN: "\<right 30\>".   Cancelled by a new right margin setting, or else applies to end of text. There is no closer tag.
Note that left and right margins are distinguished by the sign of the value; they are absolute pixel values relative to the TextView's margin, not to the prior tag's margin.
      As with Indenting, you can use either without an argument: "\<left\>", "\<right\>"; the default is the same: 20 pixels.

HANGING PARAGRAPH:
Uses the above. E.g. to indent lines after the first by 20 pixels, start the first such paragraph with: "\<left 20\>\<in -20\>".
To undo this - so that further paragraphs are 'normal' - use the line prefix: "\<left 20\>\<in 0\>".

BULLET PARAGRAPH:
At the very beginning of each paragraph to be indented with a bullet, use "\<bullet\>". Unlike the above tags, the formatting does not carry over to the next paragraph, so there is no need of a cancelling tag.
Inner deeper levels of bulletting are possible, using a suffix, which is the indent (in pixels) of the left edge of all text in the bulletted paragraph. The default is 30, so you might like to try  "\<bullet 50\>" for the second level of bulletting. Again, there is no carry over of this value to the next paragraph.
You can even change the bullet symbol. To do this you must start with the indent, even for the default case (indent = 30); you then add a comma, and immediately after it the character (or character string) which you want as your new bullet. E.g. for the standard bulletted item, to change the bullet to '#', do: "\<bullet 30,#\>" (no quote marks).
If you don't want a bullet at all (e.g. for the 2nd. paragraph of a 2-paragraph bullet item), do  "\<bullet 30,\>".
Here are some possible bullets:  •‧⁕⁜⇨→∎∙⊕▻◾☛☞⚪⚫➯⭑⭐‣
You want numbered bullets? Then you use a sequence like "\<bullet 30,1.>", "\<bullet 30,2.>", ...   (You have to set the numbers yourself - they are not automatically assigned.)

COLOURS:
You can colour either: (1) the text itself - "\<# yak\>" (where 'yak' stands for the colour descriptor); or (2) the background behind the text - "\<~ yak\>". In both cases, note that there is a space before the colour descriptor. The colour change is cancelled either by another tag of the same type or by the appropriate cancelling tag ("\</#\>" or "\</~\>").
The colour descriptor can be one of the following:
<bullet>A colour name: "\<# blue\>". (The names are as recognized by .NET; there are 146 such names. Sorry, they are not listed here, so just try your luck. They are not case-sensitive, but no spaces are allowed inside the name. E.g. "\<# LightBlue\>", but not  "\<# Light Blue\>").
<bullet>The RGB code of a colour, as three numbers (in that order): "\<# 255,0,128\>".
<bullet>The RGB code of a colour, as a six digit hex number (2 digits for each colour, in that order): "\<# FF0080\>".
There are other ways of doing it, but you would have to check program code for details.

FONT CHANGES:
  FONT: "\<font Courier_New, 12\>". Cancelled either by a new font-changing tag or by the cancelling tag "\</font\>". Use underlines where there are spaces in the font name (as spaces are parsed out); OR put the name(s) spaces into double quotes: '\<font "Courier New", 12\>'.
There must be a size, and the size must be separated from the font name by a comma.
You can list several fonts, in order of preference, if not sure what will be available on the computer running the program: "\<font myfont1, myfont2, myfont3, 10\>".
You can also specify a level value (in pts.), the height or depth (neg. value) of the char. above the base line. Do this by appending it to the font size, after another comma: "\<font myfont1, myfont2, 6, -3\>".
If you just want to change the font size, replace the font name with the key word 'same': "\<font same, 5\>".
If you want to keep the same size but change the font, you can use '?': "\<font Courier_New, ?\>"
NB! ***  Within a segment of altered font, BOLD and ITALICS will not work. This is a Gtk problem; I have not yet found a workaround for it.

SUPERSCRIPT: Turned on by "\<^\>",  cancelled either by "\</^\>" or by a subscript tag (or by its cancelling tag).
SUBSCRIPT: Turned on by "\<v\>",  cancelled either by "\</v\>" or by a superscript tag (or by its cancelling tag).
As with font changes, BOLD and ITALICS will not work in a super/subscripted segment.

SPECIAL CHARACTERS:
<bullet><i>Reserved characters</i> -- i.e. those used as part of formatting instructions.
<left 50>*    '\<' and '\>' used to be a problem, where they were not part of a tag; but I think that problem is sorted now. However you are still free to use "\\\<" instead of "\<", and "\\\>" instead of "\>".
*    To display a literal backslash '\\', enter it doubled: "\\\\\".
<bullet><left -50><i>Linefeed, Tab</i> -- "\\n", "\\t". (Note that the letter must be lower case.)
<bullet><i>Greek Letters</i> --  "\<| x\>", where 'x' is any of the following Latin letters. (NB - note the space between '|' and 'x'.)
	Latin  letter:	a b g d e z @ 0 i k l m n x o p r  s c t u f  h y  w   A B G D E Z # 9  I K L M N X O P R S T U F H Y W
	Greek letter:	α β γ δ ε ζ  η θ ι κ λ μ  ν ξ ο π ρ σ ς τ υ φ χ ψ ω  Α Β Γ Δ Ε Ζ Η Θ Ι Κ Λ Μ Ν Ξ Ο Π Ρ Σ Τ Υ Φ Χ Ψ Ω
<bullet><i>Maths Symbols</i> --  "\<* x\>, where 'x' is any of the following characters. (NB - note the space between '|' and 'x'.)
	Code character:	 i	j	S	/	+	o	x	(	)	{	}	-	|	R	F	d	D	8	A	~	#	=	\<	\>
	Maths   symbol:	∫	∮	∑	√	±	°	×	‹	›	≪	≫	‒	‖	ℛ	ℱ	∂	∇	∞	∡	≈	≠	≡	≤	≥
<bullet><i>Unicode Character Codes</i> -- "\<& ...\>". E.g. for the letter 'A' - which has unicode 65 (decimal) or 41 (hexadecimal), you could write "\<& 65\>" or "\<& 0x41\>". (Note the space after '&'. Also, for hex numbers, the prefix '0x' uses the cipher '0', not the letter 'o'.)


<b>PANGO FORMATTING TAGS</b>
Labels in programs (like MonoMaths) written in the language C# using Gtk#, cannot use tags of the above sort; however they can use tags defined by the Pango element of Gtk. Here are some examples of what is allowable. There is no guarantee that they will all work; trial and error is the rule. But they are all described on the Net (search "Pango Markup Language" as a phrase).
Pango tags must always be paired, or the text gets mangled or disappears altogether. (Pango takes no prisoners.)

Bold: 	\<b>yak\</b>
Italic: 	\<i>yak\</i>
Underline: 	\<u>yak\</u>
Strikethrough:	\<s>yak\</s>
Monospace font: 	\<tt>yak\</tt>
Subscript: 	x\<sub>1\</sub> + x\<sub>2\</sub>
Superscript: 	E = mc\<sup>2\</sup>
Make font larger: 	\<big>yak\</big>
Make font smaller: 	\<small>yak\</small>
 
\<Span> Attributes

Font changes: uses the keyword 'font_desc':
        \<span font_desc="Verdana">yak\</span>
        \<span font_desc="24">yak\</span>
        \<span font_desc="Verdana 24">yak\</span>

Other keywords to use similarly, all with the 'span' tags:
    Style: 'normal', 'oblique' or 'italic'
    Weight: 'ultralight', 'light', 'normal', 'bold', 'ultrabold', 'heavy', or a numeric weight
    Underline: 'none', 'single', 'double', 'low' or 'error'
    Text colour: 'foreground', the argument being  "#RRGGBB" (RR etc. stands for a 2-digit hex RGB colour value). 
		e.g. for blue text:  <# blue>\<span foreground="#0000FF">yak\</span><# black>
    Background colour: 'background', the argument being as above.
	Underline colour: 'underline_color', the argument being as above.     
	Variant:	 either 'normal' or 'smallcaps'.
	Stretch: 	The font width - one of 'ultracondensed', 'extracondensed', 'condensed', 'semicondensed', 'normal', 'semiexpanded', 'expanded', 'extraexpanded', 'ultraexpanded'.

<b>Forcing a line break:</b> Inserting '\\n' into the text just does not work. You have to insert the value '10' - e.g. in the status bar label: <# blue>label('C', "This is line 1", 10, " and this is line 2.");

===============================================
//MAIN MENU ITEMS//
<just c><B>MAIN MENU ITEMS</B>

<just l><U>FILE MENU</U>
<B>New -- Open -- Save -- Save As</B> are obvious. The default directory for files is, in order of availability: (1) the directory last used to save a file (as opposed to a function - see next paragraph); or (2) the directory set by the INI file (valid at startup, and until files loaded / saved); or (3) the program's directory, if INI file unavailable.
<B>Load Function -- Save Function</B>To save a segment of text (usually a function you have written), or to insert such a segment from disk into your current file, use these options. The default file extension is 'txt', but use what you like. A separate internal record (also in the INI file) is kept for the default directory for these menu options.
<B>Save Array or System List</B> Only does anything after you have run the program, and so have data to save. A submenu asks you for the obvious details. The variable is saved as prefixed binary data, exactly as if it were saved by function 'save('A', ...)' with the argument 'ApplyPrefix' set to 'true'; it can be retrieved during another run of MonoMaths using function 'load('A', ..., true)'.
<B>Save Settings for Future Runs</B>  Certain changes can be made from the menu (e.g. fonts and window colours), which may optionally be retained for the future. To make the changes stick, you need to click on this item. (You can also edit the INI file directly in a text editor, as it is a human-readable plain text file; when editing, keep to the format which appears obvious from other items in the file. And don't edit the INI file while the program is running, or your changes will be overwritten when the MonoMaths instance ends.)
<B>Run New MonoMaths instance</B> -- does just that. Useful while you are coding a longer program, e.g. to check out the effect of some short routine before inserting it into your main code.
<b>Reload Pnemonics</b> -- This item allows you to edit the pnemonics file within MonoMaths and then, after saving it, invoke the edited set of pnemonics in the same MonoMaths instance.

<U>RELOAD MENU</U>
Stores the most recently saved or loaded files, in order of recency. Click on one to reload it.

<U>EDIT MENU</U>
<b>Undo, Redo, Copy, Cut, Paste</b> behave as in most other applications.
<b>Block of Text Actions</b> -- In an ideal GTK world you would be able to draw a box somewhere across text in the Assignments window and copy / cut such a block, inserting it elsewhere. This menu item is an apology for the lack of such a facility. Instead of drawing a box, you  make a selection across several lines of text; the indent of the start of the selection (as a number of characters) defines the left edge of the virtual box, and the indent of the end of the selection defines the right edge. (Obviously the selection must cross at least one paragraph, and the end of the selection must have a greater character offset than the start of the selection.) You can then either copy or cut the contents of this virtual box. Its contents are <b>not</b> stored in the clipboard, but in a special buffer. You can paste from this buffer elsewhere. To do this, you click on the same menu item again, but this time with no selection; the cursor is considered to be at the top left corner of where you will plant the stored box of text, either inserting it there or overwriting text there. The best way to understand this feature is to experiment with it for a while on some useless piece of text.
Note that there are problems where you use this on most fonts, as they give different thicknesses to different letters; also tabs are a problem, as the width of the tab is usually set to be much more than the width of a character. To overcome the first problem, temporarily convert the text to a font where letters have equal length, using menu item "Appearance | Toggle proportional font"; the original font will return later, when you again click this menu item. For the second problem, replace tabs by some character not used elsewhere in the text (e.g. '£' would usually be fine) before making your selection; do this with the "Search | Replace" menu (in which you represent a tab as "\\t").  Revert this character back to the tab after the action is over.
<B>Code Completion</B> -- (You would normally use the shortcut key for this, as shown on the menu.)  Checks text to the left of the cursor, and compares this with internal identifier lists. If a single match is found, the word at the cursor is replaced with the found word. If more than one match, a context menu is displayed; clicking on the appropriate menu item replaces the word at the cursor with the chosen word. Entries in the context menu are colour-coded and annotated, so that you know whether they are initialized variables (if the program has already been run), potential variables (if the program has not been run yet), system functions or user functions, or keywords (like 'for').
<b>Special Characters</b> -- allows insertion of Greek or Maths characters; self-explanatory. The dialog also explains how to do this without the menu click, just using hot key combinations; in which case it changes the character to the left of the cursor (if that character is a recognized code - see the dialog for such codes).
<b>Conform indents</b> -- If the current file's line indents are partly or all tabs and you want only spaces for line indents, then this will do the change for you; and vice versa. Additionally, if you choose, it will remove all spaces and tabs which are at the ends of lines, as these serve no useful purpose and increase storage size.

<U>SEARCH MENU</U>
<b>Find, Find Again, Replace</b> -- The message boxes for searching and replacing are self-explanatory. Finds are marked with background colouring, which will disappear if you press 'Esc' (or if you save the text). <i>Useful point:</i>  In both the "search for:" and the "replace with:" text boxes, "\\n" stands for a line break, "\\t" for a tab, and "\\\\\" stands for literal "\\\" (only needed before letters 't' and 'n').
<b>List all Finds, Move to any</b> -- Displays all instances of a search text in a window, and then gives you the opportunity to focus any of them in the Assignments Window. If you invoke this menu item (or its hot key) while there is a selection, that selection will appear in the search dialog box.
<b>Insert / Go To Bookmark</b> -- Simply inserts remarked-out text "/**/" at the cursor; the second option hunts for same. If you use the hot keys mentioned there, what goes in is "/*n*/", where 'n' is a digit between 0 and 9.
<b>Insert / Go To Bookmark</b> -- Simply inserts remarked-out text "/**/" at the cursor; the second option hunts for same. If you use the hot keys mentioned there, what goes in is "/*n*/", where 'n' is a digit between 0 and 9.
<b>Remove All of One Bookmark</b> -- Use the hot key only. Removes every occurence of  "/*x*/" where 'x' is a digit between 0 and 9.
<b>Navigate Backwards / Forwards</b> -- try it out. Too hard to explain its intricacies. Will usually take you back to where you were editing before (several levels stored), and then back to where you are now.
<b>Which Occurrence of Word</b> -- If no text is selected, and the cursor is in or beside a string that would qualify as an identifier (letters, numerals and/or '_' only, and not starting with a numeral), then a message will pop up, telling you which occurrence of that word this is, and how many occurrences there are throughout the whole text. If text <i>is</i> selected, the same will occur, except that the search will be for all occurrences of exactly the text that is selected, with no reference to what characters are around that occurrence.
<b>Go To Nth. Occurrence</b> -- If no text is selected, and the cursor is in or beside a string that would qualify as an identifier (letters, numerals and/or '_' only, and not starting with a numeral), then this will take you to the Nth. occurrence of that string in the text (including occurrences in remarked-out text). You can return to the original cursor position using N = 0. If text <i>is</i> selected, the same will occur, except that you will go to the Nth. occurrence of exactly the text that is selected, with no reference to what characters are around that occurrence; and the newly found text will in this case also be selected (unless N = 0).
It is much more convenient to use the hot keys for this (as indicated on the menu - cntrl-1 to cntrl 9; then for 10th to 19th occurrences, cntrl-alt-0 to 9. Cntrl-0 brings you back to the original cursor position).
<b>Go to this function's Declaration</b> -- If the cursor is at an identifier (as for the above two items), and if this identifier happens to be the name of a user function, then focus changes to that function declaration (in midscreen), with the cursor at that function's name. As with the menu item above, Cntrl-0 will bring you back to your original line, provided that the cursor is at the function name before you press Cntrl-0. 
<b>Go To Screen Position before Last Run</b> -- Useful where an error or break point interrupts your program, taking focus away from where you were working on code to the line of the error or break point. This gets you back to where you were working.
<b>Find Line By Number</b> -- Finds the line (or rather the paragraph) by its number, the first paragraph being '1'. Remark paragraphs are included here.
<b>Show / Hide Line Numbers</b> -- Normally off, when 'on' this causes the current cursor line to be shown in red in the space just above the Assignments Window.
<b>Colour-Match of Braces / Brackets / Square Brackets</b> -- Applies a highlight colour to the chosen type of brackets, the colour depending on the bracketting level. The base level is black. The braces or brackets continue to be highlighted until you press ESC. Note that every time you add a bracket / brace while the display is on, all the bracket / brace colours throughout the text are immediately adjusted accordingly. (Not true for square brackets, as not needed.)
<b>Mark Text between Braces / Brackets / Square Brackets</b> -- Whichever bracketting level contains the cursor has all of its text highlighted (using the same background colour as for 'Find' menu finds). As with the previous item, highlighting persists till you press ESC.

<U>APPEARANCE MENU</U>
<b>Indent / Unindent Selected Lines</b> -- You must first highlight the lines in question, in their entirety (i.e. not starting the highlight halfway through a line); the covered lines will then either be prefixed with one TAB character ('indent') or else have one leading TAB character removed, if present ('unindent'). The shortcuts are Control-Shift-'>' (indent) and Control-Shift-'<' (unindent). (Obviously this system only works properly if you use tabbing rather than spaces for your indenting.)
<b>Remark-Out Selected Lines / Undo [same]</b> --  Usually used to temporarily 'remark out' a few lines of code. As above, the highlight should start at the start of a line; in any case, the first "//" will be inserted where the highlight starts.
<b>Toggle Remarks-Colouring System</b> -- rarely needed, but useful if you are editing ordinary text rather than a program, and don't want any colouring of text to be triggered by cues accidentally present in that text.
<b>Toggle Markup Tag System</b> -- If you are editing text other than program code, and want to invoke formatting effects like bold type and different font colouring, you would use this option. Details of the syntax of the HTML-like markup tagging system can be found by entering the word 'format' into the Assignments Window and keying F1; or by consulting main menu item "Help | Formatting with Text Tags". You can determine where the display will return to, after you revert to the normal display. If, in the formatted display mode, you make a selection, then when your return to normal mode the line of the selection will be not far off the centre of the window. On the other hand, if you don't make a selection, then the return to normal mode brings you back to the place in the file that you were at before invoking formatting mode. 
<b>Change Appearance - Colours / Fonts</b> -- Changes will apply for the duration of the present <i>MonoMaths</i> run. If you want them to apply for evermore, you have to save them in the INI file; to do this, click on menu item "File | Save Settings for Future Runs". BUT be sure you back up the INI file before messing with it. (If in the future you change your mind and want to reinstate some particular old colour or font, the old INI file is humanly-readable, so that you can easily read off the values needed to reset that one item.)
<b>Toggle proportional font</b> -- On the first toggle, this stores the current font name and then converts the font of the Assignments Window to a proportial font (i.e. one in which every letter has exactly the same width). The next toggle reverts the Assignments Window to the original font.
<b>Colour Selector</b> -- Produces a message box with a 'colour button'. If you click that button you see the colour-selector that comes with the Mono language. If you want to start with a particular colour, enter its details into the text box part of the message box and click on the 'SET' button. Once you have chosen a colour, click on the 'FINISH' button. The outcome will be a line in the Results Window which gives the colour's RGB description in both hexadecimal form and three- integer form; if this colour is listed in the approximately 140 named colours stored internally, that name will appear there also. Finally there is a short text in the chosen colour.  

<U>SHOW MENU</U>
<B>Function Arguments</b>  -- If the cursor is inside the opening bracket of a function's argument section, and less than 50 characters beyond that bracket, then the Results Window will show the arguments needed for the function. If it is a system function, a very brief explanation of argument usage is also shown there. If a user function (one that you have written in your program), it will show any remarks that you placed above your function definition, as long as those remarks are in contiguous lines starting with "//" and are immediately above the function definition.
	This option has been adapted to show C-like program functions/methods as well, if they begin with one of the keywords 'public', 'protected' or 'private'. This allows the menu option to work while editing non-MonoMaths program code of C-like syntax.
<B>Function Code</B> -- Invoked as above (with the cursor inside the argument brackets). If this is a user function, the entire function will be displayed in a message box (though you can't edit it there). If a system function, nothing should happen; but if perchance you are using one of my computers, it will most likely display the internal C# code for the function.
	This option has been adapted to show C-like program functions/methods as well, if they begin with one of the keywords 'public', 'protected' or 'private'. This allows the menu option to work while editing non-MonoMaths program code of C-like syntax.
<b>List Assigned Variables</b> -- Lists alphabetically all currently assigned variables in a box at the right side of the screen, together with their values (in the case of arrays, only their first six values). Scalars are in blue, arrays in red. If the program has paused or crashed while focus was inside a user function, the variables of that function will be displayed first, then the main program's variables. If you drag the box elsewhere or change its dimensions, the changes will persist for the next time you invoke this menu item, during the current run.
<b>System List Contents</b> -- As long as you know the identification number of the list, you can view its contents with this option. (A similar menu item for variables is not needed, as you need only place the cursor at the variable name and key F1 for display.)
<b>List All Functions</b> -- Lists all user functions in the program code, together with any lines immediately preceding which start with "//". For a function to appear on this list, the declarative word "function" (or the symbol "//" of an associated remark line) must be either at the start of the line, or only separated by spaces and/or tabs from it.
As a bonus, this display shows you the total number of calls to each function during the latest run (if there has been any run since the program was loaded). This number appears in square brackets after the function declaration. 
If you highlight the name of a function in this display (e.g. by double-clicking it), then when the dialog box is closed, focus will be at that function's declaration.
<B>Unused Variables</B> - When you have completed some large program and it is running well, you may want to clean up by checking for variables that you defined but never used, or stopped using after a revision. This will identify and list such variables.
<B>Run Durations</B> - If you click on this, then the duration of the last run will be printed in the Results Window, and so will the duration of all future runs till you re-click this menu item. If using this to time a program, realize that NET uses a 'garbage collector' to remove arrays and strings from memory after they have ceased being used; this garbage collector can strike at any time, quite unpredictably, and causes consecutive runs of the same code to take differing times. Also the first run after starting MonoMaths takes a little longer. So time three or four runs of your code in order to get a reliable estimate of how long it takes to complete its job.
<b>Array Memory Usage</b> -- Lists the arrays currently defined and the amount of space they occupy in terms of 'values'. Multiply by 8 to approximate the number of memory bytes occupied. 
<b>Pnemonics Currently Loaded</b> -- Pnemonics are short texts - typically 2 or 3 letters - which can be expanded into larger texts; for example, you could make a pnemonic 'for' which would expand into a four line 'for' loop statement, complete with braces, placing the cursor on the line between the braces. When MonoMaths is installed, a sample file of pnemonics is stored in a file 'Pnemonics 1' in the same directory as the program 'MonoMaths.exe'. This should load automatically at every start of MonoMaths. To invoke a pnemonic, one enters the cue (e.g. 'for' in the given example), and then keys control-N. To write a pnemonic, open that file and edit it; the formatting rules are in the header of the file. You are not restricted to using that particular file name; but if you change it, or its location, you will need to change the corresponding line in the INI file "MonoMaths.INI", which is in the same directory as "MonoMaths.exe". This menu item 'Show Pnemonics' will produce a message box listing the currently active pnemonics. (See also the comments above re menu item 'File | Reload Pnemonics'.)

<U>RUN MENU</U>
<b>GO</b> - same effect as clicking the GO button, or the hot key F5.
<b>Toggle Break Point</b> -- To put a break point in your program, put the cursor on the required line (which obviously must be a line holding code) and click this menu item (or press the hot-key combination). The line will acquire a highlight colour specific to break points. When you run the program it will halt at this line - and the highlight colour will darken (to distinguish the line from other break point lines) - while you test variable contents. To resume action, click the 'GO' button (or key F5). You can insert or remove break points even during the program run, e.g. when stopped at one break point. (A hint: better not to use on a line with '}' somewhere in it. If, for example, this '}' ended an 'if' section, the break point would operate whenever the 'if' condition was evaluated, whether it evaluated as TRUE or FALSE.)
<b>Remove All Break Points</b> -- does so. (Note that 'control-Escape' also removes break points - along with other colour tags; 'Escape' by itself leaves break points while removing those other tags.)
<B>Kill Current Graphs</B> - If your last run generated lots of graphs, they will normally remain on screen till the next run, or until you close down MonoMaths. To get rid of them otherwise, slaughter them all together using this menu item (a bit easier than closing them one by one).
<B>Don't Clear Results Window at "GO"</B> - Normally each run of your program starts by wiping the Results Window clean. If you don't want this, click on this menu item, which will retain all results from successive runs, so that you can scroll back through them. The setting remains until you cancel it by the same menu item.
<b>Abort Run</b> -- Does precisely what the ABORT button does; but occasionally a runaway graphing program may so cover the screen with rapidly proliferating graphs that you cannot access the menu, or even the task bar item for MonoMaths (as each graph packs its own item in there). Your only hope, apart from crashing Linux, is to use the hot key given by this menu (cntrl-F5).
<b>Show Sequence of Function Calls</b> -- shows details of the most recent user function calls in the last run of the current program. You can alter the number of function calls which the internal log will hold by means of a button in the display (labelled 'lengthen'). 

<U>YOUR HIDDEN CUSTOM MENU</U>
You won't normally see this menu, but it secretly exists, waiting to be invoked by your code. If you enter the word 'menus' into the Assignments Window and then key F1, you will be shown the three functions which allow you to generate this menu and (if desired) lots of submenus. Once generated, it will show up, bearing whatever name you have given it. (Clicking on the menus doesn't 'raise an event' - that is, it doesn't interrupt whatever else the program is doing. All it does is set a flag; your code has to check every so often - say, every half a second - as to whether any submenu has been clicked, and if so, then determine which one was clicked, and respond in whatever way your code decrees.)

<U>HELP MENU</U>
If you have managed to invoke this display then you don't need any help with this one.

<U>TECHNICAL MENU</U>
<b>Version</b> -- Just tells you the MonoMaths version which you are using and the date of its creation.
<b>Internal Data</b> -- Not meant for the user; used for trouble-shooting MonoMaths itself. It has been left available so that in the event of an inexplicable error, the contents of this display can be copied and pasted into a file, which can be passed on to the unfortunate programmer for analysis (along with the user program).
\tOh well, if you must know, here is a little bit of explanation. Ignore the first long section ( a list of assignments), which I can't explain without writing an awfully long essay on how the program works. Look rather for the later sections labelled "Variables (Fn. level n)". The main program is 'function 0', and all your functions (in the order in which they occur in the text) are numbered from 1 up. Each variable is represented by a line with four headers: name, use, X, ptr. Use is 3 for assigned scalars and 11 for assigned arrays. X is the current value (if a scalar) or 0 (if an array). Ptr, for arrays, points to the slot in memory where the data is stored (and it is listed for you, much lower down still, under 'Array Storage', where the 'slot' number corresponds to the Ptr value here). For scalars, Ptr is always zero. Array listings also provide obvious dimensioning data.
\tBe warned! If your program is huge with a large amount of data within many arrays, MonoMaths will appear to freeze for a long, long time, before it finally wheezes out with the data. Test it on programs generating smaller amounts of data first, to see how it goes on your supercomputer.

<u>EXPERIMENTAL MENU</u>
Only there for the programmer - i.e. me. I test out new C# routines (e.g. new menu actions) by putting them in an experimental zone which is activated by the menu. It would usually do nothing in a distributed version (unless I forgot to erase some test code).

==========================================================
//PNEMONICS (MACROS)//
<just c><B>CREATING AND USING A FILE OF SHORTHAND PNEMONICS</B>

<just l>Suppose you get sick of typing "writeln(neat(" all the time to examine matrixes. You could prepare a pnemonic "w", as below, to stand for that piece of text. You invoke it by typing "w", and then pressing <B>control+N</B> while the cursor is immediately to its right; the "w" will be replaced by the expanded text.

What happens is this. Whenever you press control+N, the program searches back through the 20 characters to the left of the cursor and looks for a pnemonic. It stops looking as soon as it finds any character other than a letter, a number or an underscore. If it has found some text, it checks that against its list of pnemonics. If it is not identified, nothing happens. Otherwise the replacement occurs.

<# grey>Small print: There is a second keypress, control+shift+N, which behaves a bit differently; see the end of this page for details.<# black>

Pnemonics don't come with the program; you have to write your own file of them. (You can certainly use MonoMaths itself to write and edit that file.) Go about it as follows.

1.  Start a new text file - say, with a name like "Pnemonics_1".

2.  Add the pnemonics, in accordance with the rules given below.

3.  Edit the file "MonoMaths.INI" - which is always in the same directory as "MonoMaths.exe" - and put in <I>exactly</I> one of these two lines, somewhere in the file:
<# blue>PnemonicsFileName=Pnemonics_1
<# black>Or, if the pnemonics file is not in the same directory as MonoMaths.exe,
<# blue>PnemonicsFileName=C:/Here/There/Pnemonics_1

<# black>4.  Start up MonoMaths, and then try typing in one of the abbreviations stored in the file. (If you were using MonoMaths itself to fix either or both files, you will have to close it down and restart it first.)

Once such a pnemonics file exists and is recorded in MONOMATHS.INI you can edit it in a future instance of MonoMaths, save it, and then make it operational in the same instance by means of menu option "Other | Reload Pnemonics". 


<U>RULES FOR THE PNEMONICS FILE</U>
When writing a pnemonics file you can use the three types of remarks in exactly the same way as you do with a MonoMaths program.

Lines which set pnemonics must look like this:
<# blue>w = writeln(neat(<# magenta>  // Add remarks like this at the end, if you wish.
<# black>In this case, the pnemonic is 'w' and its expansion is "writeln(neat(".
Note - Blanks around this '=' sign are ignored, as are blanks at the end of the line (before any remarks). However internal blanks in the expansion are retained. (Any subsequent '=' is taken as part of the expanded text.)

The pnemonic (LHS) must consist only of characters that you would use in MonoMaths for a variable name - letters, numerals and the underscore. The comma (alone of punctuation marks) is also allowed. On the other hand, any printable characters can be used for the expansion (RHS).

Some special codes can be used in the replacement text:
<bullet>"\<CR>" stands for a paragraph mark, so will give you a new line.
<bullet>"\\t" stands for a tab.
<bullet>"\<#>" is null; it is used to separate two characters which otherwise would be parsed as having special meaning.  For example, to output the remarks double-slash you enter "/<#<#>>/" (because the Pnemonics parser ignores anything in a line after a double-slash). Also, "\<^>" has a special meaning to the parser (see below); so to fool the parser for the formatting tag for superscripting, use  "\<\<#>^>".
<bullet>"\<_>" is a space; it is used if you want to start or end the replacement with one or more spaces. (If you just type in spaces, they will be removed by MonoMaths when the pnemonics file is read in.)
<bullet>"\<IN>" is used where you wish to preserve the indent which applied to the pnemonic itself. It is <I>only</I> meaningful if you are using TABS to indent, rather than spaces. It is a combination of an indent and a line feed. For example, if you define a pnemonic 'a' as: "a = A<IN>B", then in program code 'a' would be replaced by A, then a line feed, then B appearing immediately below A, with the same total indent as A.
<bullet>"\<^>" performs in two different ways:
<bullet 50,➯><i>If no selection</i>, the cursor will end up here, instead of at the default position at the end of the added text.
<bullet 50,➯><i>If there is a selection</i> which begins immediately after the pnemonic, then  whatever is selected will end up in the place indicated by "\<^>".
Examples:  Suppose a pnemonic 'bar' is matched with this expansion, in the pnemonics file: "\<i\>\<^\>\</i\>"; and in the text you have "barfoo...". Then, on invoking the pnemonic, and then switching MonoMaths to formatted display mode:
<bullet 30,1.>  If there is no selection, but the cursor is betweene 'r' and 'f',  you will see just "foo...", with the cursor to the left of 'f'; but later if you type there, the new text will be in italics: "<i>abc</i>|foo...".   ('|' represents the cursor's position).
<bullet 30,2.>  If 'foo' is selected, then the selected text will end up in italics, with the cursor at its right end: "<i>foo|</i>...".
<bullet>"\<0>", "\<1>", "\<2>"... - wildcards. Suppose the pnemonic is 'hy', and the line in the file is: "hy = sqrt(\<0>^2 + \<1>^2):" Then if, in your code, you enter "hy%side1,side2" - with no spaces anywhere! -  the variable names will be substituted, giving: "sqrt(side1^2 + side2^2):". (If you don't supply enough variable names, the excess wildcard symbols themselves will be printed.)
 "/<#^>/".
Here is a model file, which you would do well to copy and use as the starting point for your own version.

<# red>__ PNEMONICS 1
<# magenta>// THE BASIC RULES:
<# magenta>//  Basic format: Given pnemonic "gd" and its replacement "goodday", enter the paragraph: "gd = goodday".
<# magenta>//  Pnemonics can consists only of letters, numerals and the underscore. Replacements on the other hand can have any printable characters (including further '=' signs).
<# magenta>//  Spaces are allowed (except in the pnemonic itself), but are removed except for those inside the Replacement text. (Spaces at its end are ignored.)
<# magenta>// When looking for a pnemonic, the program only checks 20 characters prior to the cursor; pnemonics must therefore be smaller, esp. if the '\<IN>' indenting option is used
<# magenta>//    (see below), as program line tabs must be included in the extracted text.

<# magenta>// SPECIAL SYMBOLS in the pnemonic expansion (i.e. the part after the '='):
<# magenta>// "\<CR>" stands for a paragraph mark.
<# magenta>//  "\\t" stands for a tab.
<# magenta>// "\<IN>": Suppose that there are M tabs betwen the start of the paragraph and the pnemonic; the program will discover this, and
<# magenta>//     then wherever you have inserted  "\<IN>" in the pnemonic expansion, it will replace this by a paragraph mark followed by M tabs. 
<# magenta>//     The effect of e.g. "A\<IN>\\tB\<IN>C" will be three lines, with C (3rd. line) aligned with A (1st. line), and B (2nd. line) indented once beyond them.
<# magenta>//     This symbol will be useless if you have used space indenting rather than tab indenting, as it only counts tabs.
<# magenta>// "\<^>" will place the insertion point at that location, after the replacement has occurred. (Normally it would be at the end of the replacement.)
<# magenta>//  "\<#>" is a null; use it e.g. to enter "//" without this being parsed as a remark cue: enter "/<#>/" instead.
<# magenta>// "\<0>", "\<1>", "\<2>"... - wildcards for variable names. Suppose the pnemonic is 'hy', and the line in this file is: "hy = sqrt(\<0>^2 + \<1>^2):" 
<# magenta>//     Then if, in your code, you enter "hy%side1,side2" - with no spaces anywhere! - the variable names will be substituted, giving: "sqrt(side1^2 + side2^2):".
<# magenta>//     (If you don't supply enough variable names, the excess wildcard symbols themselves will be printed. Wildcards must be numbered from 0 up.)

<# blue>p = pause(); /<#>/ <<==========  <# magenta>// a 'pause()',  pointed to by a long arrow as a remark.
<# blue>if = if (true)\<IN>{\\t\<^>\<IN>}\<CR> <# magenta>// a 3-line structured 'if' statement. (The final \<CR> ensures that there is at least one blank line after it.)
<# blue>wn = writeln(neat( \<^> ));  <# magenta>// the cursor will end up between the brackets of the 'neat()' function.
<# blue>plot = plot(\<0>, \<1>, '.', 1, 'blue', '_', 1, 'blue'); <# magenta>// a very standard 2D plot. Enter e.g. "plot%yy,xx" into program code.


<# black>If we use this file, the following will happen in the Assignments window. (The final cursor position is represented by "<# red>|<# black>".)

\t\t<# blue>p

<# black>After keying control+N with the cursor just to the right of the 'p', we end up with:

\t\t<# blue>pause(); <# magenta>// <<==========<# red>|

<# black>Similarly, if we start with this:

\t\t<# blue>if

<# black>it will expand to:

\t\t<# blue>if (true)
\t\t<# blue>{\t<# red>|
\t\t<# blue>}

Finally,

\t\t<# blue>wn

<# black>will expand to

\t\t<# blue>writeln(neat( <# red>|<# blue> );
<# black>
			____________________________________________

<u>Second hot key - Cntrl-Shift-N</u>
This behaves a bit differently to Cntrl-N, if there is no selection. (If there is a selection, there is no difference in operation.) Suppose you have set up "bb" to produce "\<b>\<^>\</b>". Then you have a paragraph "bbThe cat sat on the mat.". If you move the cursor to just after "bb" and do this new hot key, "The cat sat on the mat." will all go bold, AND the cursor will end up at the end of that paragraph. This one saves a few keypresses when you are writing passages that use a lot of pnemonics, but is hardly worth it if you just use the occasional pnemonic.

==========================================================
//SELF-ALTERING PROGRAMS//
<just c><B>PROGRAMS THAT ALTER THEMSELVES</B>

<just l>This programming facility gives you wondrous possibilities to completely stuff things up. On the other hand, used carefully and properly, it allows one to experiment with evolutionary programming - the purpose for which it was created - and no doubt much else.

Please note - <I>MonoMaths</I> is <I>not</I> a text editor, and there are no plans to make it one. From the point of view of text manipulation, what follows would be very clumsy for a text editor; it is intended strictly for the purpose of self-modification by programs.

<U>HOW IT WORKS</U>
You do not actually alter the text of the currently running program; instead you take its text, alter it how you wish, and then programmatically force it to run in place of the currently running program. You only click on 'GO!' once; the original program then runs, makes the text changes, then sends those text changes back to the routine that handles a 'GO!' click, which responds by stopping the original program and in its place running the text handed to it.

It would be pretty destructive and pointless to change the whole text of a program; normally you would set aside a special region in the program where changes are to occur. To delineate that section you use <B>bookmarks</B>.


<U>BOOKMARKS IN THE TEXT</U>
There is no specific syntax for a bookmark; any valid part of a program can be used <B>except</B> anything in remarks. (In what follows, bookmarks will be coloured green.) A good idea is to use a number between semicolons. For example, to delineate passage 1, you might put it between a bookmark <# green>";1;"<# black> at the start and <# green>";-1;"<# black> at the end. (The program will think these are valid program steps, and will set these values to internal variables; but that is no problem.) You can also use a meaningful name, provided a variable with that name has been defined: "<# blue>secn_1=0; ... <# green>;secn_1;<# blue> ...<# black>". The variable's value will not be changed. Or you can make the definition itself the bookmark: "<# green>;secn_1=0;<# blue> <section one text>  <# green>;secn_1=1;<# blue> ...<# black>"

<U>OPERATIONS ON BOOKMARKED TEXT</U>
<B>Copying the changeable section of the program:</B> 
Use "<# blue>arr = <B>pgm_copy</B>(Bmark1, Bmark2);<# black>". The array 'arr' will now hold the unicode values of the text between (but not including) the bookmarks. You can use scalars (character locations) instead for either argument; for example, if you want to copy the <I>whole</I> program into array 'pgm', you would use: "pgm = pgm_copy(0, 1e6);" (If the second argument is too big, as here, it is downsized to the end of the program text.)  (This function takes two further optional arguments: a third is nonzero if you want the first bookmark to be part of the copied text; a fourth is nonzero if the second bookmark is to be copied.)

<B>Modifying the extracted text:</B>
Use standard functions that operate on arrays, for example: 
<bullet><B>copy(.)</B> and <B>copyto(.)</B> copy some portion of the extract.
<bullet><B>replace(.)</B> and <B>replaceto(.)</B> replace some portion of the extract with other text.
<bullet><B>insert(.), delete(.), deleteto(.)</B>.


<B>Grafting the modified text back into the program:</B>
Use "<# blue>newpgm = <B>pgm_graft</B>(ModifiedText, Bmark1, Bmark2);<# black>". The array 'newpgm' will now hold the whole program, with the new portion ModifiedText replacing what was previously between the bookmarks. (The same optional arguments can be at the end; if both were nonzero, the effect would be to eliminate bookmarks from the new program.)


<U>RUNNING ANOTHER PROGRAM FROM THE CURRENT ONE</U>
With the function <B>run(.)</B> you can either run the altered program text as above, or load a file and run it (if it is a <I>MonoMaths</I> program).
<B>Running a file:</B>  <# blue>run(FileNameAsArray, "F");<# black>  This will load the file into the Assignments Window, and then run it as if you had clicked on 'GO!'. The new file name will appear in the form header. Of course the program crashes (with a message) if the file can't be found or loaded. (If it is not a <I>MonoMaths</I> program, no doubt you will be rewarded with some weird and wonderful parsing or runtime message.)
<B>Running text:</B>  <# blue>run(PgmText, "T");<# black>  This will load the text which you supply in PgmText into the Assignments Window and attempt to run it. The form heading will not change; it will still have the original file name displayed there.
<B>Running a program 'quietly':</B>Use with great care! This usage is intended mainly for research situations where you may be running a sequence of evolving programs, and don't want time wasted with the displaying of text in the windows. The downside is that the Assignments Window will still hold whatever text it held before the 'quiet' run. This mode is instituted by using "TQ" or "FQ" for the second argument of function run(.).

One way around the display problem is to use a condition in your program; for all runs but the last, the second argument will be e.g. "TQ"; but for the final run, it will be "T".

If you just want to <B>load a program but not run it</B>, use <# blue>pgm_load(..)<# black> with the same arguments as "run(..)" - except that the "TQ" and "FQ" options do not work (there is no point in just loading a program, if it is not to be visible.)

Another function which can be used to run one program from another is <b>exec(.)</b>. This is especially valuable if you are going to have programs calling each other all day on some amazingly large project; sadly, despite all my efforts to date, memory leakage does occur, so that if 'run(.)' is being called a large number of times operation will gradually get slower and slower, and may (after many hours) grind to a halt. Function <i>exec(.)</i>, usually followed by "kill_on_exit();  exit;" (to shut down the current instance), will give you a clean sheet of memory each time.


<B>EXAMPLE</B>
Here is a simple model, from which more complex arrangements can be built. Explanatory lines are long, so you should drag this form's borders out with the mouse in order to keep remarks on single lines.

<# magenta>// SELF-ALTERING PROGRAM. There is a library of five program steps, packed in function Chameleon, all modifying 
<# magenta>//  the value of a single variable 'a'. The task of the sequence of runs - using a random search - is to find that order 
<# magenta>//  of the steps which produces the highest final value for 'a', given an initial value of 2. 
<# magenta>// Run the program, which will cause the screen to flicker away for some seconds as it continuously rewrites itself.
<# magenta>//  Eventually it will stop, but as the code in Chameleon is randomly generated the code in the final program will be
<# magenta>//  most likely very suboptimal. Go to the program's current directory and look for a file "fooxx.txt", where xx will 
<# magenta>//  be a number. There should be more than one; the one with the highest number xx will hold the best result to date. 
<# magenta>// The result will be printed in the file's first line; the maximum possible result is 3599, often reached with 100 trials.
<# magenta>//----------------------------------------------------------------------------------------------------------
<# magenta>// SET UP THE LIBRARY

<# blue>array library; <# magenta>// Will become a jagged matrix, as we add row by row below.
<# blue>jagger(library, 'A',  text("  a = a + 3;",10),  -1, -1, '#'); 
		<# magenta>// lines will end up in the 'volatile section', so for readability there supply a line indent and a final line feed.
<# blue>jagger(library, 'A',  text("  a = a - 1;",10),  -1, -1, '#');
jagger(library, 'A',  text("  a = a^2;",10),  -1, -1, '#');
jagger(library, 'A',  text("  a = a * 2;",10),  -1, -1, '#');
jagger(library, 'A',  text("  a = a*6;",10),  -1, -1, '#');

<# magenta>//----------------------------------------------------------------------------------------------------------
<# magenta>// SERVICE THE RUN SEQUENCE COUNTER, which is stored in index 0 of list 0. It starts at 0 for the first run, and then 
<# magenta>//  is incremented at each run. The sequence ends when a certain number of runs has occurred.
<# blue>if (list_size(0) == -1) { lists_new(2); } <# magenta>// Must be the first run. Two lists are needed; the second is used further down.
<# blue>if (list_size(0) == 0) { list_add(0,0); }  else { list_alter(0, 0, list(0, 0)+1);  }
<# magenta>// NB! If the last run program had called 'lists_preserve()', you are in trouble!
<# magenta>// ======== THE VOLATILE SECTION ==============================================
<# magenta>// Volatile text is entirely stored within the following user function. 
<# magenta>// It is left blank for the first run, which is a dry run that sets up Chameleon ready for the second run.
<# magenta>// NB - You never fill in the text between the bookmarks! Leave it to the program itself to do this.
<# blue>function Chameleon(a)
{;1;


;-1;
return a; }
<# magenta>// WARNING! It is a terrible sin to refer to these bookmarks, even in a remarks section, until AFTER the volatile section,
<# magenta>// because the function 'pgm_graft(.)' below will look indiscrimately for their FIRST instance, and place code there!
<# magenta>// ======== END OF THE VOLATILE SECTION =========================================
// CONVENTIONAL PROGRAM RUN. For the first dry run, all that is done is to set the initial value of what
// will later be returned by Chameleon, ready for future comparisons. Subsequent runs actually run Chameleon.
// This value is stored in list 1 (1,0).
<# blue>isFirstRun = (list(0,0) == 0);
<# blue>if (isFirstRun) {list_clear(1);  list_add(1, 0); } <# magenta>// First run: put here a ridiculously low value, which Chameleon will easily beat.
<# blue>else
<# blue>{	x = Chameleon(2);  <# magenta>// RUN THE VOLATILE CODE, always with the same argument 2.
	<# blue>if (x > list(1, 0))
	<# blue>{	list_alter(1, 0, x); <# magenta>// Chameleon returned a bigger value, so store that value, and save this instance of the program.
		<# blue>pgm = data("/","/ Chameleon returns ", str(x), 10, pgm_copy(0,1e6) );	 <# magenta>// The pgm. will be headed by the Chameleon score as a remark.
                         <# magenta>//  NB - you can't write 'data("//", ...), as the parser would regard all after the "//" as a remark!
		<# blue>pp = text("~/MonoMaths/Data/foo", str(list(0,0)), ".txt"); <# magenta>// Saved instances will take the form e.g. "foo23.txt" (for instance 23).
		<# blue>save('T', pgm, pp, 'O');
	}
}
<# magenta>//-----------------------------------------------------------------------------------
<# magenta>// FILL THE VOLATILE SECTION FOR THE NEXT RUN:
<# magenta>// Here we use a simple randomizer; in such a small space (120 possible arrangements of the volatile lines, some equivalent), 
<# magenta>// this is very adequate. Larger spaces would do better with more sophisticated space-searching techniques.
<# blue>lines = shufflemx(library, 'r'); <# magenta>// Returns the library matrix, but with rows randomly shuffled.
<# blue>voltxt = data(10, cull(lines, '#')); <# magenta>// Derives the new volatile text from that matrix. 'cull' not only sews the rows together but
		<# magenta>// also removes the padding character '#'. (The introductory line feed starts the code off on a different line to the first bookmark.)
<# blue>newpgm = pgm_graft(voltxt,  ';1;',  ';-1;'); <# magenta>// Removes whatever junk is currently between the bookmarks and places 'voltxt' there.
		<# magenta>// 'newpgm' now holds the entire next instance program.
<# magenta>//-----------------------------------------------------------------------------------
<# magenta>// SET UP THE NEXT INSTANCE AND RUN IT
<# blue>if (list(0,0) >= 100) <# magenta>// This last value is the preordained number of instances, after which the sequence will end.
<# blue>{	writeln("list 0: ",list(0), 10, "list 1: ", list(1));  exit;}
<# blue>else {lists_preserve();}<# magenta>// Causes the hold lists to persist for one further run (only). THE 'ELSE' IS VITAL; the final run of this
            <# magenta>// series of programs MUST allow the lists to be destroyed, for the sake of whatever program may next be run.
<# blue>run(newpgm, 'T'); <# magenta>// This eradicates the current instance, writes the new instance 'newpgm' into the Assignments Window,
				<# magenta>// and then runs that next instance exactly as if you had loaded it there and then clicked on 'GO!'.<# blue>
==========================================================
