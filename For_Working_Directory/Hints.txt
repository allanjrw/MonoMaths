HINTS FOR MINIMATHS

This file must be saved as the file 'Hints.txt', in the same directory as the program itself.
*** View this introduction outside of a text editor mode which processes tags. It is meant to be viewed exactly as written. ***

Each section must begin with an identifier line, e.g.: '//CATS AND DOGS//' (to identify the section entitled 'Care of your cats and dogs'). Note the introductory and final '//', with nothing else on the line (blanks before and after the '//' are significant).

Sections can begin with multiple lines beginning with '//', or even have such lines in the middle somewhere. Such lines will be searched for as above (but to be detected must be in capitals), and any further such lines will simply be ignored.

Each section must end with a line starting with '=======' (initial blanks ignored; at least 4 '=' needed).

Formatting instructions may be inserted, using a markup language not unlike HTML. The rules are given at the end of the file.
Example: 'aaa <U>bbb</U>  ccc' underlines bbb.

SPECIAL CHARACTERS:
Obligatory:
	To produce literal '<', '>', '\',   use "\<", "\>", "\\".
Optional, or occasionally necessary:
	You can use '\t' for tabs and '\n' for line feeds, but you wouldn't really need to, as the text editor inserts these for you.
	'\"' can be used for the double-quote; this is only necessary where that double-quote occurs within a tag.
Special printable characters (Greek symbols, maths symbols etc.) - see the end of this file - "FORMAT" section.

It is best practice to use '\<' and '\>' whenever you want to display literal '<' and '>' close together; if you don't, sometimes you will get repetition of segments of text overlaying each other, even though the actual '<' and '>' will be displayed correctly. (This is most likely to occur where you double them - e.g. you want to display ">>". For example, "The cat <<sat>> on the mat" will produce: "The cat The cat <The cat <<sat>> on the mat"; but "The cat \<\<sat\>\> on the mat" will produce what you intended.)

___________________________________

//ABS//
<B>ABSOLUTE VALUE</B>

<B>abs(x)</B> returns the absolute value of x.
===============================================================
//ADDPLOT//
//ANIMATE//
//ANIMATION//
//GFIXEDCLICK//
//GFIXEDVISIBLE//
//GRAPHKEY//
//GXMENU//
//GXVISIBLE//
//GXCLICK///
//LASTCLOSED//
//PIXELS//
//READGRID//
<just c><B>GRAPH FEEDBACK AND ANIMATION</B>

<just l>It is possible to get feedback from existing graphs (such as information about a mouse click or a menu click on the graph tablet). It is also possible to change the characteristics of existing graphs (such as the scaling, or the data being displayed). As a result, animation is possible. Examples of useful graph interaction will follow, but first we have to run through the available system functions. (The best way to understand their action is to copy and run the sample programs given below.) 

Note that every graph (the surface on which a set of curves is plotted) has its <B>unique 8-digit identifier</B>, never zero. You need this identifier in nearly all of the functions below. To obtain it, use 'graph(.)' or 'graph3d(.)' in a non-void manner:
<# blue><B>g = </B>graph(plot1, plot2, ...);  <# magenta>// where plot1 etc. are plot ID numbers.
<# black>
<U>FUNCTIONS WHICH PROVIDE FEEBACK FROM EXISTING GRAPHS</U>

<B>(a)  Graph menu-handling functions</B>
<B>lastclosed()</B> -- used to detect closure of a graph. If any graph has closed, this function will return its identifier (by reading an internal 'interrupt request' issued by the closing graph); if none has closed, it returns 0. A call to this function automatically resets the interrupt request, after reading it, so that a second call immediately afterwards would return 0. If you just want to check whether a particular graph still exists or not, it is better to use '<# blue>isgraph(graphID)<# black>', as 'lastclosed()' only provides the ID of the latest graph to close.

<B>gfixedclick()</B> -- used to detect clicks on submenus of the fixed graph menus ('fixed' meaning the ones that are there already; the user may add another menu item - see next section.) A chars. array is returned. Element [0] = a status indicator; [1] = time when the click occurred (milliseconds since the start of 1 AD); and from [2] to the end is what is written on the menu, but with spaces removed - e.g. a click on "Viewpoint | Move Left" will return the string "MoveLeft". If the status indicator is 1, there has been a new click since the last call to this function; if 0, then this was already handled by this function (though elements [1] up are unaltered.).
If the graph does not exist, the return is of size 3: { -2, -1, 32 } (the last being the space character). If the graph exists but no fixed menu's submenu has yet been clicked, the return is of size 3: { -1, -1, 32 }. 
This function does not respond to clicks on submenus of the user-added menu (see below), and also not to the 'File | Exit' submenu. 
<b>gfixedvisible(GraphID, array MenuName, bool Visibility)</b> --void; changes the visibility of the graph's <i>main menu items</i>. Only the first letter of MenuName is accessed (case-insensitive); this should be one of 'F' (File), 'Z' (Zoom), 'V' (ViewPoint), or 'S' (Scaling). You can only change the visibility of one item per function call, and you can't make individual submenu items invisible.

<b>Extra Menu:</b> In the graph's main menu there is a hidden menu item which the user can invoke, equipping it with up to 20 submenus (but at least one). This extra menu system is invoked with void function <b>gxmenu(GraphID, Title, Subtitles )</b>, where 'Title' is the title of the added main menu item, and 'Subtitles' is the accumulated titles of its successive submenus, delimited by '|'. E.g. <# blue>gxmenu(thisGraph, "Change Colour", "Red | Green | Sky Blue" )<# black> will produce a menu named 'Change Colour' with three submenus. Note that spaces at the start and end of titles are ignored, but internal spaces (as in "Sky Blue") are preserved. To change even one title or subtitle, or the number of submenus, you have to call "gxmenu(.)" again with all arguments, as if calling it for the first time. Empty titles and subtitles should be avoided. The function is not void, but <i>returns a boolean</i>, which is only ever false if GraphID could not be identified.
All submenus are automatically visible after the above. To alter visibility, use <b>gxvisible(GraphID, Visibility)</b>, where 'Visibility' is a set of values (in any mix of arrays and scalars). Its elements are nonzero ('true' - for 'make visible') and zero ('false' - for 'make invisible'). Visibility[0] applies to the main menu item, and Visibility[1+] to the submenus. If there are less argument values than menu items, only those addressed will have visibility affected. If there are more argument values, the excess will be ignored.
The function <b>gxvisible(.)</b> is not void, but always returns the final visibility state of all items as an array. So if you don't want to change the visibility of the second submenu but just want to read its visibility, use <# blue>arr = gxvisible(GraphID);<# black> and then test arr[2]. In the event that GraphID cannot be identified, the function returns an array of size 1, value -1.
To read clicks, use <b>gxclick(GraphID)</b>. This returns the index of the submenu clicked, and then immediately resets the internal flag raised for GraphID by that click, so that a second call to 'gxclick(GraphID)' would return -1 instead. If no click has occurred in the lifetime of the program, this function returns -1. If the graph cannot be identified, it returns -2. Note that submenus are <i>numbered from 1 upwards</i>, as they are for function 'gxvisible(.)'. Note also that this function does not detect a click on the main menu item itself.

<B>Other event-handling functions</B>

<B>arr = readgrid(g) </B> -- where 'g' is the tablet identifier. This returns exactly the array that you would use as an argument for 'grid(...)'. In other words, for the 2D case, the array has size 6, and is: [X minimum, X maximum, No. of X segments, Y minimum, Y maximum, No. of Y segments]; and for the 3D case, an array has size 9, the first 6 elements being the same, and the remainder being: Z minimum, Z maximum, No. of Z segments.
If graph 'g' doesn't exist,an array of size 1, value NaN is returned, and a call to 'empty(.)' would return TRUE.

<B>arr = pixels(g) </B> -- Returns an array of size 4. For 2D graphs, [0] = width of a pixel in terms of the X axis variable; [1] = height of a pixel in terms of the Y axis variable; [2] = number of pixels from left to right of the plottable surface; [3] = same, vertically. For 3D graphs, [0] and [1] are always simply 0, and [2] and [3] give the width and height of the blue-lined box which contains the actual 3D plot region together with the region to its right where descriptive data goes. If the graph cannot be identified, the return is { -1, -1, -1, -1 }.
<i>Caveat:</i>  If used after 'graphresize(.)', you have to allow time before calling 'pixels(.)', or you are given the sizes that predated the 'graphresize(.)' call. Insert a step like this:  "starttimer();  while (timer() < T) { dummy = 1; }", where T  is found by experiment. (On my current computer, T = 100 (msecs) is safe;  T = 40 to 60 fails some of the time;  smaller T always fails.)
<B>arr = pixels('screen') </B> -- Returns an array of size 2; [0] = the screen width, in pixels; [1] = the screen height.

<B>bool = newclick(g)</B> -- where 'g' is the tablet identifier. Simply returns TRUE (i.e. 1) if the particular graph has been clicked; the call to the function resets the flag in the graphing unit which signals the click, so that a second call immediately following would instead return FALSE. FALSE is also returned if the graph does not exist.

<B>mx = mouse( ...)</B> -- This gives information about where the mouse pointer is when a mouse button goes down, which button it is, and where the mouse pointer is when the button goes up again, and times. 

<b>graphkey(g)</b> -- Returns the latest keypress occurring while graph 'g' is in focus, and in the process removes the internal record of it. In fact, the internal record consists of a stack of the 10 latest keypresses; each call to graphkey(.) pops one keypress permanently off the stack.
The return is always an array of size 3: [0] is the basic key value, [1] is the helper-key combination code, and [2] is the number of unprocessed keypresses left on the stack after this call. (If no keypress since startup, or since all extant keypresses have been handled, the returned array is {0, 0, 0]. If 'g' does not exist, the return is [-1, -1, -1].)
More on [0]: This holds the value assigned by .NET to the key. Common ones: 'A' (or 'a') - 65; '0' - 48;  TAB - 9; Enter - 13;  Space - 32;  Arrows: left - 37, right - 39, up - 38, down - 40;  Cntrl - 17; Shift - 16; Alt - 18. (Use the code example below to get values for keypresses that you want to recognize.)
More on [1]:  Using abbreviations 'c'(ontrol), 's'(hift) and 'a'(lternate), the returned code (0 to 7) corresponds to the following helper key combinations:   0="", 1="a", 2="c", 3="s", 4="ac", 5="as", 6="cs", 7="acs".
Sadly the keying (if printable) will be printed in the description section below the graph, as this section is editable; but you can easily remove it with the 'delete' key, as in any other editable box. 
Run the following example code. Once the (empty) graph is in focus, do key presses, and see the results appear in the status bar below the Results Window (not on the graph itself). You may have to drag the graph away to see it. (Don't test the TAB key, as this will shift focus away from the graph's hidden textbox for key testing. But two further TABs would bring focus back there.)
\t<# blue> g = graph();  <# magenta>// Create and focus an empty graph.
\t<# blue>while (true)
\t<# blue>{\tif (lastclosed() ) break;  <# magenta>// End the program by closing the graph.
\t<# blue>\tarr = graphkey(g);
\t\t<# blue>if (arr[0])  label('C', "Base key: ", arr[0], 10, "Helper key combination code: ",arr[1]);
\t<# blue>}
<# black>
Although function <b>keydown(.)</b> is not specific to graphing, it can be useful, for example to detect whether or not a helper key is being held down when a mouse click occurs on the graph. (For example, you might want to decree that the nearest point is removed from the graph when you mouse-click with 'Cntrl' held down.) Here is some sample code:
<# blue>g = graph(); <# magenta>// Generate a blank graph
// Loop, waiting for mouse clicks
<# blue>while (true)
{	if (lastclosed() != 0) break; <# magenta>// The only way out of the loop is to close the graph.
<# blue>	if (newclick(g))
	{	ss = keydown(true); <# magenta>// Get the name of the key as a chars. array 
<# blue>		foot = "At the time of the mouse click, ";
		if (ss == "#0") foot = text(foot, "no key"); 
		else foot = text(foot, "the '",  ss,  "' key");
		foot = text(foot, " was being held down.");
		footer(g, foot);
	}
}		
<# black>For full information on 'keydown(.)' and the values which it returns, enter the function name into the Assignments Window and press F1. Also, note that the one key which will not work for the above code is the "Alt" key, as this is reserved by the underlying Gtk# environment for use with invoking graph menus.

<U>OTHER FUNCTIONS IMPORTANT IN RESPONDING TO GRAPH FEEDBACK </U>
(You'll find out why as we work through examples.)

<B>killplot(p1, p2...)</B> -- plots p1, p2..., if identified, are removed from memory, and from all graphs containing them.
 
<B>addplot(g, p1, p2, ...)</B> -- Void. If graph g can be identified, then plots p1, p2... are added to the graph (if in existence). No error is raised if graph or plot IDs are not identifiable. Any number of plot IDs can be supplied, as any mixture of scalar or array values. You would use this function in conjunction with <B>killplot(.)</B> to gradually move a point or curve or shape across the graph surface. Suppose your graph displays plot p1, and that you wish to make the plot slightly different, as the next step in an animation. You would devise plot p2 as the slightly different version of p1, and then call 'killplot(p1);  addplot(g, p2);'. The function applies to both 2D and 3D graphs. Duplication is not a problem; an attempt to add a plot already present in the graph is simply ignored.

<B>removeplot(g, p1, p2, ...)</B> -- removes the plots (if identified) from graph 'g'; but unlike 'killplot(.)', it does not remove them from memory or from other graphs; you could install p1, p2... into future graphs, if you wished. As with the above functions, any number of plot IDs can be supplied, as any mixture of scalar or array values.
NB: in animation sequences, <I>don't</I> use "removeplot(g,p1); addplot(g,p2);". The graph will show the animation just fine, but meanwhile hundreds of undestroyed and useless plots are filling up computer memory, which is indeed a Bad Thing!


<U>EXAMPLES OF USE</U>
<B>1.  A curve which moves to wherever on the graph you mouse-click.</B>
The graph is of y = x*x + C, where the constant C is initially 0, but is reset after mouse clicks such that the new curve passes through the point just clicked.

<# magenta>// Set up 101 X-values from 0 to 1, and corresponding Y values (X squared):
<# blue>xx=ladder(101,0,1);    yy=xx*xx;
<# magenta>// Draw the initial plot, using a nonvoid call to 'plot(.)', to get the graph no.:
<# blue><B>p = plot</B>(yy, xx);    g = graph(p);
<# magenta>// Enter a WAITING LOOP:
<# blue>while (TRUE)
{	if (<B>lastclosed()</B> != 0) { break; } <# magenta>// closing a graph sets this to the graph's identifier.
				<# magenta>//If you had more than one graph, you would use: " == p" as the condition instead.
	<# blue>if (<B>newclick(g)</B> ) <# magenta>// a click happened:
	<# blue>{	moo = <B>mouse(g)</B>; <# magenta>// Data re the latest click
	<# blue> 	clickX = moo[10]; clickY = moo[11];  <# magenta>// the point clicked by this latest click.
		<# magenta>// Find the nearest xx[i] to the click point:
		<# blue>n = place(xx, clickX); <# magenta>// find the first index i of xx[i] such that xx[i] <= xclick
		<# blue>if (n >= 0) <# magenta>// = -1 if could not place xclick
		<# blue>{	ydel = clickY - yy[n]; <# magenta>// vertical distance between curve and click point
		<# blue>	yy += ydel;
			killplot(p); 
			p = plot(yy, xx); 
			addplot(g, p); 
		}
	}
}


<# black><B>2. Simulation of Brownian Motion. All points start at the origin, then gradually move away by random walk.</B>
<# magenta>// Set up a population of points, all at the origin:
<# blue>NoBlobs = 200;
<# blue>dim(xx, yy, NoBlobs); <# magenta>// To compute new positions, we will use a random radius and a random direction.
<# magenta>// These will require the following further arrays:
<# blue>delrr = xx;  delang = yy; <# magenta>// radius and angle increments will be in these.
<# blue>delxx = xx;  delyy = yy; <# magenta>// XY coordinate increments will be in these
<# blue>Step = 0.01; // <# magenta>maximum step size for a blob
<# blue>grid(-1.5, 1.5, 6, -1.5, 1.5, 6);
<# magenta>//----------------------------------------------------------------------
<# magenta>// OUTER LOOP: Iterates every time the plotting arrays are updated.
<# blue>firstloop = true;   
p = 0; <# magenta>//  dummy declaration, so 'killplot(p)' won't raise a parsing error.
<# blue>while (true)
{	if ( not(firstloop) ) { killplot(p); }
	p = plot(yy, xx,   '.', 5, 'red', ' '); <# magenta>// Big red points, no connecting lines.
	<# blue>if (firstloop) 
		{ g = graph(p);   graphresize(g, 500, 500);  firstloop = false; } <# magenta>// Make the graph square, so the circle looks like a circle.
	else { addplot(g, p); }
	FrameReady = FALSE;
	TimeStep = 20; <# magenta>// millisecs between frames. (Once you go above a few hundred points, the time
			<# magenta>// taken for graphing will be longer than this, but this will not cause any problem.)
	<# blue>starttimer(1); <# magenta>// Sets timer '1' to 0 milliseconds. (timer no. can be 0 to 9.)
		<# magenta>// INNER TIMER LOOP: waits for the timer to count up from zero to TimeStep.
	<# blue>while (timer(1) \< TimeStep) <# magenta>// (If something goes wrong, so this loop
 		//  never ends yet no graph appears, remember to click on 'GO' to abort action.)
	<# blue>{	if (not(FrameReady))
		{	rand(delrr, 0);   delrr *= Step;    rand(delang,0);  delang *= 2*PI;
			delxx = delrr * cos(delang);   delyy = delrr * sin(delang);	
			xx += delxx;       yy += delyy; 
			FrameReady = TRUE; <# magenta>// You only need to recalculate the arrays once during the waiting loop. 
		<# blue>}		
	}
	if (lastclosed() == g) { break; } <# magenta>// Outer loop exit occurs when the user closes the graph.
<# blue>}

<# black>You could add a scale adjustment to the above. For example, once the outermost particle has an |X| or |Y| value exceeding the current axis limit of 1.5, you could use 'grid(.)' to zoom out.

<# black><B>3. Simulation of Brownian Motion in 3D. All points start at the origin, then gradually move away by random walk.</B>

<# magenta>// Random walk in 3D. Points are in a cube which has one corner at the origin, and side 1.
// Set up a population of points, all in the centre of a cube - i.e. at (0.5, 0.5, 0.5):
<# blue>NoBlobs = 20;
xx = fill(NoBlobs, 0.5);  yy = xx;  zz = xx;
dim(delxx, delyy, delzz, NoBlobs);  // increments will be in these.
<# blue>Step = 0.01; <# magenta>// maximum step size for each blob per loop.
<# blue>grid(0, 1, 5, 0, 1, 5, 0, 1, 5);
<# magenta>//----------------------------------------------------------------------
// OUTER LOOP: Iterates every time the plotting arrays are updated.
<# blue>TimeStep = 10; <# magenta>// millisecs between frames. (Actually once you go below around 50, the time taken
     // by graphing takes longer than this - on my computer, at any rate - but no problem arises.
<# blue>firstloop = TRUE;   
p = 0; <# magenta>// dummy declaration, so 'killplot(p)' won't raise a parsing error.
<# blue>while (true)
{	if ( not(firstloop) ) { killplot(p); } 
	p = plot3d(zz, yy, xx,   '.', 5, 'red', ' '); <# magenta>// Big red points, no connecting lines.
	<# blue>if (firstloop) { g = graph3d(p);  firstloop = false; } 
	else { addplot(g, p); }
	FrameReady = FALSE;
	<# magenta>// INNER TIMER LOOP: waits for the timer to count up from zero to TimeStep.
	<# blue>FrameReady = FALSE;
	<# blue>starttimer(1); <# magenta>// Sets timer '1' to 0 milliseconds. (timer no. can be 0 to 9.)
	<# blue>while (timer(1) < TimeStep) <# magenta>// (If something goes wrong, so this loop
	<# blue>{	if (not(FrameReady))
		{	rand(delxx, 0);   rand(delyy, 0);   rand(delzz, 0);   	
			delxx = Step*(2*delxx - 1);  delyy = Step*(2*delyy - 1);  delzz = Step*(2*delzz - 1);  
			xx += delxx;       yy += delyy;   zz += delzz;
			FrameReady = TRUE; <# magenta>// You only need to recalculate the arrays once during the waiting loop. 
		<# blue>}		
	}
	if (lastclosed() == g) { break; } <# magenta>// Outer loop exit occurs when the user closes the graph.
<# blue>}

<# black>In animation scenarios, note that you can <B>manually change the value of a main program scalar parameter during looping</B>. Stop the animation loop by clicking on the 'GO!' button, and then on the 'HOLD' button that appears. Animation is frozen. Then on the MiniMaths menu (not the graph menu), click on "Other | Change Value of a Scalar", and change the required value. Then reclick on the 'GO!' button; the animation loop resumes, now using the new value of the parameter for calculations.

===============================================================
//ALIAS//
//SETALIAS//
//GETVAL//
//SETVAL//
<just c><b>ALIASSING OF VARIABLES</b>
<just l>
Many programming languages allow you to set up a collection of objects of different types; for example, in the collection "Foo", "Foo[0]" might be scalar, "Foo[1]" a matrix, ... MonoMaths does not have that capacity yet (it is on the 'To Do' list), but the following system functions provide much of the functionality of such collections.

Suppose we have three variables - X (a scalar), Arr1, Arr2 (each array being of any structure). We can assign to each of them an 'alias' - that is, an integer value - which allows them to be indirectly accessed. We do this with the instruction <# blue>setalias(X, Arr1, Arr2)<# black>, which assigns 0 as the alias of X, 1 as the alias of Arr1, and 2 as the alias of Arr2. But you can only make use of these aliasses with two functions - <# blue>getval(Alias, ...)<# black> and <# blue>setval(Alias, ...)<# black>. "getval" allows you to access the whole value of the original variable, or - if an array - some segment of it. Similarly "setval" allows you to set the variable's value, or - if any array - some segment of it.

The bad news - the scope of aliassing is limited to the function in which it occurs (or to the main program, if that is where it is invoked). The variable aliassed must belong to that function, and also the alias only applies within that function.

Why use aliassing? The answer is - don't, unless you really need to, as indirect addressing takes longer to service, and has unlimited capacity for errors that may not be easy to track down. The sort of situation where I would use aliassing is where there are a number of arrays with different names, and where the one you access in any one circumstance depends on some index N. E.g. you might have arrays aa, bb, cc, dd, and index N = 0 to 3. Instead of writing "if (N == 0) aa[10] =.. ; else if (N == 1) bb[10] = ..", you would use "setalias(aa, bb, cc, dd)" followed by "setval(N, 10, ...)" with no need for an 'if' section.


<u>SETTING THE ALIAS</u>
<B>setalias</B>(<# blue>{any number of  variable names}<# black>) -- VOID. The variables must have been assigned before this function call. (In the case of arrays, no address component like "[1]" is allowed.) The variables must exist in the current function level. Constants and system variables cannot be aliassed.

The aliasses assigned to the variables are integers, always starting from 0 (for the first variable).

While you may use 'setalias' more than once in a function (or main program), a later call will completely negate all aliasses from an earlier call; the new aliasses will again start from 0.


<u>USING THE ALIAS TO GET VALUES</u>
In the case of scalars, <# blue>getval(N)<# black> will return the value currently in the scalar being accessed.
For arrays, <# blue>getval(N)<# black> will return a copy of the whole array, including its structure and characters rating.
To get just a segment of the array, use <# blue>getval(N, <address>)<# black>, where 'address' is  what you would put between square brackets if using the unaliassed variable. As an example, suppose that N is the alias for a matrix Mx'. The following will all return the same data:
<bullet><# blue>x = getval(N, 1, 2)<# black>	  and  <# blue>x = Mx[1,2]<# black>. ('x' will be a scalar.)
<bullet><# blue>xx = getval(N, 1)<# black>	  and  <# blue>xx = Mx[1]<# black>. ('xx' will be an array, one row of Mx.)
Where you want the whole of a column, and would use empty square brackets "[]" to indicate this, you instead use -1 (but no other negative number) - or MINREAL. These are equivalent:
<bullet><# blue>xx = getval(N, -1, 1)<# black>	  and  <# blue>xx = Mx[][1]<# black>. ('xx' will be an array, one column of Mx.)
<bullet><# blue>xx = getval(N, -1, -1)<# black>  and  <# blue>xx = Mx[][]<# black>. ('xx' will be assigned the whole of Mx.)
You can use 'getval(N)' as an argument of a function, as long as that function does not require a named variable (e.g. 'redim(.)' ).  An example of use would be
	<# blue>mx1 = appendrows( getval(0), data(16, 17, 18) )<# black>, where 0 is the alias of a matrix with row length 3.

<u>USING THE ALIAS TO SET VALUES</u>
<# blue>setval(N, ...)<# black> is a <b>void</b> function.
In the case of scalars, <# blue>setval(N, z)<# black> will cause the aliassed scalar to take on value z. (While the function will not crash if there are further arguments, only the first two will be accessed.)
For arrays, <# blue>getval(N, zz)<# black> will set the aliassed array to be a copy of zz (same structure and chars. rating), overwriting whatever prior value and structure the aliassed array had.
To set just a segment of the aliassed array, use <# blue>setval(N, <address>, Data)<# black>, where 'address' is what you would put between square brackets if using the unaliassed variable. As an example, suppose that N is the alias for a matrix Mx'. In the following pairs, both assignments will have the same effect on Mx:
<bullet><# blue>setval(N, 1, 2, x)<# black>	  and  <# blue>Mx[1,2] = x<# black>. ('x' is either a scalar or an array with only one element.)
<bullet><# blue>setval(N, 1, arr)<# black>	  and  <# blue>Mx[1] = arr<# black>. In both cases, 'arr' must have exactly the right length to fit a row of Mx.
Where you want the whole of a column, and would use empty square brackets "[]" to indicate this, you instead use -1 (but no other negative number) - or MINREAL. These are equivalent:
<bullet><# blue>setval(N, -1, 1, foo)<# black>	  and  <# blue>Mx[][1] = foo<# black>. ('foo' must have the length of one column of Mx.)

An example of use, extending the example given under 'getval': Suppose some matrix Mx has row length 3; the following appends an extra row to this original matrix Mx:
	<# blue>setval(0,  appendrows( getval(0), data(16, 17, 18) ) )<# black>.

===============================================================
//ALLOW//
//CONSTANT//
//CONSTANTS//
<just c><b>PROGRAM DIRECTIVES</b>

<just l>There are two statements which, if they appear at the very start of the program, modify operation. They are - 
<bullet>The ALLOW statement, which allows you to use special characters within identifier names (i.e. names of variables and of functions);
<bullet>The CONSTANT statement, which allows you to define program-wide constants. These behave just like the system constants mentioned above; in the same way, they can be called from within any function, but they can not be altered anywhere by assignments. (You cannot redefine an existing system constant using this statement.)

For each of the above directives:
<bullet>The statement(s) must precede all program code (though empty lines and remarks-only lines may precede or follow).
<bullet>The directive command must be at the very start of the line, with <i>no preceding spaces</i>.
(If using both directives, either may precede the other.)

<b>The ALLOW Statement -- Allow special characters in identifiers</b>
If you want to use unicode characters beyond unicode 127 as part of identifier names in some program, you can warn MonoMaths of your intentions by setting the <b>first data line of the program</b> to the word "ALLOW ", followed by a space, then the special characters you have in mind, all in the one paragraph. (Any characters after "ALLOW " which are ≤ unicode 127 will be removed from the line, so you are free to use punctuation and spaces, even interspersed comments.) A selection of such characters is available via the main menu option "Edit | Special Characters".
<u>Caveat:</u> Different fonts and operating systems may interprete unicode characters differently. A character that looks like an 'alpha' on your system might look like the Chinese logogram for 'crushed beetle' on someone else's computer!

<b>The CONSTANT Statement -- Define program constants</b>
More exact syntax is required. Follow the word "CONSTANT " and a space should come assignments separated by commas:
<# blue>CONSTANT PISQ = PI*PI,  FOO = 1.234,  BAR = sin(2*PISQ)<# black>
All the basic scalar mathematical functions can be used.


<b>Example of use of directives:</b>

	<# red>__ GREAT MATHS PROGRAM No. 1
	<# magenta>// This great maths program will do thus and so....
	<# blue>ALLOW  ρ,  π,  ²,  ε, √, ω
	<# blue>CONSTANT  π² = PI*PI,  √ε = sqrt(EE), ω = 1.23456 <# magenta>// You can add comments. A final ';' is optional.

	<# blue>ρ = 100;   Whatever = π² * ρ; <# magenta>// And no syntax error will be raised!<# black>

===============================================================
//ALLZERO//
//NOZERO//
<B>allzero</B>(<# blue>Variable [, scalar Tolerance ] <# black>) -- returns TRUE (scalar value 1) if ALL elements of Variable are zero. If there is a 2nd. argument 'Tolerance' and it is positive, a 1 is returned if all elements in Variable have absolute values <= Tolerance.

<B>nozero</B>(<# blue>Variable [, scalar Tolerance ] <# black>) -- returns TRUE (scalar value 1) if NO element of Variable is zero. If there is a 2nd. argument 'Tolerance' and it is positive, a 1 is returned if <I>no</I>  elements in Variable have absolute values <= Tolerance.

For both functions, scalar 'Variable' is allowed.
===============================================================
//AND//
//OR//
//XOR//
//XORCOMP//
<B>BINARY LOGIC FUNCTIONS</B>

The functions are  <B>and(.)</B>, <B>or(.)</B>,<B>xor(.)</B> and <B>xorcomp(.)</B>,

Each takes arguments: (<# blue>Variable1, Variable2 [, scalar Tolerance ] <# black>).

Each returns an object of the same structure as Variable1.

Argument combinations allowed are: scalar-scalar;  array-array (of same size, not necessarily of same structure); array-scalar (in which case the scalar is replaced by a virtual array containing only that scalar value).

Suppose we call the returned array 'Result', and consider the case of two input arrays Var1 and Var2. Then Result is made up as follows:

<B>and(.)</B> -- Result[i] is 1 if <I>both</I> Var1[i] and Var2[i] are <I>nonzero</I>.
<B>or(.)</B> -- Result[i] is 1 if <I>at least one of</I> Var1[i] and Var2[i] is <I>nonzero</I>.
<B>xor(.)</B> -- Result[i] is 1 if <I>exactly one of</I> Var1[i] and Var2[i] is <I>nonzero</I>.
<B>xorcomp(.)</B> -- Result[i] is 0 if <I>exactly one of</I> Var1[i] and Var2[i] is <I>nonzero</I>.

If there is a 3rd. argument 'Tolerance' and it is positive, a match is regarded as occurring if the absolute difference between the two elements is <= Tolerance.

See also unary logic functions 'is(.)' and 'not(.).
===============================================================
//APPENDCOLS - see INSERTROWS
//APPENDROWS - see INSERTROWS
===============================================================
//ARCSIN, ARCCOS, ARCTAN -- see TRIGONOMETRY
===============================================================
//ARGB -- see HSL
===============================================================
//ARRAY//
//ARRAYS//
//DIMS//
<B>Quick enumeration of array functions</B>
Consult the 'Help' menu for more details on functions in this list. 
<I>NB - most basic scalar mathematical functions</I> will take array arguments; for example, 'sin(Arr)' will produce an array consisting of the sine of every member of Arr.  Such functions are not included in this list. 
Also, <I>arithmetic signs</I> can be used between scalars and arrays (for example, 'Arr + x' adds the scalar x to every element of Arr) and between arrays ('Arr1 ^ Arr2' raises every element in Arr1 to the power which is the corresponding element of Arr2). Scalar/array and array/scalar operations cause every element of the array to be operated on by the scalar; array/array operations result in each term of one array and each corresponding term of the other array undergoing the action of the sign.

<U>Defining / redefining arrays</U>
Using the declaration '<B>array</B>': "array Arr1, Arr2, ..., Arr9;" This creates as many arrays as are mentioned, all having size 1 and content 0. (You use this mainly for clarity, e.g. to name all important arrays at the start of your program, giving them realistic sizes and content later).
<B>dim</B>(Arr, 3) defines Arr as list array, size 3; dim(Mx, 2,4) defines Mx as a 2x4 matrix. (Note the order: higher dimension(s) first). No more than three dimensions are currently allowed. Values supplied for dimensions are rounded internally. You can define more than one array to the same dimensions in the one function call: 'dim(Mx1, Mx2, Mx3, 2, 4);'.
<B>dimlike</B>(Arr1, Arr2, ..., Model) creates arrays Arr1 etc. with the dimensions of the last array Model.
<b>Arr = structure(dimensions)</b>:  Has the advantage that the dimensions may be provided in array form.  Both "Mx = structure(4, 3)" and "Mx = structure(arr)" (where arr is the array [4, 3]) are equivalent to "dim(Mx, 4, 3)".
<B>Arr = data(1,2,3,4);</B> defines a list array with the given data. Any characters go in as their unicode numerical values; hence, <I>Arr = data(1, "ABC", 2)</I> and <I>Arr = data(1, 65, 66, 67, 2)</I> are equivalent.
<B>ladder(..)</B> -- fills an array with an arithmetic progression. Type 'ladder' and then key F1, for details.
<B>chain(.)</B> -- creates a list array built by replicating a given scalar or array until the desired length is reached.
<B>fill(..)</B> -- fills an array according to a pattern; type in 'fill' and then key F1, for details.

You can also create an array by using a declaration -
<# blue> array Arr1, Arr2, Arr3;  <# magenta>// Any number of arrays can be declared together.
<# black>This creates list arrays of length 1, and is useful where function arguments need to exist before being used, even though the function will change their structure and content(e.g. the function 'unpack(..)'). The declaration has exactly the same effect as <# blue>dim(Arr1,Arr2,Arr3,1);<# black>


<U>Eniolating arrays</U>
Where huge temporary arrays need destroying to conserve memory during a run, use the void function "<B>clear(Arr1, ...)</B>;". (You can have any number of arguments.)
 
<U>Information about an array</U>
<B>size(Arr)</B> -- total data storage size for an array. (For a scalar, returns 0. Always nonzero for arrays, so can be used to distinguish scalars from arrays.) <B>size(Arr, n)</B> returns the size of the nth. dimension of Arr.
<B>dims(Variable [, IncludeZeroDims])</B> -- Returns an array holding the dimensions of the array (element [0] being the lowest dimension). If there is a nonzero second argument, all five allowed dimensions will be included, unused upper dimensions being represented as 0; otherwise, only nonzero dimensions are returned. Scalars return an array of length 1, content 0 (second argument ignored); this never occurs with an array.
<B>redim(Arr1, Arr2, ..., 4,2)</B> -- void; redefines arrays Arr1, Arr2, ... to a 4x2 matrix, retaining data as much as possible. The arrays must already exist.
<B>redimlike(Arr1, Arr2, ..., ModelArr)</B> -- void; redimensions Arr1 etc. to the dimensions of ModelArr, retaining data as much as possible. The arrays must already exist.
<B>undim(Arr1, Arr2, ...)</B> -- void; redimensions the arrays as list arrays. All arrays must have been previously declared.
<b>offset(Struc1, IndexAddress)</b> -- only for matrix or higher structures. Given an index address, returns its offset within the memory image for the array.
<b>indexed(Struc1, OffsetAddress)</b> -- The inverse of the above.
<B> max (any no. of arrays or scalars)</B> -- the highest value within all listed variables.
<B>min(any no. of arrays or scalars)</B> -- the lowest value within all listed variables.
<B>maxat( ""), minat("")</B> - same, but returning an array with more information.
<B>maxabs(.), minabs(.), maxabsat(.), minabsat(.)</B> -- as for the preceding, for maximum / minimum of absolute values.
<B>place(Arr, Low[, High]),   places(Arr, Low[, High])</B> - 'place(.)' returns the index of the first value between/on the limits ('High' is infinity, if omitted). 'places(.)' returns an array of size 6 with more details ([0] being the same index that 'place[.]' would return).
<B>sum</B>(..) -- the sum of all the contents of the array (irrespective of its structure).
<B>distance</B>(..) -- Returns euclidean distance between arrays (given the right boolean arguments).
<B>dot(Arr1, Arr2)</B> -- the dot product of two vectors. (But no check is made on structure, so Arr1 and Arr2 can be of any dimensions, as long as they have the same length.)
<B>find</B>(..), <B>finds</B>(..) and <B>findall</B>(..) -- find first occurrence / find number of occurrences + positions of first and last / find all occurrences. Start point of search is specified for all three.

<U>MANIPULATIVE SYSTEM FUNCTIONS</U>
These all have analogies in the manipulating of strings. Refer to the "System Functions" section for details (or key F1 with the cursor at the function name after transferring it to the Results Window). All are nonvoid, returning a new array based on the first argument of the function (which is not itself altered).
<B>copy(.) and copyto(.)</B> return part of an array. (The first version copies a given extent from a given location; the second version copies all between two given locations.)
<B>select(Arr, array of indices)</B> returns a list array of values from Arr, selected using the supplied indices.
<B>evict(Arr, array of indices)</B> the converse; returns a list array of values from Arr, selecting all <I>except</I> those indicated by the supplied indices.
<B>poke(Arr, array of indices, array of values OR single scalar value)</B> -- the inverse: takes a list array of values and inserts them into Arr, using the supplied indices; OR takes a single value and inserts it as per supplied indices.
<B>insert(.)</B> inserts a second array into the input array, at a given point. If that point is beyond the end of the input array, the second array is appended to the input array. But this is done more efficiently by 'data()'.) 
<B>delete(.)</B> copies a given array with a section deleted.
<B>replace(.) and replaceto(.)</B> return a given array with part of its extent replaced by a given replacement (array or scalar).
<B>peck(.)</B> finds the first instance of some value and either removes or replaces that single instance of the value.
<B>substitute(.)</B> returns copy of input array, with all instances of a scalar or array (or within a certain range of values) replaced by a given scalar or array.
<B>expunge(.)</B> returns copy of input array, with all instances of a scalar or array value removed (without replacement).
<b>readtable(.)</b>given a look-up table array, and an input array of indices for it, returns the table values corresponding to the indices. 
<B>removedups(array)</B> -- returns a copy of the array with all duplications removed: <# blue>removedups(data(1,1,3,2,2,3,1));<# black> returns the array [1, 3, 2]. No reference to input structure; output always a list array.
<b>removeruns(array, ...)</b> -- returns a copy of the array with runs of value(s) replaced by a single value.
<B>intersection(at least two arrays)</B> -- Returns a list array containing all values common to all arrays (structure and chars. rating ignored). Duplicates removed. If no common values, call to 'empty(.)' returns 'true'.
<B>reverse(..)</B> and <B>reversed(..)</B> -- reverse array contents.
<B>push(..)</B> and <B>pop(..)</B> -- push data in one end of the array and remove it from the other end (to keep length the same). They return the displaced data.
<B>cull(..)</B> and <B>cullbykey(..)</B> -- shorten the array by removing particular values.
<B>progressive(..)</B> returns a copy with elements progressively operated on (cumulatively added or multiplied, or progressive differences taken).
<B>overlay(..)</B> returns an interaction (+, -, * or /) between two list arrays or two matrices, but only in the region in which they overlap (you supply pointers to show where overlapping begins).
<B>fixedsize(.)</B> returns a copy of the array either padded or (optionally) truncated to a given length, with padding as needed.

<U> SYSTEM FUNCTIONS SPECIFIC TO MATRICES</U>
More details on these can be found by keying F1 with the cursor at the particular function names. Here they are just mentioned:
<B>determinant( SquareMx [, CutOff])</B> -- produces the determinant of Mx (which must be square and at least 2x2).
<B>inverse(Mx [, CutOff])</B> -- Returns the inverse of the matrix, which must be square, and at least 2x2.
<B>dot(Vec1, Vec2)</B> -- dot product of two vectors.
<B>norm(Vec)</B> -- euclidean norm; has the same effect as: "sqrt(dot(Vec,Vec));".
<B>transpose(Mx)</B>.
<B>mxmult(Mx1, Mx2)</B> -- true matrix multiplication.
<b>matrixop(Mx1, Operation, Arr)</b> -- operations between matrix and vector, or matrix and matrix.
<b>mxhalf(.)</b> -- fills the upper and/or lower triangle of a matrix, ± the main diagonal. Key F1 with the cursor at 'mxhalf'.
<B>mxdiag(.)</B> -- returns / manipulates square matrix diagonal.
<B> shufflemx(..)</B>-- rearrange the order of rows or columns.
<B>selectrows / selectcols(Matrix, arrow of row / column nos.)</B> returns a matrix made up of the indicated rows or columns.
<B>pokerows / pokecols(matrix Destination, list array Row/ColNos, matrix Source)</B> -- the inverse: overwrites existing rows / cols with supplied new ones.
<B>insertrows(.),  insertcols(.)</B>.
<B>appendrows(.),  appendcols(.)</B>.
<B>copyrows(.),  copycols(.),   copyrowsto(.),  copycolsto(.)</B>.
<B>copymx(.),  copymxto(.)</B> -- copies a submatrix of given matrix.
<B>replacerows(.),  replacecols(.)</B>.
<B>deleterows(.), deletecols(.)</B>.
<B>sumrows(.),  sumcols(.)</B>.
<B>prodrows(.),  prodcols(.)</B> -- products of all terms in each row / column.
<B>chainrows(.),  chaincols(.)</B> -- generate matrices with given no. of repetitions of an input row / column.
<B>findinmx(..)</B> -- find a value in a matrix and return the row and column of the find.
<b>removedups(mx, 'R')</b> -- remove duplicate rows;  <b>removedups(mx, 'C')</b> -- remove duplicate columns.
<B>push(.),  pop(.)</B> -- cause the array to act like a stack, rows being pushed onto / popped off the stack. (Not confined to matrices, but would usually be used with a matrix.)
<B>rowop / colop (..)</B> -- replaces a row / column with a multiple of any compatible row / column (unary version) or with an operation between two rows / columns, or even a row and a column (if a square matrix).


<U>I/O</U>  (see help menu, 'Data Input and Display', or key F1 after entering the function name in the Assignments window. No details of functions are given here.)
<B>show(..)</B> -- displays data in a message box. (Works with scalars also.)
<B>write(..), writeln(..)</B> -- displays data in the Results window. (Works with scalars also.)
<B>request(..)</B> -- allows data entry from the keyboard during a program run; for scalars and list arrays.
<B>save(..)</B> -- saves array (or scalar) contents to a file.
<B>neat</B> -- puts matrix (or higher structure) into more readible form: 'write(neat(Mx))', 'show(neat(Mx))'.
<B>chars(..), notchars(..)</B> -- too complicated for here. See 'Data Input and Display'.
===============================================================
//ASC -- see STR
===============================================================
//ASPECT//
<b>Setting the Initial Viewpoint for a 3D Graph</b> 

If you don't want the default viewing angles, use function <b>aspect</b>(<# blue>[graphID, ] scalar Declination, scalar RightAscension)<# black>. Imagine that your graph is of a man standing and facing you, and consider the plane of your table top as you view him on your vertical computer screen. <i>Declination</i> would then be the angle between the man and the table plane (0 when he is prone before you in an act of adoration; PI/2 when he is standing proud and vertical). The man can be rotated through a full circle, to face all directions; in doing so, his declination is unaltered. Now return him to face you, at whatever rakish declination angle he is standing relative to the table. His <i>RightAscension</i> is now 0. Rotate him through a right angle to face the wall to your right; his RightAscension is now PI/2. 

The default settings for 3D graphs are: Declination = PI/3;  Ascension = PI/6. If you want to use a default and cant remember these, write the system constant NAN in place of the angle.

If you omit graphID, then the settings apply to the next 3D graph to be drawn.

You can also retrieve the current settings by calling with only one argument: <b>aspect(graphID)</b>. This will return an array of length 2: [0] = current Declination, [1] = current Ascension. If graphID could not be identified or is 2D, the return is an array of size 1, value NaN, and a call to 'empty(.)' returns 'true'. (The 3-argument version also returns these values; but the 2-argument version is void.)
===============================================================
//BARGRAPH -- see HISTOGRAM
===============================================================
//BESTSQUARE//
<B>bestsquare</B>(<# blue>scalar Number<# black>) -- If Number is a scalar and rounds to 1 or more, the function returns an array of two factors which when multiplied equal Number, these factors being as near to each other in value as possible, the smaller coming first. Examples: 'bestsquare(48)' returns [6, 8] (rather than e.g. [4, 12]); 'bestsquare(144)' returns [12, 12]; 'bestsquare(17)' returns [1, 17]. If Number rounds to 0 or a negative integer, an array of length 1, value NaN is returned, and a call to 'empty(.)' returns TRUE.
===============================================================
//BETWEEN -- see COPY
//BIN -- see HEX
===============================================================
//BITOP//
<B>BITWISE OPERATIONS ON NUMBERS</B>

The function for these is <B>bitop</B>(<# blue>array Operation, one or more Operands<# black>).

Only the first character of Operation is examined, which must be one of the following:  

<bullet>'&': bitwise AND;
<bullet>'|': bitwise OR;
<bullet>'^': bitwise XOR;
<bullet>'1': 1's complement;
<bullet>'2': 2's complement.

Values are all rounded and converted to 64-bit integers before the operations happen. They must have less than 16 decimal digits; i.e. they must lie inside the limits +/- 1E15, or an error is raised. (Limits to the precision of .NET type 'double' dictates this.)

The function always returns a scalar value.

'Operands' may be any mix of arrays and scalars, with the following limitations:
(1) Unary operations ('1' and '2'): there may be only one value in Operands.
(2) Binary operations('&', '|' and '^'): there must be at least two values in Operands.

Binary operations chain through the values in succession; as an example (using scalars), "bitop('&', a, b, c, d)" will produce bitwise (a & b & 77 c & d).

<U>Example Code</U>
Run the following in MiniMaths to see a display of hex forms of the operands and of the results.

\t<# magenta>// Binary operations:
\t<# blue>a = unhex("FF"); \t<# magenta>// 255
\t<# blue>b = unhex("88"); \t<# magenta>// 136
\t<# blue>_and = bitop('&', a, b);
\t<# blue>_or = bitop('|', a, b);
\t<# blue>_xor = bitop('^', a, b);
\t<# magenta>// Unary operations:
\t<# blue>_1scomp = bitop('1', a);
\t<# blue>_2scomp = bitop('2', a);
\t<# magenta>// Display these results in hex form:
\t<# blue>writeln(hex(a), " & ",  hex(b), " = ", hex(_and) );
\t<# blue>writeln(hex(a), " | ",  hex(b), " = ", hex(_or) );
\t<# blue>writeln(hex(a), " ^ ",  hex(b), " = ", hex(_xor) );
\t<# blue>writeln("1's complement of ", a, "(", hex(a), ")  is  ", _1scomp, " (", hex(_1scomp),")");;
\t<# blue>writeln("2's complement of ", a, "(", hex(a), ")  is  ", _2scomp, " (", hex(_2scomp),")");;
===============================================================
//BKMKCOPY//
//BKMKREPLACE//
<B>ARRAY MANIPULATORS USING BOOKMARKS</B>

In some situations, such as when dealing with self-altering programs, one may want imbedded bookmarks in the text, between which text is frequently updated. These functions come to the aid:

<B>bkmkcopy</B>(<# blue>array Source, scalar StartPtr, array OpenBkMk, array CloseBkMk<# black>) -- Looks in Source (structure ignored), from StartPtr onwards, for the two bookmarks. If both are found, returns what is between them as a list array. If nothing is between them, or if either is not found, returns an array of size 1, value NaN; and a call to 'empty(.)' returns 'true'.

<B>bkmkreplace</B>(<# blue>array Source, scalar StartPtr, array OpenBkMk, array CloseBkMk, array NewData [, bool RetainBkMks]<# black>) -- Looks in Source (structure ignored), from StartPtr onwards, for the two bookmarks. If both are found, Inserts NewData between them, overwriting any data that was there; if the final bool is not present or is 'false', the bookmarks themselves are also removed. If either bookmark is not found, returns a copy of the original data unedited (as a list array) - no insertion.
===============================================================
//BLOCKFILE//
<b>BLOCKING PARTICULAR FILES FROM BEING SAVED VIA THE MAIN MENU</b>

Sometimes the user's program might use the Assignments Window as a sort of text editor, clearing away the program text in the process even though the program is still running. There is a danger that the user may then accidentally overwrite the disk image of the program when using "File | Save" to save whatever has since been placed in the Assignments Window. (The function below was added because this happened to me on numerous occasions.)

The function to block / unblock the saving of files as one of the listed file names, using menu options "File | Save" and "File | Save As", is

	aa = <b>blockfile</b>(<# blue>array FileName [, array DoWhat [, array AlternativeMessage ] ] <# black>)

<i>FileName:</i>The full path and name. You can use standard abbreviations,  e.g. "~" for the personal home folder. If the name occurs alone, it is matched to the current directory (not recommended, as that can change during program runs as the result of other file I/O actions). If the name is invalid, no error is raised; simply what you thought you were blocking / unblocking won't get blocked / unblocked.

If you want to stop a file name from being used to save the file <i>anywhere</i> in any directory, prefix the name with "!". (You can also do this with a partial file path before the file name; that path and name could not be saved in any other directory.)

<i>DoWhat:</i> An array, only the first element of which is examined. This is case-sensitive, and should be one of:
<bullet>'B' - block the file mentioned.
<bullet>'U' - unblock the file mentioned, if it had earlier been blocked. (No action, if not.)
<bullet>'A' - unblock all currently blocked files (if any). (In this case, FileName is not accessed, so could even be scalar.)
<bullet>'?' - Just return a list all currently blocked files (if any). (again, FileName is not accessed, so could even be scalar.)
<bullet>Any other value raises an error.

If DoWhat is missing, it defaults to 'B'.

<i>AlternativeMessage:</i> The automatic dialog box message for a blocked file event isn't a bad one; but if you would like to do your own, and DoWhat is 'B', then add in this third argument.

Note that this function does NOT prevent you saving a blocked file from within the program, via system function "save(.)". It only blocks saving via the "File" menu.

RETURNED: In all cases, a chars. array consisting of currently blocked file names delimited by '|'. If there are none, returns " " (i.e. an array of one space character). If some file has been assigned an alternative message (i.e. the argument AlternativeMessage was supplied), then that file name will be followed by '#' and the message.

CRASHING ERROR: The only causes internal to the function are: (a) unrecognized DoWhat value (or scalar DoWhat); (b) FileName not an array, where it is needed (i.e. where DoWhat = 'B' or 'U'). 
===============================================================
//BOARDPLACEMT -- see GRAPHRESIZE
//BOARDRESIZE -- see GRAPHRESIZE
===============================================================
//BOOLSTR//
<B>STRING OUTPUT FOR BOOLEAN VALUES</B>

<B>boolstr</B>(<# blue>Any no. scalars and arrays TestValues [, chars. array TrueFalse]<# black>) -- TestValues will be the key for determining strings (like "true" and "false" - which are the defaults) to use for the output. It returns the output as 
<bullet>an unpadded chars. list array (if TestValues is just one scalar);
<bullet>or a 'jagged' matrix, column length being longer of the 'true' and 'false' string pair, padder being the space char.

All values are tested for being 'true' (nonzero) or 'false'. The output string for these values is determined as follows...

TrueFalse = "T" or "TR" --> 'TRUE', 'FALSE';  
TrueFalse = "t" or "tr" --> 'true', 'false' (the defaults).
TrueFalse = "Tr" --> 'True', 'False';  
TrueFalse = "tR" --> 'tRUE', 'fALSE'.

There can be more characters after the first two, which will be ignored.

TrueFalse begins with '/':  
<bullet>"/string A/string B" --> 'string A', 'string B'   (Note - no stripping of blanks.)
<bullet>"/ string 1 " --> ' string 1 ', 'false' (default 'false', as no 2nd. string supplied.) 
===============================================================
//BRACKETLEVEL//
<b>FINDING BRACKETTING DETAILS AT SOME POINT IN A CHARACTER ARRAY</B>

The scenario:  You have some text with parenthetic passages in it; your pointer might be inside such a paranthesis - you would like to know. If so, you might also like to know where the opening and closing brackets are for this parenthesis. The function is:

<b>bracketlevel</b>(<# blue>array String, array Opener, array Closer, scalar Pointer<# black>) -- gives you the bracketting information for element Pointer in array String.

<u>ARGUMENTS</u>
<i>String</i> -- the array should contain unicode values; I don't know what would happen if you try using other values.
<i>Opener, Closer</i> -- only the first character is accessed. (A scalar would also do, if it were the corresponding unicode.) For regular brackets, these would be '(' and ')'; but they can be any characters you like (though obviously not both the same character).
<i>Pointer</i> -- this function is unforgiving; if Pointer does not point to an element of the array (i.e. is negative, or too large), the function crashes.

<u>RETURNED ARRAY</u>
This always has length 3. The elements are deployed thus:
[0]  -- IF NO ERROR:  the bracketting nesting level. 0 = Outside of all brackets; 1 = inside single brackets, unnested; 2+, successively more nested bracket levels.
		E.g. in the string "00(11(22(33(44))))", each digit by a happy coincidence happens to be what [0] would contain if Pointer pointed to it.
[0] -- IF ERROR IN BRACKETTING: Always -1. Examples of arrays that would produce this (whatever the value of Pointer): "AA(BB" or "AA)BB" or "AA)BB(CC". In other words, bracketting must be logically correct throughout the whole string; this is important if you are testing just a substring of text, where your substring cuts across the correct bracketting of the original text.

When Pointer points to a bracket, the value of [0] will be the nesting level of the characters between it and its matching bracket. For example, in "(A)", Pointer of 0, 1 or 2 would return the same value 1. (the brackets can be empty; "()" would return [0] as 1 for Pointer of 0 or 1.)

Whether there is error or not, the next two are always filled. You cannot rely on their values, however, in the presence of errors.

[1] -- The position in String of the bracket AT or TO THE LEFT OF Pointer. Note that this finds the bracket at the current nesting level, hopping over any nested brackets along the way. For example, in this string - "(AA(BB(CC)DD)EE)", if Pointer points to either of the 'E's, then [1] will be 0, the position of the first bracket in the string.

[2] -- The position in String of the bracket AT or TO THE RIGHT OF Pointer. Again, this hops over any nested brackets along the way. In the string above, if Pointer pointed to one of the 'A's, the returned value would point to the final bracket in the string.

If there IS NO BRACKET to the left, [1] returns -1; likewise if none to the right, [2] returns -1.

Here are some examples:
	<# blue>writeln( bracketlevel( "AAA",  '(',  ')',  1)  );  <# magenta>// -->  [0,  -1,  -1]
	<# blue>writeln( bracketlevel( "A(B)C",  '(',  ')',  1)  );  <# magenta>// -->  [1,  1,  3], as would Pointer values of 2 and 3.
	<# blue>writeln( bracketlevel( "A(B)C",  '(',  ')',  0)  );  <# magenta>// -->  [0,  -1,  -1], as would Pointer value 4.
	<# blue>writeln( bracketlevel( "A(BC",  '(',  ')',  0)  );  <# magenta>// -->  [-1, -4, -1]; [0] indicates an error state, so [1] and [2] are consequently not much use.

<# black>Note that you can use this function just to test whether bracketting is legal and complete in some text; in that case you would only be interested in returned element [0].

===============================================================
//BTNRELEASE//
<b>MOUSE EVENTS IN THE ASSIGNMENTS WINDOW</b>

Well... er... currently only one is handled, the release button event. Due to the way that Mono's TextView handles the mouse, the only way this event is ever triggered is when you click over some text which has already been selected (in whatever way). The click will end the selection, but will also provide data which can be retrieved by the function below.

<^>(The 'button down' event is even more unavailable - it fires with a triple-click on the vertical scroll bar, or a single click on the tiny bit of space between the edge of the Assignments Window and the vertical scroll bar. As a result I have not written a system function to handle the button down event.)</^>

<b>btnrelease()</b> -- returns an array of size 15, its fields containing the following data:

	[0] = button clicked (0 if none since user run startup OR since the last call to this function); left = 1; middle = 2; right = 3.
	[1] = time of this click in msecs. since start of 1 AD.
	[2] = time since last click, or same as [1] if this is the first click this run.
	[3], [4] currently unused, reserved for future timing entries.
	[5] = CNTRL down (TRUE or FALSE), [6] = ALT down.
			([7] supposedly is for SHIFT down, but is never detected as Mono's TextView hijacks SHIFT + mouse click.)
			Keys CNTRL and ALT may be down together, in which case both [5] and [6] will be TRUE.
	[8] to [10] unused; reserved for other modifier keys detection in the future, if necessary.
	[11, 12] = (X, Y) of click relative to the top of this window.
	[13, 14] = (X, Y) of click relative to the top of the screen.

Note that 
(a) At the start of a program run, all fields are zero.
(b) This function resets [0] in the internal buffer, but no other fields. So if [0] is nonzero, there has been a new click; if it is zero, the rest of the data is retained from the last click.
===============================================================
//CAP//
You have some set of values which you want to cap; that is, none of the values is allowed to rise <b>much</b> above some value that I will call CriticalValue. (If they must not at all rise above that value, simply use function <# blue>clip(.)<# black> ). There is also an absolute ceiling for values, which I call Asymptote; no value may ever exceed this limit. The function described below will downscale all values above CriticalValue to some value between CriticalValue and Asymptote; the higher the input value, the closer is the output value to Asymptote.

<B>cap</B>(<# blue>scalar / array InputValues, scalar CriticalValue, scalar Asymptote<# black>) -- returns a structure of the same type as InputValues in which every input value above CriticalValue is replaced with a smaller value which is less than Asymptote.

You can test the function by running this code, using varying values for the 2nd. and 3rd. arguments. The code draws a graph of output values v. input values. Three extra straight lines are added to the graph: a grey line, representing a slope of 1 (below the critical value, all values will lie on this line, as output value = input value); a red line, for the critical value; and a blue line, for the asymptote.
As you mess with the arguments, note that if CriticalValue = Asymptote, the output is the same as you would get using function <# blue>clip(.)<# black>. Also, the function doesn't fall over if you make Asymptote less than CriticalValue; you just don't get what you might expect.

	<# blue>CriticalValue = 1.7; <# magenta>// *** Vary at will.  Below this value, the function 'ApplyCap' will simply return the input value.<# blue>
	Asymptote = 2.4; <# magenta>// *** Vary at will.  Returned values will never exceed (or even reach) this value.
	// Settings just for the illustrative graph:
	<# blue>NoPoints = 101;
	Xmax = 5;
	xx = ladder(NoPoints, 0, Xmax); <# magenta>// This will be the set of original uncapped values; 'yy' below will be corresponding capped values.<# blue>
	g = graph();
	graphresize(g, 400, 400);
	grid(g, 0, 5, 25,  0, 5, 25);
	<b>yy = cap(xx, CriticalValue, Asymptote);</b>
	pCurve = plot(yy,xx, ' ',0,0, '_', 2, 'black');
	<# magenta>// For demo purposes, draw a grey line of slope 1 from the origin, draw a red line through the critical value, and draw a blue line
	//   for the asymptote:<# blue>
	pSlope1 = plot( data(0, Xmax), data(0, Xmax), ' ',0,0,  '_',1,'grey'); 
	pCrit = plot( data(CriticalValue, CriticalValue), data(0, Xmax),  ' ',0,0,  '_',1,'red'); 
	pAss = plot( data(Asymptote, Asymptote), data(0, Xmax),  ' ',0,0,  '_',1,'blue'); 
	addplot(g, pSlope1, pCrit, pAss, pCurve);

===============================================================
//CAPTURED//
<b>captured</b>() -- When, after running some code, you put the cursor beside or in some array name and then press the F1 key, you get a display of that array's contents. One button in that window is marked "Capture". Click on this and the array details and data are saved in a file "Captured Array" in the program's directory. You can then operate on that array by starting up a new instance of MonoMaths and adding the line "arr = captured();" (the LHS name is immaterial). The LHS array has the same structure, chars. rating and data as the array that was captured.

The function also may take an array argument: <b>captured(array ShowWhere)</b>. Only the first letter of that array is significant. It allows for the publishing of information about the variable and its source. This information has two forms: a verbose form (easily humanly readable) and a concise form (only readable by geeks). If ShowWhere[0] is a capital letter, the verbose form is used; otherwise the concise form.

There are three English letters accepted for ShowWhere[0]. (If none of these, or if the argument is scalar, nothing is shown, though of course the function still returns the variable as explained above.)
<bullet>'R', 'r' -- publish the report in the Results Window.
<bullet>'D', 'd' -- display the report in a dialog box.
<bullet>'M', 'm' -- put the data into an internal buffer, which you can then access using function 'iomessage()'. (This is usually used for returning messages relating to file I/O operations.)  ( The related function 'iok()' would return 'true' if accessed, though that would be rather pointless to do.)

The <i>verbose</i> message is self-explanatory. The <i>concise</i> message is more arcane. An example of the concise message would be: "foo::/home/fred/MonoMaths/Temp/aaa.txt::1768::63543038048" - where 'foo' is the name of the variable as it was in the given program ("/home.../fooltxt"), and where '1768' is how long ago the data was saved, in seconds. The final large number is the actual time of the save, as Mono (and .NET also) codes it.

===============================================================
//CEILING -- see MOD
===============================================================
//CHAIN//
<B>CHAIN(array or scalar Segment,  scalar OutLength)</B>

Returns a list array made up of repetitions of 'Segment' until length OutLength has been reached. OutLength obviously must be 1 or higher; if less, the function simply returns a scalar value - 0.

If Segment is an array, the output array takes on its character status. Also, its structure is ignored.

<# blue>arr = chain(9, 5);  <# magenta>// returns [9, 9, 9, 9, 9]
<# blue>arr = chain(data(1,2), 5);  <# magenta>// returns [1, 2, 1, 2, 1]
<# blue>arr = chain("Cat", 8);  <# magenta>// returns "CatCatCa"
===============================================================
//CHAINROWS//
//CHAINCOLS//
<B>CREATING A MATRIX WHICH CONSISTS OF DUPLICATIONS OF A GIVEN ROW / COLUMN</B>

<B>chainrows</B>(<# blue>variable Row, scalar NoRows<# black>) -- nonvoid; produces a matrix of NoRows rows, all being copies of Row. If Row is scalar, the output matrix will be a column vector (as would also occur if Row were an array of length 1). The structure of Row is not referenced. An error is raised if NoRows < 1.

<B>chaincols</B>(<# blue>variable Column, scalar NoColumns<# black>) -- analogous to the above.
===============================================================
//CHARPOLY//
<B>charpoly</B>(<# blue>Matrix [, scalar virtZero]<# black>) -- returns the characteristic polynomial for an NxN square matrix (must be at least 2x2). The polynomial is returned as an array of length N+1, being coefficients in ascending order of power. The coefficient for the highest power is always +1. if 'virtZero' is supplied and is positive nonzero, polynomial elements with absolute value of this or less are equated to zero.
===============================================================
//CHARS//
//UNCHARS//
<B>CHARACTERS RATING OF AN ARRAY</B>

Arrays are tagged internally with a boolean which decrees whether or not the contents of the array should, in certain circumstances, be treated as a string of unicode character codes or as just plain data. This boolean has no effect whatever on any aspect of array behaviour other than how it is handled by  screen input/output functions (principally 'write', 'writeln', 'show', and 'request'). Suppose the array [65, 66, 67] is presented as an argument to 'write(.)'. If the characters rating boolean is set to TRUE, then this will be displayed on the screen as "ABC". Otherwise it will be displayed as "65, 66, 67".

By default, the characters rating is FALSE for a newly created array. Exceptions: (1) when it is created using the function 'text(..)'. (2) when it is equated to another array which has a TRUE rating: "Arr1 = text("ABC");  Arr2 = Arr1;" - both arrays will have their rating set to TRUE.

You can alter the rating at any time by means of two functions -
<# blue>chars(Arr);<# black>  sets the rating to TRUE;
<# blue>unchars(Arr);<# black>  sets the rating to FALSE;

Both functions can take any number of arguments. (Scalar arguments, if included, would not cause a crash; they would simply be ignored.)

<b>CAUTION:</b> If you use 'chars(Arr)' on an array containing values outside of the unicode range, and then subsequently treat the array as if it were all unicode values, you will get strange intermittent crashes of MonoMaths as a whole. <# grey>This has to do with the way the underlying library G-Lib (used by C#) handles the code; a "G-Lib CRITICAL" error is internally raised, which nevertheless normally does not stop operation; the intermittent nature apparently has to do with the fact that IDs of error points can be duplicated in some circumstances not accessible to the user. There are many bug reports on the Net re this type of error.<# black> 

===============================================================
//CHECKDIRECTORY//
//CHOOSEFILENAME//
//CURRENTDIRECTORY//
//HOMEDIRECTORY//
//FILESIZE//
<b>filesize</b>(<# blue>PathAndName<# black>) -- Returns the file size, or -1 if unsuccessful (the file does not exist). As <i>not</i> with the above functions, there are allowed standard abbreviations. These are: (a) "~/" --> user's personalized home folder, e.g. "/home/fred/";  (b) "./" refers to the current directory; (c) "../" refers to the parent of the current directory.

<B>homedirectory</B>(<# blue>dummy<# black>) -- Returns the current user's personalized home directory, e.g. "/home/fred/". Argument, if any, is not referenced.

<B>checkdirectory</B>(<# blue>DirectoryName [, bool AllowFileName] <# black>) -- returns TRUE if this directory exists AND if it is accessible; otherwise FALSE. (For example, in Ubuntu the root directory "/" will return false because MonoMaths does not have privileged access to it.) The same abbreviations are allowed in the directory name as for function "filesize" above. The 2nd. argument is important; if it is absent or FALSE, then the function looks for a terminal '/', and if it does not find one, it adds one. If TRUE, no such adding occurs; if there is anything after the last '/', it is taken as file name and so is ignored. (If it is in fact a directory name, it is still ignored, and the outcome will depend on whether its parent directory exists.)

<B>choosefilename</B>(<# blue>DirectoryName [, scalar AllowMultipleFileChoice]<# black>) -- Opens a file dialog box at the given directory, and offers a choice of file (or of multiple files, if the second argument is present and TRUE). Returns a chars. array, the chosen file name (with its full path). If more than one file name was chosen, names are delimited by the character '#'. If no file is chosen (i.e. the user cancelled the file browser display), an array of one space is returned. No errors raised. DirectoryName: only text up to the last '/' is used; whatever follows is ignored, even if a valid directory name. The same abbreviations are valid as for function "filesize" above. If part of DirectoryName is invalid, the file browser opens at the latest valid part of the name. If the whole of DirectoryName is garbage, the browser opens where it wills.

<B>currentdirectory</B>(<# blue>array DirectoryName OR scalar Dummy<# black>) -- If the array is a scalar (any value), simply returns the current directory as a chars. array. If a valid directory name, sets the current directory to that name, and the function also returns that name. (This directory will then be the opening directory for e.g. loading and saving of files.) If an invalid directory name, no internal setting occurs, and an error message is returned. (You can distinguish between an error message and a returned path name in that the path name always begins with '/', and the error message always begins with a space character -- unicode 32.)
Note that no abbreviations are allowed in DirectoryName; it must be a complete file path. If it does not already end in '/', a terminal '/' will be added before testing.
See also <b>programfile(.)</b>.

===============================================================
//CHOOSECLR//
<b>DISPLAYING A COLOUR DIALOG</b>

<b>chooseclr</b>(<# blue>array InputColour, array OutputType<# black>) -- Displays an interactive colour choosing dialog - the initial colour being as set by <i>InputColour</i> - and returns the final colour choice in the format set by <i>OutputType</i>. The dialog is exactly the same as you get with main menu item "Appearance | Colour Selector", so you may care to experiment with that first.

<i>InputColour:</i>  This can be one of:
<bullet>An array of size 3, values 0 to 255, which represents R, G, B values;
<bullet>A recognized colour name;
<bullet>Six hex digits as a string.
If InputColour is wrongly formatted the dialog box tells you so, but still allows you to make a new colour choice.

<i>OutputType:</i>  This must be EXACTLY one of these three words (case-sensitive):
<bullet>"hex" -- in which case the return will be a chars. array of length 6 - e.g. for red:  "FF0000".
<bullet>"bytes" -- the return is a nonchars. array, size 3; e.g. for red: [255, 0, 0].
<bullet>"verbose" -- e.g. for red, the return would be: "Chosen colour:  FF0000    (255, 0, 0)    'red'.     Text example: <# red>ABCDEFG<# black>".

CANCELLATION of the dialog, either by the CANCEL button or by corner icon closure, returns the 'empty' array [NaN], for which you test using function 'empty(.)'.
===============================================================
//CLEAR//
//CULL//
//CULLBYKEY//
//KILL//
//TRIM//
<B>CLEARING AND ENIOLATING VARIABLES</B>

<B>clear</B>(<# blue>Var1, Var2, ...<# black>) -- void function, taking any number of arguments, which must be valid variable names. Whether the variable is scalar or an array, all of its data values are replaced by 0. No change is made to array structure.

<B>kill</B>(<# blue>Var1, Var2, ...<# black>) -- void function, taking any number of arguments, which must be valid variable names. Each variable is eniolated, and its name becomes available for reuse as either an array or scalar. Intended uses: (a) demolish huge arrays, no longer needed; (b) in a loop which repeatedly assigns a function to a variable, and that function may on different occasions return a scalar or an array. If you don't kill the assignee after use, the next loop will expect it to be dedicated as the variable type of the last function return, and so a crash will result if the function returns the other type. 

<B>cull</B>(<# blue>ArrayToCull,  UnwantedValues (scalar or array) [, CullWhere (array) ]<# black>) -- Returns a list array which is a copy of the data within ArrayToCull, shortened by removal of any values listed in UnwantedValues. If there is no third argument, or if it is not one of the following list, all such values are removed from the whole array. If CullWhere starts with 'L' or 'l', left-trimming occurs; i.e. all values from [0] upwards which are unwanted are removed until the first wanted character is found. If with 'R' or 'r', right-trimming occurs. If with 'T' or 't' (for 'trim'), both ends are trimmed of unwanted characters, but any unwanted characters surrounded by wanted characters are left. Where culling would return an empty array, it in fact returns an array of size one, its value being NaN; a call to function 'empty(.)' returns TRUE in this case. In all cases the 'characters' rating of the output array is the same as ArrayToCull.

<B>cullbykey</B>(<# blue>array Victim, array Key<# black>) -- Given any array Victim, and a second array Key of the same length, return all the values of Victim except for any values Victim[i] for which Key[i] is FALSE (i.e. exactly zero). If all elements of Key are FALSE, returns an array of size 1, value NaN; and a call to function 'empty(.)' will return TRUE.
===============================================================
//CLIP//
//CLIPABS//
//CLIPCULL//
//CLIPCULLABS//
<B>CONFINING DATA WITHIN LIMITS</B>

<B>clip</B>(<# blue>Scalar LowerLimit, Scalar UpperLimit, Variable Values<# black>) -- returns an identically structured copy of 'Values' (whether scalar or array), in which all values above UpperLimit are replaced by UpperLimit, and all values below LowerLimit are replaced by LowerLimit. If you want a lower limit but not an upper limit, replace UpperLimit by <I>any</I> array; e.g. "clip(-2, "none", arr);". Similarly replace lower limit by any array if you want only an upper limit.
(If you want a gradual upper cutoff point rather than a sharp point, see function <# blue>cap(.)<# black> instead.)

<B>clipabs</B>(<# blue>Scalar LowerLimit, Scalar UpperLimit, Variable Values<# black>) -- similar to the above. returns a copy of 'Values' (whether scalar or array), in which all values with absolute value above UpperLimit are replaced by  UpperLimit (but retain their original sign), and all with absolute values below LowerLimit - including zero itself - are replaced by LowerLimit (but retain their original sign). (The signs of args. 'UpperLimit' and 'LowerLimit' are ignored; their absolute values are used.) If you want a lower limit but not an upper limit, replace UpperLimit by <I>any</I> array; e.g. "clip(-2, "none", arr);". Similarly replace lower limit by any array if you want only an upper limit.

<B>clipcull</B>(<# blue>Scalar LowerLimit, Scalar UpperLimit, Array Values [, bool CullValuesAtLimits ]<# black>) -- returns a copy of 'Values' in which all values above UpperLimit and below LowerLimit are removed. If you want a lower limit but not an upper limit, replace UpperLimit by <I>any</I> array; e.g. "clipcull(-2, "none", arr);". Similarly replace lower limit by any array if you want only an upper limit. If the final argument is supplied and is nonzero, values at LowerLimit and at UpperLimit will be
culled; the default is that they remain. If the theoretical result of this function would be an empty array, instead an array of size 1, value NaN is returned, and a call to 'empty(.)' would return 'true'.

<B>clipcullabs</B>(<# blue>Scalar LowerLimit, Scalar UpperLimit, Array Values [, bool CullValuesAtLimits ]<# black>) -- exactly as for <i>clipcull(.)</i>, except that array elements are culled if their <i>absolute</i> value is greater than the absolute values of the supplied limits.
===============================================================
//CLIPBOARD//
<b>ACCESSING THE COMPUTER'S CLIPBOARD</b>

<B>clipboard</B>(<# blue>variable Dummy [, variable DataToStore ]<# black>) -- The first argument is not analysed, but we suggest "get" (one-argument version) and "set" (two-argument version).

The <i>one-argument form</i> simply retrieves any character string stored on the clipboard, as a chars. array: <# blue>ss = clipboard("get")<# black>. (If there is nothing there, the "empty" array is returned - an array of length 1, value NaN, which returns true to function 'empty').

The <i>two-argument form</i> is VOID; it puts the second argument into the clipboard. If that argument is a chars. array, it is stored directly as a string; if a numerical array or scalar, it is first converted to a string (arrays using the delimiter ", ") and then stored.
===============================================================
//CLUSTER//
<just c><b>DETECTING CLUSTERING IN A MATRIX MAP</b>
<just l>
The clustering function is  <b>cluster(<# blue>char. array Action,  matrix Map,  bool IncludeDiagonallyTouchingBoxes [, ... ] <# black>)</b>.  (Non-void; returns a matrix of the same dimensions as Map.)

<u>Scenario 1:</u>  You have a map of boxes arranged rectilinearly, so that if you place a number in each box the numbers constitute a matrix. Think of the map as being of islands in a sea. All the boxes in the sea are filled with zeroes; they will remain zeroes in all that follows. All the land boxes start off with the value -1. The task in hand is to identify each island and to give it a separate 'name' - i.e. fill every box of that island with a unique number.

As an example, starting with the matrix on the left, we want to end up with the matrix on the right:

	0	-1	0	0	-1				0	1	0	0	2
	-1	-1	-1	0	-1		->		1	1	1	0	2
	-1	-1	0	0	-1				1	1	0	0	2
	0	0	0	-1	-1				0	0	0	2	2

where there are two islands, one identified as '1' and one as '2'.

The form of this function to use is  <b>cluster(<# blue>"resolve",  matrix Map,  bool IncludeDiagonallyTouchingBoxes<# black>)</b>.  (Non-void; returns a structure of the same type and chars. rating as 'Map'.)

The arguments:
<bullet><i>Map</i> -- A matrix of any dimensions, <b>which only contains values 0 and -1</b>. (There is no test for the presence of other values; 'garbage in, garbage out' certainly applies if you inadvertently allow other values in.)
<bullet><i>IncludeDiagonallyTouchingBoxes</i> -- If FALSE, boxes that are part of the one island must share a side; those touching diagonally at vertices would not be regarded as on the same island (unless indirectly connected via a chain of intermediate side-by-side boxes). If TRUE, boxes touching only at vertices would also be regarded as being on the same island.

If the input matrix entered as described, with just 0 and -1 as its values, then the returned value will contain 0 (in the same places as before), and integers from 1 upwards. Not all integers within the range will always be represented; e.g. the returned matrix might have identifiers 1, 2, 5, 6, reflecting the fact that during the clustering process land masses 3 and 4 were originally thought to be separate, but then were found to be parts of other islands already labelled.  


<u>Scenario 2:</u>  You have a map of boxes as above, but this time the values in the boxes can be anything you like. But you know that often contiguous boxes contain the same value ('islands' again, if you like). You know where one of these boxes is; you want to identify all the contiguous boxes which contain the same value as that box (the 'island'). The returned matrix will have some special value which you set ('FillValue' below) for every location on this 'island', and 0 for every other location in the map. ('FillValue' can be the same as the value in island boxes, if you so desire.) The only restraint on FillValue is that it cannot be 0 (because, as we have just said, every non-island location in the map will have that value.) (The value in the boxes of the island may, on the other hand, be zero, or any other value you like except NaN.)

The form of this function to use is  <b>cluster(<# blue>"single",  matrix Map,  bool IncludeDiagonallyTouchingBoxes, scalar ThisRow, scalar ThisColumn, scalar FillValue<# black>)</b>.  (Non-void; returns a structure of the same type and chars. rating as 'Map'.)

Here is an example. Using the map below, suppose we set ThisRow to 2 and ThisColumn to 1, and FillValue to 9. We wil get:

	2	5	2	1	5				0	9	0	0	0
	5	<# red><b>5</b><# black>	5	0	5		->		9	9	9	0	0
	5	5	3	0	5				9	9	0	0	0
	1	2	1	5	5				0	0	0	0	0

See also function <b>mxcentre(.)</b>.

===============================================================
//COMMANDLINE//
//COMMAND//
<just c><b>COMMAND LINE ARGUMENTS</b>
<just l>
The following are command elements which may be used. When a value is being assigned to a command element, the syntax is very similar to that used within MonoMaths itself. Where a command element is just a switch, it stands alone. Here are the available command elements. Note that they are <b>case-sensitive</b>.

<u>GROUP 1 -- SCALAR ASSIGNMENTS</u>
<bullet><# blue>left<# black>  OR  <# blue>L<# black>  --  sets the distance of the left edge of the MonoMaths instance from the left edge of the screen.
<bullet><# blue>top<# black>  OR  <# blue>T<# black>  --  sets the distance of the top edge of the instance from the top of the screen.
<bullet><# blue>width<# black>  OR  <# blue>W<# black>  --  sets the width of the instance.
<bullet><# blue>height<# black>  OR  <# blue>H<# black>  --  sets the height of the instance.
<bullet><# blue>topwindowheight<# black>  OR  <# blue>TWH<# black>  --  sets the height of the Assignments Window.

Note that for all of the above you may provide EITHER a pixel value (in which case the value will be an integer \>\> 1)  OR  a proportion of the appropriate screen dimension (in which case it will lie in the range 0 \< N ≤ 1).

Also be aware that the underlying Mono Gtk system only takes your figures as a recommendation; if you supply impractical figures, it just does what it thinks best instead

<u>GROUP 2 -- ARRAY ASSIGNMENTS</u>
<bullet><# blue>load<# black>  --  loads a file which will appear in the MonoMaths instance when it opens.
<bullet><# blue>run<# black>  --  as above, but also runs the file (assuming it is a MonoMaths program file).

<u>GROUP 3 -- SWITCHES</u>
Currently only one -
<bullet><# blue>formatted<# black> -- if text is being loaded, that text will be displayed in the formatted mode (the same as if it had been loaded normally, and then one had keyed F2).

The order of command elements is not important, EXCEPT that <b>no command element should follow 'load' or 'run'</b>. (Any that do will be ignored.)

<b>Syntax for these command elements</b>
For groups 1 and 2, the format is precisely as for MonoMaths assignments. There must be an '=' sign; and there must be a ';' at the end of the assignment (optional for the last assignment, as in MonoMaths code). For group 1, a pure number must be on the RHS; for group 2, a string in quotes. Leading and trailing spaces, and spaces around the '=', are ignored as in MonoMaths.
<bullet>Group 1 - scalar assignments - examples:
<bullet 50,➯><# blue>left = 150;<# black>     [The inset will be 150 pixels.]
<bullet 50,➯><# blue>T = 0.1;<# black>     [The top inset will be 1/10th of the height of the screen.]
<bullet>Group 2 - array assignments - examples:
<bullet 50,➯>load = <# blue>`/home/fred/Foo/bar.txt`;<# black>  [Note the particular quote mark used: [`]. See below for the reason.
<bullet 50,➯>run = <# blue>`/home/fred/Foo/my_program.txt`;<# black>
<bullet 50,➯>run = <# blue>`/home/fred/Foo/my_program.txt` `once upon a time`;<# black> -- runs the program, AND stores what is between the second set of quotes in the internal storage location that is accessed by the system function <# blue>persistent_array()<# black> - which see. If "my_program.txt" is running and wants to access whatever was put there, it just includes the line
				<# blue>PassedStuff = persistent_array();<# black>
<bullet 50,➯>run = <# blue>text(`/home/fred/Foo/my_progarm.txt`, `once upon a time`);<# black> Exactly the same effect. In fact you can put anything you like around the two quoted passages on the RHS, as it will all be ignored.
<bullet>Group 3 - switches
<bullet 50,➯><# blue>formatted;<# black>

Often such command lines will be used in launchers. Here are examples which at the time of writing I am using.
<bullet>Written in the 'command' text box of the GUI for setting a launcher from a panel item:
<bullet 50,➯><# blue>mono /home/jon/MonoMaths/MonoMaths.exe L=0.115; T=0; W=0.75; H=0.94;<# black>
<bullet>Written in the Thunar file which is accessed when right-clicking on a text file and choosing "Open with monomaths":
<bullet 50,➯><# blue>Exec=mono /home/jon/MonoMaths/MonoMaths.exe L=0.115; T=0; W=0.75; H=0.94; load=`%f`<# black>
<bullet>You can achieve the same thing programmatically from within MonoMaths, using the system function <# blue>exec()<# black>. Note that the file name is in one set of standard quotes [".."], and the rest of the command line within a second set of standard quotes:
<bullet 50,➯><# blue>exec("/home/jon/MonoMaths/MonoMaths.exe", "left = 0.05; top = 0.05; width = 0.9;  height = 0.9; topwindowheight = 600; formatted; load = `/home/jon/MonoMaths/Hints.txt`");<# black>  [ *** Warning - takes around 10 seconds because of the 'formatted'.]

<b>Why choose the back-stroke [`] as the quotation mark?</b>
Actually the code of MonoMaths allows you to use any of the three quotation mark types allowed for MonoMaths programs. The problem is not in MonoMaths but in the underlying system which handles all three of the above examples. If you use ["] or ['] around the RHS of 'load' or 'run', the quote mark will have disappeared by the time MonoMaths parses the command line, so that it will see no quotes at all and therefore will do nothing with the command element.

<b>Errors</b>
File errors raise the usual messages but do not crash the new MonoMaths instance.
Other parameter errors are simply ignored; this would include unrecognized commands ("right = 150;") or illegal RHS values ("left = -20;" or "left = `150`;" or omitting quotes - "load = /home/....foo.txt;").


<b>DISPLAY THE COMMAND LINE WHICH INVOKED THIS INSTANCE</b>

Use the command <b>commandline</b>(<# blue>bool AsOneLine<# black>).

The command line is parsed into 'arguments' by C# using the space character as the delimiter. Therefore what MonoMaths regards as legal spaces within a command line element (e.g. the two spaces in "top = 20;") will cause the element to be broken down by C# into separate arguments (here: "top", "=", "20;"). You may prefer to see the command line in its original one-line beauty, in which case set the argument to TRUE; a list array will be returned. But if you want to see how C# has broken down the command line, set the argument to FALSE; the return will be a jagged matrix with the space as the pad character. In both cases the returned array is a 'chars' array.

Note that the command line always starts with the file name of the program (i.e. MonoMaths.exe). I guess this is one way by which you might programmatically find out what is the path of your program (assuming that the calling code has supplied a path, which it nearly always would do as the calling program would be unlikely to be in the same directory as the program itself).

===============================================================
//COLOUR//
//COLOR//
//COLOURS//
//COLORS//
//PALETTE//
<B>DEFINING AND USING COLOURS</B>

There are two situations in MiniMaths where in your code you can use colours: (1) in displaying text, using <B>show(.), write(.), writeln(.)</B>; and (2) in graph plotting functions <B>plot...(.)</B>.

<B>Colours in function "show(.)"</B>
Define the colour using tags "\<# colourname\>", replacing 'colourname' with a colour name like "blue" (or "Blue" or "BLUE" - case does not matter). Any name recognized by .NET as a colour name will do. There are 141 such names; they are listed at the end of this display, with a demonstration of the colour.

The following...
\t<# blue>show("This is \<# red\>most \<# black\>important!");  
<# black>...displays this in a message box: "This is <# red>most <# black>important!"

(If for some weird reason you want to insert the literal text "\<# red\>" in your display, use '\\' before the two tags, to prevent the literal text being interpreted as a tag. Code this -
\t<# blue>show("To get <# red>red<# black> text, use the tag '\\\<# red\\\>'.");
to show this -
\t<# black>"To get <# red>red <# black>text, use the tag '\<# red\>'."

You can alse <B>define colours numerically</B>, using one of the following methods:
<bullet>A hexadecimal number with exactly 8 digits, preceded by "0x" (the numeral '0', not the letter 'o'): <# blue>\<# 0xAARRGGBB><# black>, where intensity ('alpha') is AA, and red, green and blue values are RR, GG and BB. (Sadly, the intensity value will be ignored, as transparent colours are not handled.)
<bullet>A hexadecimal number with exactly 6 digits, preceded by "0x": <# blue>\<# 0xRRGGBB><# black>. In this case, .NET sets the intensity to its highest value 'FF'.
<bullet>An integer, positive or negative, representing such a hex value: <# blue>\<# -123456><# black>.


<B>Colours in functions "plot...(.)"</B>
All the above apply, except that you don't use tags. If you wanted to plot a set of red points, you would write
<# blue>p = plot(yy, xx, '.', 10, <B>"red"</B>, ' ');  graph(p);  <# magenta>// Not case-sensitive: "Red" or "RED" are fine.  Most common colour names are recognized by .NET.
Other examples:
<# blue>p = plot(yy, xx, '.', 10, <B>"0x00FF00"</B>, ' ');  graph(p);  <# magenta>// A green point, as R=0, G=255, B=0.
<# blue>p = plot(yy, xx, '.', 10, <B>"0x4400FF00"</B>, ' ');  graph(p);  <# magenta>// Same colour, as Mono with Gtk doesn't handle transparency.
<# black>(3)  An integer value which is the decimal version of the 8-digit hex string form:
<# blue>p = plot(yy, xx, '.', 10, <B>-6543210</B>, ' ');  graph(p);  <# magenta>// A sickly purple point, as -6543210 has hex form "0xFF9C2896".
<# black>(4)  A non-chars. array of <B>three</B> integer values, [0] being R(ed), [1] being G(reen), [2] being B(lue), and all being in the range 0 to 255 inclusive:
<# blue>p = plot(yy, xx, '.', 10, <B>data(128, 128, 0)</B>, ' ');  graph(p);  <# magenta>// A hideous khakhi-green colour.
<# black>(5)  A non-chars. array of <B>four</B> integer values, [0] being A (intensity) [1] R, [2] G, [3] B, all being in the range 0 to 255 inclusive:
<# blue>p = plot(yy, xx, '.', 10, <B>data(64, 128, 128, 0)</B>, ' ');  graph(p);  <# magenta>// The same colour, as Mono with Gtk doesn't handle transparency.
<# black>(6)  A chars. array holding the text form of three integer values, imbedded within a string containing any other characters:
<# blue>p = plot(yy, xx, '.', 10, <B>"Red = 128, Green = 128, Blue = 0"</B>, ' ');  graph(p);  <# magenta>// That hideous khakhi-green colour again.
<# black>(7)  The same, but with four imbedded integers:
<# blue>p = plot(yy, xx, '.', 10, <B>"Intensity = 64, Red = 128, Green = 128, Blue = 0"</B>, ' ');  graph(p);  <# magenta>// The same, as we don't do transparency.
<# black>(8)  If you want to use the <i>inbuilt palette</i> of 10 colours, you can reference them using <b>palette</b>(index). For example, if you are drawing 50 curves and don't want to bother defining 50 colours, but just want the curves to rotate through the different colours of the inbuilt palette, just do the following. (If 'i' is too high or low, an internal modulus operation brings it back into range, ensuring rotation through the colours.)
<# blue>dim(plots, 50);
<# blue>xx = ladder(101, 0, 1);  yy = xx*xx;  <# magenta>// For a plot of y = x^2, 0 \<= x \<= 1.
<# blue>for (i, 50)
<# blue>{\tyy += 0.05;  <# magenta>// Shift the Y values up a tad for each new curve.
<# blue>\tplots[i] = plot(yy, xx, ' ', -1, -1, '_', 2, <B>palette(i)</B>);
<# blue>}
<# blue>graph(plots);  <# magenta>// The result is a rather crowded rainbow.

<# black>The coding for <b>palette</b>(Index) is -- <# blue>0:"blue"; <# red>1: "red";  <# green>2: "green";  <# orange>3: "orange";  <# magenta>4: "magenta";  <# darkviolet>5: "darkviolet";  <# deepskyblue>6: "deepskyblue";  <# brown>7: "brown";  <# grey>8: "grey";  <# black>9: "black". The index used internally is the absolute value of Index, to modulo 10.
You can also use the 2-argument form of the function, <b>palette(MyPalette, Index)</b>, where MyPalette is a matrix of colour names (either as names - "red" - or as hexadecimal RGB strings like "0x0088FF"). Here you have predefined your own palette, by using e.g. "MyPalette = split("red, green, blue",  ","  )".   The index used internally is the absolute value of Index, to modulo (length of the palette).

<# black>Note that you can use "HSL" values for colour ("Hue - Saturation - Luminescence") as well as RGB values, though conversion is needed. Enter 'hsl' into the Assignments Window and double-click it, for details of conversions HSL <--> RGB.


<B>Deriving the RGB format for a colour reference</B>
<b>rgb</b>(<# blue>ColourRef [, FailureColourRef] <# black>) -- Always returns an array of size 3. If 'ColourRef' can be identified as a colour, then the return array has [0] = R(ed) value (0 to 255), [1] = G(reen) value, [2] = B(lue) value. If not, but 'FailureColourRef' can, then that colour is returned instead. Otherwise the return is an array of all zeroes (equivalent to colour black).
'ColourRef' can be: (1) a recognized colour name (type 'colour' and key F1, for list of allowed names; spaces are ignored); (2) an integer (can be negative); (3) three values, taken as the R, G, B values (in which case using this function is pointless); (4) four values, the first of which will be ignored (this allows for an unused 'brightness' byte; the rest are R, G, B values); (5) a hex number of length 6 digits, preceded by '0x' ('0' = zero, not the letter O); format "0xRRGGBB". (It accepts 8 hex digits also, ignoring the first 2, as for item 4 above).
Wherever 'gray' occurs in a legal name, the UK English version 'grey' is also allowed.


<b>Displaying a Colour Chooser Dialog</b>
The function is <i>chooseclr(.)</i>, which see.


<B>Preparing your own Range of Colours for Plotting</B>
Trying to produce a range of colours by varying one or more of R(ed), G(reen) and B(lue) in an RGB colour array produces disappointing results. It is much better to use a sequence of HSL colours, as the gradation produced by varying one of H, S or L is much more pleasing to the eye.

There are two ways of doing this. The simpler way is to use the system function <b>ladderclr(.)</b>; the details of this function are in a separate article (key  F1 while the cursor is on the word 'ladderclr').  For most purposes this is very satisfactory. But if you want more control over the process you can instead directly use the function <B>hsl_to_rgb(arr)</B>, where 'arr' is an array of three values, each lying between 0 and 1:  [H(ue), S(aturation), L(uminescence)]. The following two short programs demonstrate its use, the first providing a colour chart of Hue versus Saturation for fixed Luminescence, and the second providing a chart of Hue versus Luminescence for fixed Saturation. For your colour series, select one of the horizontal or vertical rows of blocks from the graph of your choice. (Keep in mind that .NET can't directly use HSL colours, but has to be fed the corresponding RGB values; and values of R,G and B are integers between 0 and 255. Therefore if the choice of values for H, S and L is too fine-grained, two or more contiguous HSL colours will translate to exactly the same RGB colour.)

<U>Fixed Luminescence</U>

<# magenta>// HSL COLOURS -- GRAPHIC DISPLAY.
<# magenta>// Colour blocks represent HSL colours. For all colours, the L(uminescence) value is the same, as set in the next code line.
<# magenta>// Values for H(ue) and S(aturation) increase in steps of 0.05 from 0 to 1.
<# blue>Lum = 0.4; <# magenta>// Must lie between 0 and 1. Values between 0.4 and 0.7 give the most useful colour ranges.
<# blue>noValues = 21;   
<# blue>values = ladder(noValues, 0, 1);
<# blue>dim(plots, noValues, noValues);
<# blue>for (hue, noValues)
<# blue>{	for (sat, noValues)
<# blue>	{	colour = hsl_to_rgb( data(values[hue], values[sat], Lum) );
<# blue>		plots[hue, sat] = plot(values[hue], values[sat], '[', 19, colour, ' ');
<# blue>	}
<# blue>}
<# blue>g = graph(plots);
<# blue>header(g, "HSL COLOURS  --  FIXED  LUMINESCENCE  of  ", Lum);
<# blue>labely(g, "HUE");  labelx(g, "SATURATION");
<# blue>grid(g, -0.1, 1.1, 12, -0.1, 1.1, 12);
<# blue>graphresize(g, 500, 500);
<# magenta>// Suppress extreme scale values '-0.1' and '1.1', to improve the optics of the graph:
<# blue>LabelString = text(" ,",  ladder(11, 0, 1), ", "); <# magenta>// '11' being one less than the no. of axis segments (as defined in the 'grid(.)' statement above).
<# blue>scaleoverx(g, LabelString);    scaleovery(g, LabelString);


<# black><U>Fixed Saturation</U>

<# magenta>// HSL COLOURS -- GRAPHIC DISPLAY.
<# magenta>// Colour blocks represent HSL colours. For all colours, the L(uminescence) value is the same, as set in the next code line.
<# magenta>// Values for H(ue) and S(aturation) increase in steps of 0.05 from 0 to 1.
<# blue>Sat = 0.8; <# magenta>// Must lie between 0 and 1.
<# blue>noValues = 21;  <# magenta>// to provide array 'values' as [0, 0.05, 0.1, 0.15, ..., 1].
<# blue>values = ladder(noValues, 0, 1);
<# blue>dim(plots, noValues, noValues); <# magenta>// Each colour block has a separate single-point plot.
<# blue>for (hue, noValues)
<# blue>{	for (lum, noValues)
<# blue>	{	colour = hsl_to_rgb( data(values[hue], Sat, values[lum]) );
<# blue>		plots[hue, lum] = plot(values[hue], values[lum], '[', 19, colour, ' ');
<# blue>	}
<# blue>}
<# blue>g = graph(plots);
<# blue>header(g, "HSL COLOURS  --  FIXED SATURATION  of  ", Sat);
<# blue>labely(g, "HUE");  labelx(g, "LUMINESCENCE");
<# blue>grid(g, -0.1, 1.1, 12, -0.1, 1.1, 12);
<# blue>graphresize(g, 500, 500);
<# magenta>// Suppress extreme scale values '-0.1' and '1.1', to improve the optics of the graph:
<# blue>LabelString = text(" ,",  ladder(11, 0, 1), ", "); <# magenta>// '11' being one less than the no. of axis segments (as defined in the 'grid(.)' statement above).
<# blue>scaleoverx(g, LabelString);    scaleovery(g, LabelString);


<# black><B>COLOUR NAMES RECOGNIZED</B>
These are colour names used in .NET (for which this program was originally written). You can see by the demonstration that some are more suitable than others against a pale background (like this). The names are not case-sensitive; you might choose to use e.g. "LawnGreen" rather than "LAWNGREEN" (the form given below).
<stops 200>
<# black>ALICEBLUE     <# ALICEBLUE>\t####################<# black>
ANTIQUEWHITE     <# ANTIQUEWHITE>\t####################<# black>
AQUA     <# AQUA>\t####################<# black>
AQUAMARINE     <# AQUAMARINE>\t####################<# black>
AZURE     <# AZURE>\t####################<# black>
BEIGE     <# BEIGE>\t####################<# black>
BISQUE     <# BISQUE>\t####################<# black>
BLACK     <# BLACK>\t####################<# black>
BLANCHEDALMOND     <# BLANCHEDALMOND>\t####################<# black>
BLUE     <# BLUE>\t####################<# black>
BLUEVIOLET     <# BLUEVIOLET>\t####################<# black>
BROWN     <# BROWN>\t####################<# black>
BURLYWOOD     <# BURLYWOOD>\t####################<# black>
CADETBLUE     <# CADETBLUE>\t####################<# black>
CHARTREUSE     <# CHARTREUSE>\t####################<# black>
CHOCOLATE     <# CHOCOLATE>\t####################<# black>
CORAL     <# CORAL>\t####################<# black>
CORNFLOWERBLUE     <# CORNFLOWERBLUE>\t####################<# black>
CORNSILK     <# CORNSILK>\t####################<# black>
CRIMSON     <# CRIMSON>\t####################<# black>
CYAN     <# CYAN>\t####################<# black>
DARKBLUE     <# DARKBLUE>\t####################<# black>
DARKCYAN     <# DARKCYAN>\t####################<# black>
DARKGOLDENROD     <# DARKGOLDENROD>\t####################<# black>
DARKGRAY     <# DARKGRAY>\t####################<# black>
DARKGREEN     <# DARKGREEN>\t####################<# black>
DARKKHAKI     <# DARKKHAKI>\t####################<# black>
DARKMAGENTA     <# DARKMAGENTA>\t####################<# black>
DARKOLIVEGREEN     <# DARKOLIVEGREEN>\t####################<# black>
DARKORANGE     <# DARKORANGE>\t####################<# black>
DARKORCHID     <# DARKORCHID>\t####################<# black>
DARKRED     <# DARKRED>\t####################<# black>
DARKSALMON     <# DARKSALMON>\t####################<# black>
DARKSEAGREEN     <# DARKSEAGREEN>\t####################<# black>
DARKSLATEBLUE     <# DARKSLATEBLUE>\t####################<# black>
DARKSLATEGRAY     <# DARKSLATEGRAY>\t####################<# black>
DARKTURQUOISE     <# DARKTURQUOISE>\t####################<# black>
DARKVIOLET     <# DARKVIOLET>\t####################<# black>
DEEPPINK     <# DEEPPINK>\t####################<# black>
DEEPSKYBLUE     <# DEEPSKYBLUE>\t####################<# black>
DIMGRAY     <# DIMGRAY>\t####################<# black>
DODGERBLUE     <# DODGERBLUE>\t####################<# black>
FIREBRICK     <# FIREBRICK>\t####################<# black>
FLORALWHITE     <# FLORALWHITE>\t####################<# black>
FORESTGREEN     <# FORESTGREEN>\t####################<# black>
FUCHSIA     <# FUCHSIA>\t####################<# black>
GAINSBORO     <# GAINSBORO>\t####################<# black>
GHOSTWHITE     <# GHOSTWHITE>\t####################<# black>
GOLD     <# GOLD>\t####################<# black>
GOLDENROD     <# GOLDENROD>\t####################<# black>
GRAY     <# GRAY>\t####################<# black>
GREEN     <# GREEN>\t####################<# black>
GREENYELLOW     <# GREENYELLOW>\t####################<# black>
HONEYDEW     <# HONEYDEW>\t####################<# black>
HOTPINK     <# HOTPINK>\t####################<# black>
INDIANRED     <# INDIANRED>\t####################<# black>
INDIGO     <# INDIGO>\t####################<# black>
IVORY     <# IVORY>\t####################<# black>
KHAKI     <# KHAKI>\t####################<# black>
LAVENDER     <# LAVENDER>\t####################<# black>
LAVENDERBLUSH     <# LAVENDERBLUSH>\t####################<# black>
LAWNGREEN     <# LAWNGREEN>\t####################<# black>
LEMONCHIFFON     <# LEMONCHIFFON>\t####################<# black>
LIGHTBLUE     <# LIGHTBLUE>\t####################<# black>
LIGHTCORAL     <# LIGHTCORAL>\t####################<# black>
LIGHTCYAN     <# LIGHTCYAN>\t####################<# black>
LIGHTGOLDENRODYELLOW     <# LIGHTGOLDENRODYELLOW>\t####################<# black>
LIGHTGRAY     <# LIGHTGRAY>\t####################<# black>
LIGHTGREEN     <# LIGHTGREEN>\t####################<# black>
LIGHTPINK     <# LIGHTPINK>\t####################<# black>
LIGHTSALMON     <# LIGHTSALMON>\t####################<# black>
LIGHTSEAGREEN     <# LIGHTSEAGREEN>\t####################<# black>
LIGHTSKYBLUE     <# LIGHTSKYBLUE>\t####################<# black>
LIGHTSLATEGRAY     <# LIGHTSLATEGRAY>\t####################<# black>
LIGHTSTEELBLUE     <# LIGHTSTEELBLUE>\t####################<# black>
LIGHTYELLOW     <# LIGHTYELLOW>\t####################<# black>
LIME     <# LIME>\t####################<# black>
LIMEGREEN     <# LIMEGREEN>\t####################<# black>
LINEN     <# LINEN>\t####################<# black>
MAGENTA     <# MAGENTA>\t####################<# black>
MAROON     <# MAROON>\t####################<# black>
MEDIUMAQUAMARINE     <# MEDIUMAQUAMARINE>\t####################<# black>
MEDIUMBLUE     <# MEDIUMBLUE>\t####################<# black>
MEDIUMORCHID     <# MEDIUMORCHID>\t####################<# black>
MEDIUMPURPLE     <# MEDIUMPURPLE>\t####################<# black>
MEDIUMSEAGREEN     <# MEDIUMSEAGREEN>\t####################<# black>
MEDIUMSLATEBLUE     <# MEDIUMSLATEBLUE>\t####################<# black>
MEDIUMSPRINGGREEN     <# MEDIUMSPRINGGREEN>\t####################<# black>
MEDIUMTURQUOISE     <# MEDIUMTURQUOISE>\t####################<# black>
MEDIUMVIOLETRED     <# MEDIUMVIOLETRED>\t####################<# black>
MIDNIGHTBLUE     <# MIDNIGHTBLUE>\t####################<# black>
MINTCREAM     <# MINTCREAM>\t####################<# black>
MISTYROSE     <# MISTYROSE>\t####################<# black>
MOCCASIN     <# MOCCASIN>\t####################<# black>
NAVAJOWHITE     <# NAVAJOWHITE>\t####################<# black>
NAVY     <# NAVY>\t####################<# black>
OLDLACE     <# OLDLACE>\t####################<# black>
OLIVE     <# OLIVE>\t####################<# black>
OLIVEDRAB     <# OLIVEDRAB>\t####################<# black>
ORANGE     <# ORANGE>\t####################<# black>
ORANGERED     <# ORANGERED>\t####################<# black>
ORCHID     <# ORCHID>\t####################<# black>
PALEGOLDENROD     <# PALEGOLDENROD>\t####################<# black>
PALEGREEN     <# PALEGREEN>\t####################<# black>
PALETURQUOISE     <# PALETURQUOISE>\t####################<# black>
PALEVIOLETRED     <# PALEVIOLETRED>\t####################<# black>
PAPAYAWHIP     <# PAPAYAWHIP>\t####################<# black>
PEACHBUFF     <# PEACHBUFF>\t####################<# black>
PERU     <# PERU>\t####################<# black>
PINK     <# PINK>\t####################<# black>
PLUM     <# PLUM>\t####################<# black>
POWDERBLUE     <# POWDERBLUE>\t####################<# black>
PURPLE     <# PURPLE>\t####################<# black>
RED     <# RED>\t####################<# black>
ROSYBROWN     <# ROSYBROWN>\t####################<# black>
ROYALBLUE     <# ROYALBLUE>\t####################<# black>
SADDLEBROWN     <# SADDLEBROWN>\t####################<# black>
SALMON     <# SALMON>\t####################<# black>
SANDYBROWN     <# SANDYBROWN>\t####################<# black>
SEAGREEN     <# SEAGREEN>\t####################<# black>
SEASHELL     <# SEASHELL>\t####################<# black>
SIENNA     <# SIENNA>\t####################<# black>
SILVER     <# SILVER>\t####################<# black>
SKYBLUE     <# SKYBLUE>\t####################<# black>
SLATEBLUE     <# SLATEBLUE>\t####################<# black>
SLATEGRAY     <# SLATEGRAY>\t####################<# black>
SNOW     <# SNOW>\t####################<# black>
SPRINGGREEN     <# SPRINGGREEN>\t####################<# black>
STEELBLUE     <# STEELBLUE>\t####################<# black>
TAN     <# TAN>\t####################<# black>
TEAL     <# TEAL>\t####################<# black>
THISTLE     <# THISTLE>\t####################<# black>
TOMATO     <# TOMATO>\t####################<# black>
TRANSPARENT     <# TRANSPARENT>\t####################<# black>
TURQUOISE     <# TURQUOISE>\t####################<# black>
VIOLET     <# VIOLET>\t####################<# black>
WHEAT     <# WHEAT>\t####################<# black>
WHITE     <# WHITE>\t####################<# black>
WHITESMOKE     <# WHITESMOKE>\t####################<# black>
YELLOW     <# YELLOW>\t####################<# black>
YELLOWGREEN     <# YELLOWGREEN>\t####################<# black>

===============================================================
//COFACTOR//
//SUBMATRIX//
<B>cofactor</B>(<# blue>SquareMatrix, scalar PivotRow, scalar PivotColumn [, scalar DontApplySign]<# black>) -- returns the cofactor of the input matrix; that is, the determinant of the submatrix made by removing the indicated column and row; the determinant is then multiplied by (-1)^(PivotRow + PivotColumn). If the final argument is present and nonzero, this multiplication does not happen (that is, the 'minor' of the matrix is returned, not the 'cofactor'). SquareMatrix must be at least 2x2.

<B>submatrix</B>(<# blue>Matrix, scalar PivotRow, scalar PivotColumn<# black>) -- returns a matrix made from Matrix by removing the indicated column and row. Matrix need not be square but must have at least 2 rows and 2 columns.
===============================================================
//COLOP -- see ROWOP
//COLVEC -- see DATA
===============================================================
//CONVOLUTION//
<B>convolution</B>(<# blue>array Fn1, array Fn2, scalar XStep<# black>) -- computes the convolution of the two discrete functions represented by arrays Fn1 and Fn2 (which must have equal length). Suppose that the horizontal axis of the functions' graph is scaled in x. And suppose that the scaling of this X axis is such that for element Fn1[0], the value of x is Xmin, and for the last element of Fn1 the value of x is Xmax. Then the continuous equivalent of the convolution calculated here is

\t<& 8747><v>Xmin<^>X</^>  Fn1(u)<B>.</B>Fn2(X - u) du,

where 'X' takes every value from Xmin to Xmax. As a consequence, the returned convolution array will have the same length as Fn1 and Fn2.

'XStep' is the difference{ (X at Fn1[n+1]) - (X at Fn1[n]) }.

<B>Example</B>

<# magenta>// CONVOLUTION DEMO, using that the convolution of functions 2*t and t^3  is  t^5/10. 
<# magenta>// 
<# magenta>// Set the range for 't', and the unit of discretization of 't' (call it 'deltaT'):
<# blue>Tmin = 0;  Tmax = 2;  Trange = Tmax - Tmin;
<# blue>noPoints = 1001;
<# blue>deltaT = Trange / (noPoints-1);
<# magenta>// Build an array consisting of all values of 't' within the range:
<# blue>tt = ladder(noPoints, Tmin, Tmax);
<# magenta>// Define the two functions, calling them Fn1 and Fn2.
<# blue>Fn1 = 2 * tt;
<# blue>Fn2 = tt^3;
<# magenta>// Graph them, for posterity:
<# blue>pFn1 = plot(Fn1, tt, ' ',-1,-1, '_',1,'blue');
<# blue>pFn2 = plot(Fn2, tt, ' ',-1,-1, '_',1,'green');

<# magenta>// DEVELOP THE CONVOLUTION
<# blue>Conv = convolution(Fn1, Fn2, deltaT);
<# magenta>// Plot it on the same graph as the above plots:
<# blue>pConv = plot(Conv, tt, '.', 3, 'red', '_', 1, 'red');
<# blue>g1 = graph(pFn1, pFn2, pConv);
<# blue>header(g1, "CONVOLUTION OF \<b>2t\</b> AND \<b>t\<sup>3\</sup>\</b>");
<# blue>footer(g1, "\<# black>Colour coding:  \<# blue>\<b>2t\</b>; \<# green> \<b>t\<^>3\</^>\</b>; \<# red> \<b>Convolution\</b>.");

<# magenta>// Plot the known answer on a separate graph, for comparison
<# blue>answer = tt^5 / 10;
<# blue>pAns = plot(answer, tt, '.', 3, 'magenta', '_', 1, 'magenta');
<# blue>g2 = graph(pAns);
<# blue>grid(g2, readgrid(g1)); <# magenta>// Force the second graph to have exactly the same scaling as the first.
<# blue>header(g2, "SEPARATE SOLUTION:  \<b>t\<sup>5\</sup>\</b>");



===============================================================
//COMPARE//
//COMPARETO//
//EQUAL//
<B>COMPARING ARRAYS</B>

Three functions are available for this; all three allow you to compare a variable extent of two arrays. Function <# blue>equal(..)<# black> gives a simple 'true' or 'false' answer - the extents are equal or are not; functions <# blue>compare(..)<# black> and <# blue>compareto(..)<# black> give much more information about the outcome of comparison.


<B>equal</B>(<# blue>Array1, Array2,  scalar / array HowFar<# black>) -- If the two arrays are exactly equal for the indicated extent, then TRUE is returned; otherwise FALSE. No other information is given.

The extent for comparison is indicated as follows.
<bullet>If HowFar is scalar, it is the extent of comparison, taken from the starts of the arrays. For example, the two arrays "abcd" and "abcx" would return TRUE for HowFar = 3 but False for HowFar = 4. If HowFar is negative or zero, or if it exceeds the length of Array1, then it is set to the length of Array1.
<bullet>If HowFar is an array, then it is sought in Array1 (only). If found, the extent will be the length of data in Array1 to before the find. For example, if HowFar is "?", and Array1 is "abc?d", then TRUE would be returned for Array2 = "abcx". If the array HowFar is not found in Array1, then the extent for searching defaults to the length of Array1.


<B>compare</B>(<# blue>Array1, Array2 [, Scalar CutOff [, Scalar FirstPtr [, Scalar Extent] ] ]<# black>) -- compares two arrays, and returns an array of length 9, holding statistics re the differences. No notice is taken of array structure; only the data is compared. If CutOff is supplied, any difference below that level will be ignored in the calculation of all parameters.

If the last two pointers are missing, the extent used for comparison will be the length of the shorter of the two arrays. If one or both extent arguments are supplied, they must indicate a range which is contained in both arrays.

<B>compareto</B>(<# blue>Array1, Array2, Scalar CutOff, Scalar FirstPtr, Scalar LastPtr<# black>) -- differs from the above only in that all arguments must be supplied, and in that the last argument states the last position in the extent.

<B>Statistics:</B> In what follows, the ith. divergence is calculated as Array1[i] - Array2[i]. Also, all elements except [0] below apply only to differences within the extent as defined above.

<B>The returned array:</B> 
\t[0] is the difference in array lengths (first - second); 
\t[1] points to the first divergence (if none, = -1); 
\t[2] points to the last divergence (if none, = -1); 
\t[3] is the maximum positive difference; 
\t[4] is the maximum negative difference; 
\t[5] is the maximum absolute difference; 
\t[6] is the average difference; 
\t[7] is the average <I>absolute</I> difference; 
\t[8] is the root-mean-square of differences.
============================================================
//COMPLEX//
//REAL//
//POLAR//
<B>COMPLEX NUMBERS</B>

Several <I>MiniMaths</I> functions deal with complex numbers. A single complex number is represented as an array of size 2. If it is in 'polar' form, then element [0] represents the absolute value, and element [1] the phase angle. If in 'rectangular' form, then [0] represents the real part and [1] the imaginary part. (You have to keep account of whether a number is in polar or rectangular form, as there is no tag associated with the array to indicate its form.)

In the case of arrays of complex numbers, every [2n]th element ('n' zero or a positive integer) represents the real / absolute value part, and every [2n+1]th element the imaginary / phase angle part.

When inputting complex numbers in polar form to an array, realize that it is illegal for the [2n]th element to be negative.

Manipulations of complex numbers typically produce small numbers, typically around +/- 1e-15 or so, where a zero would be expected. Functions that handle complex numbers therefore usually have an optional argument below which values will be considered to be zero; 1e-10 is a good choice.

<U>CONVERSION FUNCTIONS</U>
<B>polar</B>(<# blue>Var1 [, VirtualZero]<# black>) -- Nonvoid; given a complex array in rectangular form, returns its polar equivalent. If VirtualZero is present and non-negative, then any amount with absolute value smaller than it is treated as zero, for both the input and output.
 
<B>rect</B>(<# blue>Var1 [, VirtualZero]<# black>) -- Nonvoid; given a complex array in polar form, returns its rectangular equivalent. VirtualZero has the same meaning as for the above function.

<B>merge</B>(<# blue>ArrReal, ArrImag) <# black> -- This function will merge any number of arrays, but for the present purpose we only need it to merge two arrays.
Here we can use it to generate a complex array from two 'real' arrays. The output is an array with the data of the two variables alternated. For example:
	<# blue>ArrReal = data(1, 2, 3);    ArrImag = data(100, 200, 300);    Result = merge(ArrReal, Arr2Imag);  <# magenta>// produces the array { 1, 100, 2, 200, 3, 300 }.<# black>
The two arrays must have the same size. The output is a list array, whatever the structure of the arguments.

<B>unmerge</B>(<# blue>CxArray, REF RealArray, REF ImagArray<# black>) -- This function can redistribute ('bin') the contents of the first array (structure ignored) to any number of subsequent REF argument arrays, but for the present purpose we only need it to redistribute to two arrays. Arguments RealArray, ImagArray have to be predefined as arrays, but will be recreated as list arrays of sufficient length to hold data from CxArray. The <b>return value</b> indicates whether all of the data in CxArray is used (if so, it is 0). If the length of CxArray is not an exact multiple of the number of REF arguments, then there will be data left over, and the return value will tell how much.


<U>BINARY OPERATIONS BETWEEN COMPLEX NUMBERS</U>
One function serves them all...
<B>complex</B>(<# blue>Array1,  Var2,  Array Operation, Array PolRect [, scalar VirtualZero]<# black>) -- Do a complex mathematics binary operation between two variables. 

For this function, <B>Array1</B> is such an array, and <B>Var2</B> is one of: (a) a scalar; (b) an array of size 2, hence representing a single complex number; (c) an array of the same size as Array1. <B>Operation</B> is an array with at least one element (no other is accessed); Operation[0] must be one of: '+', '-', '*', '/', '^'. It is the binary operation which applies between Array1 and Var2. Finally, <B>PolRect</B> is an array which describes whether variables are in polar form (i.e. element [2n] is an absolute value, [2n+1] is an angle) or rectangular form (each complex number being ([2n] + j.[2n+1]). PolRect entries can be either 'P' (or 'p') for 'polar', and 'R' (or 'r') for 'rectangular'. This array must have length of at least 3 (only the first 3 are accessed). [0] applies to the form of Array1, [1] applies to Var2, and [2] is the format desired for the output array.

If Var2 is an array of the same size as Array1, then the operation is carried out separately between each matching pair of complex numbers in the two arrays. If Var2 is a single complex number (i.e. an array of size 2), every complex number in Array1 is operated on with the one complex value in Var2. If Var2 is scalar, say of value 'x', the effect is exactly the same as if it were the complex number 'x + j.0' (or if in polar form, 'x angle 0'.).

<B>VirtualZero</B> is a small value - for example, 1e-10; any element in any input or output array of the function which has an absolute value smaller than this is converted to exactly 0. This argument should usually be supplied, especially if internal conversions between rect. and polar forms are involved.

<B>Errors that crash the function:</B> (1) In an array designated to be 'polar' by PolRect, a [2n] value is negative. (2) Attempted division by polar value [0 angle anything] or by rect. value [0 + j.0]; (3) The operation is '^' and Var2 is other than real number(s) (i.e. has nonzero imaginary component(s) ).

Examples of Use:

<# blue>cxarr1 = data(1, 2, 3, 4);     cxarr2 = data(0.1, 0.2, 0.3, 0.4);
<# blue>cxarr3 = complex(cxarr1, cxarr2, '+', 'RRR');  <# magenta>// all arrays are in rect. form. The output array will be: [1.1,  2.2,   3.3,  4.4].
<# blue>cxarr3 = complex(cxarr1, cxarr2, '+', 'RRP');  <# magenta>// the same sum, but with output converted to polar form -  [2.46, 1.11, 5.5, 0.93 ] (to 2 dec. places).
<# blue>cxarr3 = complex(cxarr1, 3, '*', 'RRR');  <# magenta>// All complex numbers in cxarr1 are multiplied by 3, giving: [3, 6, 9, 12].
============================================================
//COPY//
//COPYTO//
//SPAN//
//BETWEEN//
//INSERT//
//DELETE//
//DELETETO//
//REPLACE//
//REPLACETO//
<B> ARRAY MANIPULATIONS</B>

Several functions of the sort commonly used in programming languages for string manipulation have been implemented in <I>MiniMaths</I>.

All of them return copies of an input array, with alterations. The original input array is not affected. All of them ignore the structure of input array, and return a list array. The 'characters' rating of the input array is transferred to the returned array. A null array is never returned; if the arguments would return so (e.g. copying an extent of size zero), an array of size 1 is returned, with its only element = NaN; a call to 'empty(.)' would return 'true'.

<i>Improper arguments</i> for 'copy', 'copyto' and 'between': (1) FromPtr / StartPtr < 0 is reset to 0; (2) Extent / ToPtr / EndPtr too large are reset so as to include the end of the input array in what is returned. (3) Crossed pointers, or Extent <= 0, produce the 'empty' array just mentioned.

<B>copy</B>(<# blue>Input Array, Scalar FromPtr [, Scalar Extent]<# black>) -- returns copy of part of an input array, from FromPtr onwards, to a length of Extent. If Extent exceeds the array length, all of the array from FromPtr onwards is copied.

<B>copyto</B>(<# blue> Input Array, Scalar FromPtr, Scalar ToPtr<# black>) -- returns an array copied from the input array, from FromPtr to ToPtr inclusive. If ToPtr exceeds the array length, all of the array from FromPtr onwards is copied.
<I>Silly arguments for the above two functions:</I>  It is safe to make 'extent' (or 'end point') oversized, as it will be automatically downsized to include the rest of the array. Also, a negative start point is reset to 0 (the beginning of the array). After these adjustments, any situation which would return a sensible array does so (as just explained). But if it would logically return a null array (e.g. crossed pointers, or extent <= 0), it in fact returns an array of size 1 and value NaN; a call to 'empty(.)' will return TRUE:
\t<# blue>subarr = copy(arr, 5, x);   if (empty(subarr) ){ show("Oopsie!");  exit; }; <# magenta>// True, if x <= 0.
<# black>
<B>between</B>(<# blue>InArray, scalar StartPtr, scalar EndPtr<# black>) -- copies the subarray of InArray that lies BETWEEN StartPtr and EndPtr exclusive, producing a list array (i.e. not copying the structure of a structured array). E.g. for InArray = [10, 11, 12, 13, 14, 15], 'between(InArray,1, 4)' produces [12, 13]. If StartPtr is negative the returned subarray starts from InArray[0]. If EndPtr is beyond the end of the array, the returned array includes the end of InArray.  Where arguments would indicate a subarray of length 0 or negative length, the empty array (value NaN, size 1) is returned.
	______________

<i>Improper arguments</i> For 'delete', 'deleteto', 'insert', 'replace', 'replaceto': Pointers behave as if the input array extended to infinity in both directions with null characters; e.g. 'delete' with FromPtr -3 and Extent 4 will delete the first character of the array (as well, notionally, as null characters [-3] to [-1]). If pointers cross or extent <= 0, the whole input array is returned.

<B>delete</B>(<# blue>array Original,  scalar FromPtr [,  scalar Extent]<# black>) -- returns a list array which is a copy of Original, but with all data excised from FromPtr for extent Extent. (If that would mean all data was excised, instead the return is an array of size 1, value NaN; and a call to 'empty(.)' would return TRUE.)
If Extent is missing, all of the array from FromPtr onwards is omitted from the copy.  
If Extent exceeds the array length, all of the array from FromPtr onwards is removed. Negative or zero Extent, or FromPtr beyond the end, all return an unaltered copy of Original. If FromPtr is negative, behaviour is as if Original had a virtual extention with negative indices; that is, FromPtr of -n and Extent of n+k has the same effect as FromPtr of 0 and Extent of k.
The output array retains the "characters" setting of the input array, but is always a list array.

<B>deleteto</B>(<# blue>array Original,  scalar FromPtr,  scalar ToPtr<# black>) -- returns a list array which is a copy of Original, but with all data excised from FromPtr to ToPtr inclusive. (If that would mean all data was excised, instead the return is an array of size 1, value NaN; and a call to 'empty(.)' would return TRUE.) 
If ToPtr exceeds the array length, all of the array from FromPtr onwards is removed. If ToPtr is less than FromPtr, an unaltered copy of Original is returned. If FromPtr is negative, it is reset to 0.
The output array retains the "characters" setting of the input array, but is always a list array.

<B>insert</B>(<# blue>InputArray, Scalar AtPtr,  scalar/array InsertThis<# black>) -- returns a list array which is  a copy of the data of InputArray with 'InsertThis' inserted at AtPtr.
If AtPtr is less than 0 or more than the length of InputArray, a simple copy of the data of InputArray is returned. (If AtPtr = the length of InputArray, the effect is to append the data.)
The returned array is always a list array, but retains the 'characters' rating of InputArray.

<B>replace</B>(<# blue>array Original,  scalar FromPtr,  scalar Extent,  scalar / array Replacement<# black>) -- returns a list array which is a copy of Original, but with all data excised from FromPtr for extent Extent; the excised data is replaced by Replacement.
If Extent exceeds the array length, all of the array from FromPtr onwards is replaced. Negative or zero Extent, or FromPtr beyond the end, all return an unaltered copy of Original. If FromPtr is negative, behaviour is as if Original had a virtual extention with negative indices; that is, FromPtr of -n and Extent of n+k has the same effect as FromPtr of 0 and Extent of k.
The output array retains the "characters" setting of the input array, but is always a list array.

<B>replaceto</B>(<# blue>array Original,  scalar FromPtr,  scalar ToPtr,  scalar / array Replacement<# black>) -- returns a list array which is a copy of Original, but with all data excised from FromPtr to ToPtr inclusive; the excised data is replaced by Replacement. 
If ToPtr exceeds the array length, all of the array from FromPtr onwards is replaced. If ToPtr is less than FromPtr, an unaltered copy of Original is returned. If FromPtr is negative, it is reset to 0.
The output array retains the "characters" setting of the input array, but is always a list array.
	______________

<B>substitute</B>(<# blue>Input Array, ....., Replacement<# black>) -- returns a copy of the input array with certain values replaced by Replacement. Enter 'substitute' in the Assignments Window and then key F1, to get details on its use.

<B>span</B>(<# blue>SourceArray, array (scalar) Bookmark1, array (scalar) Bookmark2 [, scalar FromPtr [, scalar ToPtr ] ]<# black>) -- returns data from SourceArray which lies between bookmarks. If FromPtr ± ToPtr are supplied, they represent the first and last values in SourceArray which will be examined; the rest of SourceArray will be treated as if it did not exist.

A bookmark is an array; for example, if the SourceArray were [0, 1, 2, 3, 4, 5, 6, 7, 8], and Bookmark1 were [1, 2] and Bookmark2 [5, 6, 7], then the function would return the subarray [3, 4]. Exceptions: If Bookmark1 is scalar (any value - not accessed), then all is taken from the start of SourceArray (or FromPtr inclusive, if supplied) to Bookmark2. Likewise if Bookmark2 is scalar, all is taken from Bookmark1 to the end of SourceArray (or to ToPtr inclusive, if supplied). 

RETURNED: This requires care, as <i>the return can be scalar or an array</i>.
<bullet>If a nonempty subarray is found, it is always returned as a list array (with the same chars. rating as SourceArray).
<bullet>If Bookmark1 is not found, SCALAR 1 is returned.
<bullet>If it is (or if there was no Bookmark1), but Bookmark2 is not found, SCALAR 2 is returned.
<bullet>If the returned array would logically be empty, the 'empty' array [NaN] is returned. This happens if (a) Bookmark1 and Bookmark2 are contiguous; (b) if there is no Bookmark1, but Bookmark2 is right at the start of SourceArray (or at FromPtr, if supplied); or (c) if there is no Bookmark2, but Bookmark1 is right at the end of SourceArray (or ends at ToPtr, if supplied).

Note that after this function has found the first instance of BookMark1 it then seeks the first instance of BookMark2; if there are any further instances of BookMark1 between the first Bookmark1 and the first Bookmark2, they will be included in the returned array.

The function only crashes the program if SourceArray is not an array, or if both bookmarks are scalars. Errors in FromPtr and ToPtr are handled like this: FromPtr \< 0 is corrected to 0, and ToPtr beyond the end of SourceArray is corrected to its last character. If the pointers are crossed, the return is scalar (1 or 2, depending on the deployment of book mark arguments).


See also functions <b>getsegmt</b> and <b>findsegmt</b>, which operate on an array containing delimiters (e.g. '|' in "01|23|45"), a "segment" being one of the delimited subarrays.


<U>Some examples using the COPY functions</U>

<HANGIN><# blue>Arr = data(0,1,2,3,4,5,6,7,8,9,10);
Brr = copy(Arr, 4, 2); <# magenta>// Brr becomes [4,5]
<# blue>Brr = copyto(Arr, 4, 7); <# magenta>// Brr becomes [4,5,6,7]

<# blue>Brr = copy(Arr, 4); <# magenta>// Brr becomes [4,5,6,7,8,9,10] - i.e. all from 4 onwards.
<# blue>Brr = copy(Arr, 4,999); <# magenta>// Brr becomes all from 4 onwards. (Both 'Extent' of 'copy(..)' and 'ToElement' of 'copyto(..)' are corrected down, if oversized.
<# blue>Brr = copy(Arr, 4, 0); <# magenta>// Null array not allowed, so Brr becomes an array of size 1, with its only element zero.

============================================================
//COPYCOLS  --  see  INSERTROWS
//COPYCOLSTO  --  see  INSERTROWS
============================================================
//COPYMX//
//COPYMXTO//
<B>copymx</B>(<# blue>Matrix, Scalar  FirstRow, Scalar  FirstColumn [, Scalar NoRows [, Scalar NoColumns] ]<# black>) -- returns a submatrix copied from Matrix. Unlike with function "copy(.)", there is no adjustment of arguments; they must be consistent with the dimensions of Matrix. If NoRows is omitted, all rows to the end of Matrix will be included; likewise if NoCols is omitted, all columns to the last column of Matrix will be included.

<B>copymxto</B>(<# blue>Matrix, Scalar  FirstRow, Scalar  FirstColumn, Scalar LastRow, Scalar LastColumn<# black>) -- returns a submatrix copied from Matrix. Unlike with function "copyto(.)", there is no adjustment of arguments; they must be consistent with the dimensions of Matrix.

See also: copyrows(.),  copyrowsto(.),  copycols(.),  copycolsto(.).
============================================================
//COPYROWS  --  see  INSERTROWS
//COPYROWSTO  --  see  INSERTROWS
//COPYSHAPE  --  see PLOTSHAPE
============================================================
//CORRELATION//
<B>correlation</B>(<# blue>array Fn1, array Fn2, scalar XStep, variable XOffset [,FirstIndex [, LastIndex ] ]<# black>) -- computes the correlation integral for discretized functions Fn1 and Fn2; that is, 

\t<& 8747><v>a<^>b</^>  Fn1(x)<b>.</b>Fn2(x + XOffset) dx 

(Note the '+' sign. You must adjust the sign of XOffset if you want a minus sign there.)

Fn1 and Fn2 must be arrays, though not necessarily of the same length. (The algorithm regards Fn2 as having an infinite extent of indices from minus infinity to plus infinity, all array values for out-of-range indices being zero.) 

XStep is the approximation to 'dx' of the above integral, being the X-axis distance between Fn1[n] and Fn1[n+1]. 

If XOffset is scalar, a scalar value is returned; if XOffset is an array, an array is returned, with correlation value [n] corresponding to XOffset[n].

'FirstIndex' and 'LastIndex': Normally the range of integration will be over the full extent of Fn1. (In the integral shown above, 'a' is the X-value of Fn1[0], 'b' the X-value of Fn1[last element].) If a smaller range of Fn1 is to be accessed, either or both of these may be set appropriately; but realize that they are <I>indexes</I> of Fn1, not X-axis scaled values. If either is supplied but is out of range for Fn1, it will be adjusted back to the start / end of Fn1. These two arguments do not raise errors; e.g. FirstIndex > LastIndex will simply return a correlation of 0.

<B>Example</B>

<# magenta>// DEMO OF CORRELATION -- the correlation of two impulses (square peaks).
<# magenta>//
<# magenta>// Develop the function values:
<# blue>noPoints = 101;
<# blue>dim(Fn1, Fn2, noPoints);
<# blue>peak = fill(25, 1); <# magenta>// an array of 25 '1's
<# blue>Fn1 = overlay(Fn1, 2 * peak, '#', 50); <# magenta>// Fn1 is now 2 from Fn1[50] to Fn1[74], and zero elsewhere.
<# blue>Fn2 = overlay(Fn2, 3 * peak, '#', 70); <# magenta>// Fn2 is now 3 from Fn2[70] to Fn2[94], and zero elsewhere.
<# magenta>// Develop the X-axis values for plotting:
<# blue>lowX = -2; highX = 2; rangeX = highX - lowX;
<# blue>xx = ladder(noPoints, -2, 2); <# magenta>// Both functions will be plotted across the range from X = -2 to X = +2.
<# blue>deltaX = rangeX / (noPoints - 1); <# magenta>// The X distance between successive elements of Fn1.
<# magenta>// Plot the functions:
<# blue>plot1 = plot(Fn1, xx, '.', 3, 'blue', '_', 2, 'blue');
<# blue>plot2 = plot(Fn2, xx, '.', 3, 'magenta', '_', 2, 'magenta');
<# blue>grid(lowX, highX, rangeX/0.2,   -0.5, 6, 13);

<# magenta>// DEVELOP THE CORRELATION
<# magenta>// We will choose correlation offsets = xx above, so that the fns. and their correlations will all fit nicely on one graph:
<# blue>offset = xx;
<# blue>Corrn = correlation(Fn1, Fn2, deltaX,  offset);
<# magenta>// Plot the correlation:
<# blue>plot3 = plot(Corrn, offset, '.', 3, 'red', '_', 2, 'red');
<# blue>g = graph(plot1, plot2, plot3);
<# blue>placeboard(g, 0, 0, 1, 1); <# magenta>// Maximize the graph, as it otherwise looks a bit crowded.
<# blue>header(g, "CORRELATION OF TWO IMPULSES (Fn1 and Fn2)");
<# blue>ss = text("Curves represent \<# blue\>Fn1, \<# magenta\> Fn2 \<# black\>and the \<# red\>correlation integral\<# black\> \<& 8747\>\<v\>-2\<^\>+2\</^\>  Fn1(x)\<B\>.\</B\>Fn2(x + XOffset) dx\\n");
<# blue>footer(g, ss);
============================================================
//COS -- see TRIGONOMETRY
============================================================
//COUNT//
<b>count</b>(<# blue>array Subject, array/scalar CountThis [, scalar StartHere [, EndHere ] ]<# black>) -- returns the number of instances of "CountThis" either in the whole of Subject (where there are just two arguments) or in the subarray of Subject which lies between pointers StartHere and EndHere inclusive.

Pointers out of range are adjusted back to the appropriate limit.

If timing is critical and "CountThis" is a single value, enter it as a scalar rather than as a one-valued array, as the search algorithm is then significantly faster.
============================================================
//COUNTER  --  see ODOMETER
============================================================
//CRASH//
<B>crash</B>(<# blue> One or more variables or literals <# black>) -- Raises an error, causing the program to crash. The error message (which is the function's arguments) is displayed in the Results Window. The arguments are handled exactly as for display functions such as <B>write(..)</B>.

\t<# blue>speed = 210;
\t<# blue>CheckSpeed(speed);
\t<# blue>function CheckSpeed(x)
\t<# blue>{\tif (x > 200)
\t<# blue>\t{\tcrash("You drove too fast and have just hit a tree. Farewell.");  }
\t<# blue>}
============================================================
//CULL -- see CLEAR
//CURRENTDIRECTORY -- see CHECKDIRECTORY
============================================================
//CURSORDATA//
//CURSORPOSN//
<just c><b>FUNCTIONS INVOLVING THE CURSOR</b>
<just l>
Function <b>cursorposn(.)</b> returns the current character position of the cursor, and gives the option of moving it first. Function <b>cursordata(.)</b> returns the word at the cursor's current position, optionally with positional data.


<b>cursorposn(</b><# blue> array Window [, scalar NewPosn ] <# black>)  -- Returns the current cursor position in the window specified (which must be 'A' for the Assignments Window, or 'R' for the Results Window; any other value will cause a return of -1). If NewPosn is \< 0, no movement occurs. If beyond the end of the text, it is reset to be at the end of text. (If you want to be sure that the cursor will move to the end of text, set NewPosn to something impossibly large, like MAXREAL). If this function has moved the cursor, the return value is its final position.



<b>cursordata(</b><# blue> [ bool Verbose ] <# black>)  -- Returns the text at the cursor, and optionally some more data.
<i>Verbose</i> absent or FALSE:  Returns the text at the cursor as a list array, chars. rating.
If there was a selection, then selected text is returned. If there was no selection, then a string of eligible characters (i.e. A..Z, a..z, 0..9, '_') is sought either touching or containing the cursor. If found, that string is returned; if not found (e.g. only space or punctuation marks on either side of the cursor), then a single space is returned (but never the 'empty' array).
<i>Verbose</i> present and TRUE: Returns a chars. array exactly as above, but with the following four extra elements at the end:
	[MAXREAL]
	[pointer to first char. of the word, relative to the start of all text]
	[ponter to last char. of the word]
	[1, if there had been a selection; otherwise 0].

If no word could be found, the whole returned array is:  [SPACE] [MAXREAL] [-1] [-1] [0].

============================================================

   case 419: // CURSORPOSN(array Window [,  scalar Where ] ) -- returns the final cursor position. If a second arg, moves it first.
    // 'Where' = desired character position for placement. If rounds to below zero, reset to 0; if beyond end of text (e.g. MAXREAL), at end.



============================================================
//CURVEFIT -- see POLYNOMIAL
============================================================
//DATA//
//ROWVEC//
//COLVEC//
//MATRIX//
<B>DIRECTLY FILLING ARRAYS WITH DATA</B>

In all the following cases, "Values" stands for any number and any mix of scalars and arrays. In all cases, the output will have non-chars. rating.

<bullet><B>data(Values)</B> returns a list array.
<bullet><B>rowvec(Values)</B> returns a row vector filled with Values; dimensions will be  (1 x length of Values).
<bullet><B>colvec(Values)</B> returns a column vector filled with Values; dimensions will be (length of Values x 1).
<bullet><B>matrix(scalar NoRows, scalar NoCols [,   Values ] )</B> returns a matrix of given dimensions. If there is no third argument, all elements will be zero. Otherwise the data is cycled through until all locations in the returned matrix have been filled, row by row. For example,
		 <# blue>matrix(2, 3, 99)<# black> returns a matrix in which every element is 99;
		 <# blue>matrix(4, 3, 10, 20, 30)<# black> returns a matrix consisting of four rows, each being [10, 20, 30];
		 <# blue>matrix(2, 2,  10, 20, 30, 40, 50, 60)<# black> returns the matrix [10, 20;  30, 40], extra supplied values being ignored.

Note that the inverse function to 'data(.)' is <B>unpack(.)</B>, which unloads an array's contents into a list of variables.

Very often it is easier simply to use the <b>concatenator operator '#'</b>. The following two lines of code have the same effect:
		<# blue>Arr = data(1, 2, 1+2);  <# magenta>// produces the array [1, 2, 3]<# blue>
		Arr = 1 # 2 # 1+2;  <# magenta>// also produces the array [1, 2, 3]<# black>
You can use '#' in exactly the same way as you use other arithmetic signs. It has a lower hierarchical level than the arithmetic signs (i.e. than any of: + - * / ^), so that arithmetic operations precede concatenation (as in the example above).  Just be aware then in any pair of variables joined by a '#', the chars. rating of the output is that of the first array in the term.

To enter text instead of raw data, use function <B>text(..)</B>.
==================================================================
//DATASTRIP//
<just c><b>READ FROM / WRITE TO ABSOLUTE ADDRESSES IN ARRAYS</b>
<just l>
All arrays are represented in memory as a single extent of data (I think just about every computer language does this.). I call this the "data strip". Normally you access this data using the square-brackets addressing system: "x = Mx[2,3];". But if you want to access the data using its absolute address within this data strip, then use function <b>datastrip</b>, which ignores array structure completely:

	<# blue>x = datastrip(Arr, 5); <# magenta>// READS the 5th. element of the data strip of Arr into 'x'. 

	<# blue>datastrip(Arr, 5, 1.23); <# magenta>// WRITES 1.23 to the 5th. element of the data strip of Arr. <# black>

The second form of the function is void (i.e. always returns just 0).

There is no check for 'Arr' being a named array. "x = datastrip(Arr*Arr, 2)" would be fine. (The Write operation with such a temporary array would not raise an error, but also would not give you any reward for your labours.)


To convert between absolute address and the square-brackets address, use functions <b>offset</b> and <b>indexed</b>.

==================================================================
//DATETIME//
//DATE//
//TIME//
<B>datetime</B>() -- returns an array of size 10 with the following information, taken from the computer clock at the moment when this function is called: 

[0] = year (4-digit version); 
[1] = month (January = 1); 
[2] = calendar day of month; 
[3] = hour of day (0 to 23); 
[4] = minute of the hour; 
[5] = second of the minute; 
[6] = milllisecond of the second;  
[7] = day of week (0 is Sunday, 6 is Saturday); 
[8] = day of year (Jan 1st is 1);

[9] = milliseconds since beginning of 1 AD.

For timing, see <B>timer(.)</B>.
==================================================================
//DEC -- see INC
============================================================
//DECIDE//
<B>decide</B>(<# blue>Three to six arrays, followed optionally by up to four scalars<# black>) -- Displays a box asking for a decision, and offering one to four buttons for a response. 

The arguments: (Heading Text, Body Text, Button1 Text [, Button2 Text [, Button3 Text [, Button4 Text ] ] ]   [, scalar Width [, scalar Height [, scalar Left [, scalar Top ] ] ] ). 

'Left' and 'Top' apply to the top left corner; if they are missing, the box is centred on the screen. If any scalar is < 1, it is taken as being a fraction of screen width or height (as appropriate).

Buttons appear from left to right in the order given.  Returned: 0 for corner icon closure; otherwise button no., from 1 up, in the order given.

An example:
\t<# blue> cntr = 1;
\t<# blue> while (true)
\t<# blue>{\theading = "LOOPING THE LOOP";   body = text("This is the ", nth(cntr), " loop.  Keep going?");
\t<# blue>\tn = decide(heading, body, "GO ON", "STOP"); <# magenta>// Keep the button texts short!
\t<# blue>if (n != 1)  break;  else cntr++;
\t<# blue>}

<# black>You may use a small number of markup tags in the Body Text; they must be strictly paired with their cancelling tags. These are: \<b> ... \</b>, \<u> ... \</u>, \<i> ... \</i>, \<^> ... \</^> (for superscript), \<v> ... \</v> (subscript).  (These are translated internally into Pango tags - which you would have to google, for details. You can actually use any other Pango tags, but I do not list them here.) 

To set the size of the dialog box to other than the default, use function <b>setbox</b>.

<# black>See also <B>request(.), show(.)</B>
============================================================
//DEFLUFF//
<b>CLEARING VERY TINY VALUES FROM AN ARRAY</b>

Due to rounding errors of the computer, a computed value which logically should be zero may turn out to be e.g. ±1.23e-18. If you want to replace all such values with exactly zero in some array or scalar, you use this function:

<b>defluff</b>(<# blue>NAMED variable Subject,  scalar VirtualZero<# black>) -- a VOID function. All elements in Subject which have an absolute value less than or equal to VirtualZero will be replaced by zero.

An error is raised if Subject is not a named variable.

If VirtualZero is zero or negative, no changes occur to Subject. Also if Subject is a constant, no error is raised, but also nothing happens.

============================================================
//DEG -- see TRIGONOMETRY	
============================================================
//DELETE, DELETETO  --  see COPY
============================================================
//DELETECOLS//
//DELETEROWS//
<B>deleterows</B>(<# blue>Matrix, Scalar FromRow, Scalar Extent<# black>)  OR  <B>deleterows</B>(<# blue>Matrix, Array WhichRows<# black>) -- returns a copy of Matrix, but with the indicated rows removed. (If all rows are marked for deletion, a list array of size 1, value NaN, is returned, and an immediate call to function 'empty(.)' returns 'true'.) In the first case, an extent of contiguous rows is to be removed; in the second case, particular rows anywhere within the matrix.

Faulty 2nd. and 3rd. arguments do not raise errors. If  Extent <= 0, no deletion occurs. If FromRow is negative, rows from 0 to row (FromRow + Extent - 1) will be deleted. If FromRow is beyond the end of the matrix, nothing is deleted. In the second version, values out of range and duplicate values are simply ignored.


<B>deletecols</B>(<# blue>Matrix, Scalar FromCol, Scalar Extent<# black>) OR <B>deletecols</B>(<# blue>Matrix, Array WhichColumns<# black>) -- returns a copy of Matrix, but with the indicated columns removed. Behaves exactly as for 'deleterows(.)'.
============================================================
//DETERMINANT  --  see MATRIX
============================================================
//DIFFERENCES//
<B>differences</B>(<# blue>array Arr<# black>) -- returns a list array consisting of the differences between successive elements of Arr, and therefore of length one less than the length of Arr. (If Arr has length 1, the 'empty' array [ NaN ] is returned.)
\t<# blue>arr = data(1, 10, 100, 1000);
\t<# blue>brr = differences(arr);  <# magenta>// Output array is  [9, 90, 900].
\t<# blue>crr = data(1);
\t<# blue>drr = differences(crr);  <# magenta>// Output array is  [NaN].
==================================================================
//DIFFPOLY -- see POLYNOMIAL
============================================================
//DIM//
//DIMLIKE//
//REDIM//
//REDIMLIKE//
//UNDIM//
//STRUCTURE//
<B>dim</B>(<# blue>\<one or more arrays\>, \<one or more scalars\><# black>) -- void; creates the arrays (or re-creates them, if they were created earlier), and fills them with zeroes. One scalar argument produces a <I>list array</I>: "dim(Arr,10)". Two or more produce <I>structured arrays</I> - "dim(Arr,1,4)" produces a row vector, "dim(Arr,4,1)" a column vector, "dim(Arr,3,3)" a matrix. Up to 5 dimensions are allowed. The scalar arguments are rounded before use.

<B>dimlike</B>(<# blue>\<one or more arrays\>, array Model<# black>) -- void; creates the earlier arrays (or re-creates them, if they were created earlier), and fills them with zeroes. Each will have the dimensions of the final array Model, which must already have been declared.

<B>structure</B>(<# blue>One or more values, contained in any mix of scalars and arrays<# black>) -- returns a structure for which the values are the dimensions. The highest dimension comes first; e.g. to create a 5 x 3 matrix, use 'structure(5, 3)'. All values are zero.


<B>redim</B>(<# blue>\<one or more arrays\> Victims, \<one or more scalars\> Dimensions<# black>) -- A nonvoid function. 'Victims' must have been declared before this. The highest dimension comes first (e.g. row size, then column size, for a matrix). One argument produces a <I>list array</I>: "redim(Arr,10)". Two or more produce <I>structured arrays</I> - "redim(Arr,1,4)" produces a row vector, "redim(Arr,4,1)" a column vector, "redim(Arr,3,4)" a 3x4 matrix. Up to 5 dimensions are allowed. The difference between 'dim' and 'redim' is that 'dim' creates a new array and fills it with zeroes, while 'redim' redimensions an existing array <I>with retention of data</I>. If the new size is smaller, then existing data will be cropped; if the new size is larger, the end is padded with zeroes.
<i>Returned:</i>  the new size(s) minus the old size(s). If there is only one Victim, the return is a scalar; otherwise an array with one element per Victim.

<B>redimlike</B>(<# blue>\<one or more arrays\> Victims, array Model <# black>) -- Precisely as for 'redim(.)' except that 'Dimensions' are not explicitly supplied but are copied from the dimensions of the last argument 'Model'. ('Model' itself is not altered or otherwise accessed.)
<i>Returned:</i>  the new size(s) minus the old size(s). If there is only one Victim, the return is a scalar; otherwise an array with one element per Victim.

<B>undim</B>(<# blue>\<one or more arrays\> Victims <# black>) -- Converts all of Victims to list arrays, with retention of their original total sizes and data. As for the above, Victims must have been declared earlier.
============================================================
//DIMS -- see ARRAY
============================================================
//DISTANCE//
//DISTPOINTS//
//DISTMUTUAL//
//NORM//
//DOT//
//HYPOT//
<B> dot(.), norm(.), hypot(.), distance(.), distmutual(.)</B>


<U>ILLUSTRATING THE DIFFERENCE BETWEEN THESE FUNCTIONS</U>
Suppose there are two arrays, A ( = [a, b, c])  and P ( = [p, q, r]), of equal length L = 3.
<B>dot(A, P)</B> produces <I>scalar</I> value  (a.p +  b.q +  c.r). 
<B>norm(A)</B> produces <I>scalar</I> value  sqrt(a<^>2</^> +  b<^>2</^> +  c<^>2</^>). 
<B>hypot(A, P)</B> produces <I>array</I>  [ sqrt(a<^>2</^> + p<^>2</^>),  sqrt(b<^>2</^> + q<^>2</^>),  sqrt(c<^>2</^> + r<^>2</^>) ].  ('sqrt' is optional.)
<B>distance(A, P)</B> produces <I>scalar</I> value  sqrt{  [  (a - p)<^>2</^> + (b - q)<^>2</^> + (c - r)<^>2</^> ] / L },  L in this case being 3. (Both the taking of the mean and the taking of the square root are optional.)
<b>distmutual(A, P)</b> builds a matrix of mutual Euclidean distances between points (a,p), (b,q), (c,r).
<b>distpoints(.)</b> gives the distance between sets of points in 1-, 2- or 3-dimensional Cartesian space; see below re arguments.

<B>hypot(.)</B> and <B>distance(.)</B> -- either argument may be <I>scalar</I>, in which case the argument is replaced by a virtual array which has the same length as the other argument. For example, using the above variables, 'hypot(a, P)' has the same effect as 'hypot( data[a, a, a], P)'. 
<B>norm(.)</B> and <B>dot(.)</B> cannot take scalar arguments.

_______________________________

<B>dot</B>(<# blue>Array, Array<# black>) -- returns a scalar, the dot product of the structures (i.e. the sum of the term-by-term multiplication of the arrays). The arrays must have the same length; however their dimensioning is irrelevant, not being referenced by the function. 

<B>norm</B>(<# blue>Array<# black>) -- returns a scalar, the Euclidean norm of the array, irrespective of its structure; that is, it returns the square root of the sum of the elements squared. (It has the same effect as "sqrt(dot(arr,arr));" )

<B>hypot</B>(<# blue><Variable1, Variable2 [, DontTakeSqRoot]<# black>) -- Returns the square root of the sum of squares of the two variables. If both are scalars, this is tantamount to returning the hypotenuse of a triangle with the given sides: hence the name. In this case, a scalar is returned. In all other cases an array is returned. If both arguments are arrays (which must be of the same size), each term of the returned array is the square root of the sum of the squares of the corresponding input array elements. If only one is an array, the same scalar is pitted against each element of the input array. In all cases, if there is a third argument and it is anything but 0, no square root will be taken. If what you want is the <i>Euclidean distance</i>, set DontTakeSquareRoot to FALSE and DontTakeMean to TRUE.

<B>distance</B>(<# blue><Variable1, Variable2 [, bool DontTakeSqRoot [, bool DontTakeMean ] ]<# black>) -- If just two arguments, returns the root-mean-square of differences. Either the squaring or the taking of the mean can be avoided by including the relevant argument and setting it to TRUE.
Different deployments of the first two arguments give different results. Here are examples of the allowed argument structures. For simplicity, assume that the 3rd. and 4th. arguments are TRUE, so that only sums of squares are returned.
<u>Case 1:</u>  <# blue>scalar x1, scalar x2<# black>:  A scalar is returned, with value (X1 - X2)<^>2</^>.
<u>Case 2:</u>  <# blue>scalar x, array A<# black>: A scalar is returned, with value {  (X - A[0])<^>2</^>  +   (X - A[1])<^>2</^> + ... } (through all the values in A).
<u>Case 3:</u>  <# blue>array A, array B (same lengths)<# black>: A scalar is returned: {  (A[0] - B[0])<^>2</^>  +   (A[1] - B[1])<^>2</^> + ... } (through all the values in A and B).
<u>Case 4:</u>  <# blue>array A, matrix M<# black>: the length of M's columns must be the same as the total length of A. An array is returned - call it 'Result' - such that for each row of M there is a value;  Result[i] = {  (A[0] - M[i, 0])<^>2</^>  +   (A[1] - M[i, 1])<^>2</^> + ... } (through all the values in A and M[i]).

<b>distmutual</b>(<# blue>XValues [, YValues [, ZValues ] ]    [, bool DontTakeSquareRoot [, bool FillWholeMatrix] ]<# black> ) -- caters for points in 1, 2 or 3 dimensions. Returns a matrix of mutual distances. If there are N points, its size will be NxN. Normally only the top/right triangle of the matrix is filled, the other triangle being all zeroes. If the final argument is TRUE, then the lower triangle is also filled. In all cases, of course, the main diagonal consists of zeroes.
For 2 or 3 dimensions, the distance between point i and j (j > i) is placed into the returned matrix as element[i, j]. The distance is the square root of the sum of the squares of the coordinate differences, i.e. the Euclidean distance. If 'DontTakeSqRoot' is present and true, the sum of the squares is returned instead. If 'FillWholeMatrix' is true, the lower triangle will be exactly equivalent to the upper triangle (result[i,j] = result[j,i]). 
For 1 dimension, simple subtraction is used, element [i,j]  (j > i)  being Xvalues[j] - Xvalues[i]. If 'FillWholeMatrix' is true, the lower triangle values will be of opposite sign: result[i,j] = ‒result[j,i].

<b>distpoints</b>(<# blue>X1Values [, Y1Values [, Z1Values ] ],  X2Values [, Y2Values [, Z2Values ] ]  [,  bool DontTakeSquareRoot] <# black>) -- (All arguments are arrays, even if they only represent a single point.)  X1... represent coordinates of one set of points in 1-, 2- or 3-dimensional space; X2... represent coordinates of another set of points in the same space. The returned matrix will have dimensions (no. points in first set  <b>X</b>  no. points in second set). For 1 dimension, values will be signed, as result[i,j] = X2Values[j] - X1Values[i]; and DontTakeSquareRoot, if present, is ignored. For 2 or 3 dimensions the Euclidean distance applies; the square root is taken unless there is a final scalar arg and it is TRUE.
============================================================
//DIV  --  see MOD
//DIVMOD  --  see MOD
//DOT -- see DISTANCE
//DOWNSAMPLE  --  see  SAMPLING
============================================================
//EMPTY//
<B>TEST FOR AN INVALID ARRAY RETURNED BY A SYSTEM FUNCTION</B>

The function <b>empty(scalar / array Subject)</b> returns TRUE if every value in Subject is NaN. For a scalar, that means that it is NaN; for an array of any length and structure, it means that all elements in the array are NaN.

A truly empty array is not allowed in MonoMaths; the minimum length is always one. Some functions should logically return an empty array; for example, a 'delete' function that is asked to delete all of the elements in some given array. In place of the empty array, such functions return a list array of length 1 and value NaN. This function was primarily written as a test for such pseudo-empty arrays.

Sometimes it is useful for an array, though 'empty', to retain its structure. For example, with the functions 'push' and 'pop', a matrix may be used as a stack, rows being pushed onto and popped off that stack. If at some point all the rows have been popped off, the stack becomes empty; but it is necessary for this empty stack to remember its row size, ready for future 'push' operations. For that reason, the empty stack is represented by the 1xR matrix [NaN, NaN, ....], where R is the row length. Such an 'empty' matrix will return TRUE as the argument for function 'empty(.)'.

============================================================
//EQUAL -- see COMPARE
============================================================
//ERROR//
//ERRORMSG//
//ERRORTRAP//
//ERRORCNT//
<B>errortrap(..), errormsg(..), errorcnt(..)</B> -- With rare exceptions, errors arising from system function calls during runtime crash your program. You can prevent this (in nearly all cases) with error trapping. Errors in a passage of code between error trap ON and error trap OFF will be recorded, but the code will try to soldier on despite the errors (no doubt leading to more errors). You can afterwards (or during) find out how many errors occurred by calling 'errorcnt()'. The cumulated error messages (separated by paragraph breaks) can be read using 'errormsg()'. (If no errors, errormsg() returns " ".
\tNB - only errors raised by MiniMaths will be trapped; errors detected  instead by .NET will NOT be trapped. Also, note that if a system function detects an error, it will return a scalar of the value which you supplied as an argument in errortrap(.) - as by the variable 'oopsie' in the example:
\t<# blue>oopsie = 1.23e101; <# magenta>// any improbable no. will do. (Avoid zero, as
\t<# magenta>//   assignments from erratic fns. will acquire the value of 'oopsie' - 
\t<# magenta>//   division by zero may then occur in subsequent code!) 
\t<# magenta>// TURN ERROR TRAPPING ON:
\t<# blue>errortrap('on', oopsie); <# magenta>// you don't need to access 'oopsie' again.
\t<# blue>x = sqrt(-1); <# magenta>// Oops! 'sqrt' can't handle the square root of a negative no.
\t<# magenta>//   Error recorded, and the RHS 'x' will take on the value of your 'oopsie'. 
\t<# blue>dim(arr,3);  arr[4]=9; <# magenta>// Oops! Array index is out of range.
\t<# magenta>// RETRIEVE ERROR DATA: We can only get this data here, as this data 
\t<# magenta>//  will be erased after the "errortrap('off')" call below.
\t<# blue>writeln("No. of errors = ", errorcnt());<# magenta>// errorcnt() --> a scalar no.
\t<# blue>writeln("The errors were:",10, errormsg());<# magenta>// errormsg() --> array of chars.
\t<# magenta>// TURN ERROR TRAPPING OFF:
\t<# blue>errortrap('off');
\t<# magenta>// errorcnt() would now return '0', and errormsg() would return "".<# black>

\tThe display will read:
	<# blue>No. of errors = 2
	The errors were:
	Error 1: 'sqrt': negative argument not allowed
	Error 2: receiving array has an oversized dimension
============================================================
//EUCLID -- see DISTANCE
//EUCLIDEAN -- see DISTANCE
==================================================================
//EVEN  --  see MOD
//EVICT -- see SELECT
==================================================================
//EXEC//
//RUN//
//PGM_LOAD//
<b>LOADING AND RUNNING A NEW MONOMATHS PROGRAM FROM WITHIN THE EXISTING ONE</b>

<B>run</B>(<# blue>array Data;  array Mode<# black>) -- the new program will be run in the same instance of MonoMaths. Four scenarios:
<i>Case 1:</i>  Invoke a program in a disk file: 'Data' is the path and file name, and Mode is 'F' or 'f'. (The rules for this file name are exactly as for e.g. function 'load(.)'; in particular, the abbreviation "~/" for the home directory is allowed.)
<i>Case 2:</i>  No files are involved: 'Data' is the text that you want to run as a program. In this case, Mode is 'T' or 't'.
<i>Case 3, case 4:</i>  Mode is "FQ" or "TQ" (case-insensitive; 'Q' for 'quietly'). As for 'F' and 'T', but the program text does not appear; preexisting text remains in the Assignments Window. However in the case of "FQ". the window title does change to display the new running program's name. The downside to using the 'quietly' option is that what is displayed in the Assignments Window is not what is in fact running - which could have quite serious effects e.g. when you go to examine the contents of a variable during or after a run.

<B>pgm_load</B>(<# blue>array Data;  array Mode<# black>) -- Exactly as for 'run', except that the new program (if that is what the data is) will not be run. The program containing this function will be terminated first. However the Results Window and status bar will not be cleared (both are cleared with function <i>run(.)</i>).
There is no 'quietly' mode for this function; modes "TQ" and "FQ" will be interpreted as just "T" and "Q" respectively.


<b>RUNNING AN EXTERNAL APPLICATION FROM THIS MONOMATHS PROGRAM</b>

The function is <b>exec(.)</b>. This will run an application in much the same way as you would do from the terminal command line.

It has two forms, which differ only in the way in which the arguments are presented.

<u>Form 1</u>
<B>exec</B>(<# blue>array CommandLineEntry [, scalar WaitMsecs ] ]<# black>) -- The whole command, as you would enter it at the command prompt in a terminal, is contained in the chars. array <i>CommandLineEntry</i>.  There are no checks; everything before the first space is regarded as being the application name ( + path, if no environment variable stored for it), and everything after as the subsequent argument list.
<u>Form 2</u>
<B>exec</B>(<# blue>array FileName [, any no. of arrays Arguments [, scalar WaitMsecs ] ]<# black>) -- The file name this time is subject to checks. Each array that follows will become a command line argument, a space being inserted between consecutive arguments.

The <i>return</i> from the function depends on <# blue>WaitMsecs<# black>. If this is absent, the return is always 0, and the function does not wait around till the called process finishes. (This is appropriate especially where you are invoking another application which you want to persist.) If it is present and set to a value that rounds to greater than zero, then the function will wait around for the process to end for this length of time before giving up. Two returns are possible, if this argument is supplied (and is greater than zero): (1) If the process ends before time is up, then the returned value will be whatever exit code that process generated; (2) if the process did not end by then, this function gives up waiting and returns 999.

Only one abbreviation is allowed (and then only in Form 2), namely "~/" - for personalized home directory. If this is found <i>anywhere</i> within <i>any</i> argument, the home directory will be substituted for the abbreviation. If for some odd reason you don't want "~/" to be substituted in this way, precede it with a backslash (which will be removed by the function).

For the particular case where you want to <b>start another MonoMaths instance</b>, 'FileName' is just the word "mono", and the first argument is the path and file name of MonoMaths (e.g. "~/MonoMaths/MonoMaths.exe"). Omit <i>WaitMsecs</i> (as you want the instance to persist), and supply further arguments as follows:
(1) Just to open the instance: no further arguments.
(2) To dictate window sizes, and / or load or run a program in that instance, first set up a command line of arguments that would work if entered into a terminal (see the hint for "command" for this), and then enclose the whole command line in quote marks, inside the 'exec' function. Here is an example, which runs program "zzz.txt" in the new instance after resetting the size of the instance:
(a) The command line version (which would work in a terminal, or in a desktop link):
	<# blue>mono /home/jon/MonoMaths/MonoMaths.exe  L=0.115;T=0;W=0.75;H=0.94; run = `~/MonoMaths/Scripts/zzz.txt`<# black>
(b) The 'exec' version, developed from this:
	<# blue>exec("mono /home/jon/MonoMaths/MonoMaths.exe  L=0.115;T=0;W=0.75;H=0.94; run = `~/MonoMaths/Scripts/zzz.txt`");<# black>


Other useful functions: where you want to end an instance, <i>kill_on_exit()</i> (followed by 'exit') and (more drastic but more certain) <i>smash()</i>.

<u>Running shell commands and scripts</u>
The above will only run a shell command that consist of an instruction and (optionally) arguments; like "ls /bin" (to list the contents of folder /bin). The problem is that there is no terminal open, so that wherever the output of this command goes, you will never see it. To preserve the output you should use the command "ls /bin > /tmp/abc.txt", which directs the listing output to the disk file of your choice. The next problem is that you can't just use <# blue>exec("ls", "/bin", ">", "/tmp/abc.txt", 100)<# black>, as the underlying Mono code will pass ">" as an argument to "ls", which will invoke an error message from within Bash's "ls" function. Here is a function that you can use to run a shell script, be it a one-liner (as the one just quoted) or a long series of commands (separated either by Bash's symbol ';' or by the line feed, char. 10). We exemplify its use with a two-line shell script. What the function does is to save a temporary script and then run that script.

<# magenta>// Establish a file to hold the script and a second file to receive its output:
<# blue>scriptFile = "/tmp/aaa";
<# blue>outputFile = "~/abc.txt"; <# magenta>// File will appear in the personalized home directory.
<# magenta>// Write the shell script. In this case it is a simple two-liner; the first command changesthe script's 
<# magenta>//   working directory to "/bin", and the second lists it (in a verbose form) to a file in "/tmp".
<# magenta>// Don't bother about the 'shee-bang' line "#!bin/sh" which normally starts a script; the function handles this.
<# blue>script = text("cd /bin", 10, "ls -la /bin > ", outputFile); <# magenta>// '10' being the end-of-line character.
<# blue>n = ShellScript(script, scriptFile, 100);   if (n == -999) exit; <# magenta>// '-999' = error; the error msg was shown by the function.
<# magenta>// Display the results:
<# blue>writeln("Exit code: ", n);
<# blue>aa = load('T', outputFile);
<# blue>if (!iok()) crash("Problem with loading the output of the shell script: ", iomessage());
<# blue>writeln("LISTING OF THE BIN DIRECTORY:", 10, aa);
<# magenta>// And if you don't want to leave any evidence behind...
<# blue>exec("rm", scriptFile);   exec("rm", outputFile);
<# magenta>// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<# magenta>// 'Script' is a valid shell script. (It should not contain the "!#!bin/sh" line, as this function adds it in automatically.)
// 'Msecs' is necessary if you want to read the return code from the script; otherwise the function always returns 0.
//   If using it, make sure the value is more than long enough for the script to finish executing; if it does finish in time,
//   the script's exit code is returned; otherwise the return is the 'script not yet finished' code, which is 999.
// Error in saving the script file returns -999 (note the sign).
<# blue>function ShellScript(Script, ScriptFileName, Msecs=0)
<# blue>{	Script = text("#!/bin/sh", 10, Script); <# magenta>// Although the saved script usually would work from the command line
								// without this introduction, it won't work through 'exec(.)' without it.
\t<# blue>save('T', Script, ScriptFileName, 'O');
\tif (!iok()) {  show("Problem saving the script: ", iomessage());   return -999;  }
\texec("chmod", "+x", ScriptFileName); <# magenta>// since text files are automatically made nonexecutable when created.
\t<# blue>result = exec(ScriptFileName, Msecs); <# magenta>// run the script.
\t<# blue>return result;
}
============================================================
//EXIT_PLUS//
<b>exit_plus</b>(<# blue>array DoWhat [, FileName [, bool FormattedTextMode ] ]<# black>) -- causes the program to exit, but then invokes some extra stuff. 

<u>Action 1 -- simulate menu item "File | New" after the exit</u>
<b>exit_plus</b>(<# blue>"new"<# black>). The first argument is not case-sensitive. No other arguments accessed. NB - <i>No warning dialog box</i> appears to warn you if the prior Assignments Window text has unsaved changes, before it is cleared away.

<u>Action 2 -- simulate menu item "File | Load" after the exit</u>
As for 'action 1', <i>no warning dialog box</i> appears to warn you that the current text is unsaved and about to be overwritten.
<i>DoWhat</i> is <# blue>"load"<# black> (again, case-insensitive).
<i>FileName</i> behaves as with e.g. function 'load'. The abbreviation '~/' for personal home folder is allowed. If no path, path is assumed to be current directory. If a path but no file name, a file dialog box opens at the given folder. If FileName is empty (just spaces), or is scalar, the file dialog box opens at the current folder.
<i>FormattedTextMode</i>  -- if present and nonzero, the text will be displayed in formatted form, as if menu item "Appearance | Toggle Markup System" had been effected.

<b>Errors:</b> -- The current program ends in all cases, errors or not. However the existing program's text remains in the Assignments Window, if there is an error. Errors:
<bullet>Faulty DoWhat;
<bullet>DoWhat is 'load', but there is only this one argument;
<bullet>Faulty or inaccessible file FileName.

If there was a dialog box, but the user cancelled out of it, then the existing text remains on view, and the appropriate message goes into the Results Window (as with errors).
============================================================
//EXP//
<B>exp</B>(<# blue>Variable<# black>) -- the exponential constant 2.71828... raised to the given power (or powers, if the argument is an array).
============================================================
//EXPUNGE//
<B>expunge</B>(<# blue>InArray,  scalar or array Target [, scalar FromPtr [, scalar Extent]]<# black>) -- returns a copy of InArray in which all instances of Target have been removed which lie wholly within the limits set by FromPtr and Extent (or within the whole string, if they are absent). If only FromPtr is supplied, the rest of InArray is included.

 Always returns a list array. If the function call would logically remove all of InArray, the return is the 'empty' array - that is, an array of size 1, content NaN; subsequent call to "empty(returnedArray)" then returns TRUE.

Error results from negative FromPtr or Extent; otherwise combinations of FromPtr and Extent which don't define extents of InArray will not raise an error, but will simply return InArray (as a list array).

See also <# blue>substitute(.)<# black>.
============================================================
//FACT//
//LOGFACT//
//FACTORIAL//
//BINOMIAL//
//BINOM//
//LOGBINOM//
<B>FACTORIAL FUNCTIONS  AND  BINOMIAL COEFFICIENTS</B>

In all cases, <B>arguments are rounded</B> before testing and use within the functions.

<U>FACTORIALS</U>
<B>fact(Variable [, Scalar])</B> -- 'fact(n)' simply gives factorial n; 'fact(n,p)' gives factorial n divided by factorial p. Both n and p must lie between 0 and 169, with p < n.  ('fact(0)' evaluates to 1.)

<B>logfact(Variable [, Variable])</B> -- 'logfact(n)' gives the log to base 10 of factorial n; 'fact(n,p)' gives in effect logfact(n) divided by logfact(p). Both n and p must lie between 1 and 2,147,483,647 (which is hex no 7FFF FFFF), with p < n.


<U>BINOMIAL COEFFICIENTS</U>
<B>binom (Scalar TopValue, Scalar BtmValue1 [, Scalar BtmValue2])</B> -- Returns the binomial coefficient(s). The two-argument value returns a <I>scalar</I> - the binomial coefficient (TopValue  BtmValue1); the three-argument value returns an <I>array</I> - all the coefficients from (TopValue  BtmValue1) to (TopValue  BtmValue2). Obvious limits apply: TopValue >= 0, BtmValue >= 0 and <= TopValue, and if supplied, BtmValue2 >= BtmValue1. In addition, the upper limit on TopValue is 170. (Use function <B>logbinom(.)</B> if you want to work with larger numbers.)

<B>logbinom(Scalar TopValue, Scalar BtmValue1 [, Scalar BtmValue2])</B> -- Returns the logarithm (to base 10) of the binomial coefficient(s). The two-argument value returns a <I>scalar</I> - log of the binomial coefficient (TopValue  BtmValue1); the three-argument value returns an <I>array</I> - log of all the coefficients from (TopValue  BtmValue1) to (TopValue  BtmValue2). Obvious limits apply: TopValue >= 0, BtmValue >= 0 and <= TopValue, and if supplied, BtmValue2 >= BtmValue1. The upper limit on TopValue is hex no. 0x7FFF FFFF, which is 2,147,483,647. For TopValue 170 or below you may prefer to use the non-logarithmic function <B>binom(.)</B> instead.
============================================================
//FACTORS//
<B>factors</B>(<# blue>value(s) contained in one or more variables<# black>) -- 

(1) <I>Single value:</I> 'factors(n)' returns a list array containing the prime factors of n, if n >= 2; otherwise NaN. Examples: 'factors(7)' returns 7 (in an array of size 1);  'factors(8)' returns '2, 2, 3' (in an array of size 3); 'factors(0)' or 'factors(-4)' returns an array of size 1, value NaN, which would return TRUE from a call to 'empty(.)'. 

(2) <I>More than one value:</I> returns the factors <I>common</I> to all elements, or NaN (in an array of size 1) if none. 'factors(4,8,24)' returns '2,2'; 'factors(4,5)' returns 'NaN'.
============================================================
//FFT -- see FOURIER
//FILESIZE  --  see  CHECKDIRECTORY
============================================================
//FILL//
<B>FILL</B>

<B>VOID</B> - '<B>fill</B>(Arr,1,2)' -- or <B>NONVOID</B> - 'Arr1 = <B>fill</B>(20,1,2)'.
Nonvoid form: 1st. argument = size of array being (re-)created.

The <I>nonvoid form</I> creates a list array.

The <I>void form</I> does not alter the dimensional structure of the array passed to it, but the array must be entire, not e.g. a row; "fill(Mx[0], ...)" will not raise an error, but it will also not change the existing content of Mx.

<B>Arguments after the first</B> = polynomial coefficients.
<B>Examples</B> (assume Arr has size 5):
    fill(Arr, 3)    -->   [3, 3, 3, 3, 3] <# blue>// the polynomial is just '3'<# black>
    fill(Arr, 0, 1)    -->    [0, 1, 2, 3, 4] <# blue>// poly is 'x + 0'. <# black>
    fill(arr, 1, 2, 1)    -->    [1, 4, 9, 16, 25] <# blue>// poly is 'x^2 + 2x + 1'<# black>
============================================================
//FILTER//
<B>filter</B>(<# blue>InArray, scalar WindowWidth, scalar StepSize, array Mode<# black>) -- Non-void. A window is moved across the input array, to interact with it. The window will be linear if InArray is a list array, a square window if InArray is a matrix, or a cubic window if InArray has 3 dimensions. The window starts with its lowest element at the lowest element of InArray. If one thinks of InArray as represented by unit boxes in a 1D, 2D or 3D Cartesian system, the window moves along the positive X direction in jumps of StepSize until it can go no further (it is not allowed to overlap the right edge). Then if InArr has more than one dimension, it moves up the Y axis by the same StepSize, and repeats the process. And if it has three dimensions, then after completing one face of the cube the window moves to the lowest X and Y positions of the next face along the Z axis, with the Z coordinate advanced by StepSize.

The nature of the interaction depends on argument Mode. This is a new function, and so far only two modes are recognized:
<bullet>"average" -- the output datum is the average of all the data in the window.
<bullet>"maximum" -- the output datum is the maximum of all values in the window.

The <b>returned structure</b> has the same dimensionality as InArray, but is smaller (except when both WindowWidth and StepSize are 1). In this structure, one value is entered for each position of the window.


For a <b>FIR ("finite impulse response")</b> filter written specifically for 2D, use function <b>firfilter(.)</b> instead.

============================================================
//FIND//
//FINDS//
//FINDALL//
//FINDANY//
<just c><b>FUNCTIONS FOR FINDING TARGETS WITHIN ARRAYS</b>
<just l>
There are four functions:
<bullet><b>find</b>:  Finds the first occurrence of a target within an array.
<bullet><b>finds</b>:  Returns the number of occurrences of the target, with pointers to the first and last occurrence.
<bullet><b>findall</b>:  Returns an array of pointers to all occurrences of the target within the array.
<bullet><b>findany</b>: Given several targets, finds the first occurrence of any of them, and tells which target was found there.


<B>find</B>(<# blue>ArrayToSearch, scalar StartPtr, ...<# black>) -- Search the array for a given value or sequence, and return the index of the first find at or after StartPtr; or return -1, if no find. 
The structure of ArrayToSearch is ignored; the index is an absolute address in ArrayToSearch's data strip. (You can use function "indexed(..)" to translate this address into array coordinates.)
StartPtr must not be negative - if it is, the function crashes (as do the rest of the functions below).

There are three possible forms: 
<bullet><# blue>find(ArrayToSearch, StartPtr, scalar Value)<# black> searches for the exact value; 
<bullet><# blue>find(ArrayToSearch, StartPtr, scalar LoValue, scalar HiValue)<# black> searches for the first value lying between (or at one of) the two limits - which, by the way, may be in any order (high limit before low limit is permitted). 
<bullet><# blue>find(ArrayToSearch, StartPtr, array Sought)<# black> looks for the first occurrence of the complete sequence of exact values in array Sought.


<B>finds</B>(<# blue>ArrayToSearch, scalar StartPtr, ...<# black>) -- Arguments are exactly as for <B>find(..)</B>. The only difference between the two functions is what is returned; this function always returns an array of size 3: [0] is the number of finds (starting from StartPtr), [1] the position of the first find (or -1, if none), and [2] the position of the last find (-1, if none).


<B>findall</B>(<# blue>ArrayToSearch, scalar StartPtr, ...<# black>) -- Arguments exactly as for <B>find(..)</B>. The only difference between this and the above two functions is what is returned. This function returns an array made up of the indices of all finds. (You can create a parallel array of their values using the function 'select(.)'.) If there are no finds, an array of size 1 is returned, with [0] set to -1.

\t<# blue>searchme = data(10, 11, 12, 13, 14, 15); <# magenta>// array to be searched
\t<# blue>indices = findall(searchme, 0, 11.5, 13.5); <# magenta>// from searchme[0] onwards, retrieve the indices of all values lying between 11.5 and 13.5;  --> array [2, 3].
\t<# blue>values = select(searchme, indices); <# magenta>// returns the array [ searchme[3], searchme[4] ]; i.e. [12, 13].
<# black>


<b>findany</b>(<# blue>ArrayToSearch, scalar StartPtr,  array TargetSet [, scalar / array Delimiter ]<# black>) -- TargetSet holds a set of targets to be sought. The return is always an array of size 2. In all cases, if none of the targets is found the return is [-1, -1].
The first two arguments are as for all above. For the rest, there are <b>two versions</b>:

<i>The three-argument version:</i>  Each value within TargetSet will be searched for in turn. Of those found, the one with the smallest index in ArrayToSearch will be the find returned. The return is: [index in ArrayToSearch;  index in TargetSet of the find]. For example, if ArrayToSearch is "12345" and TargetSet is "592", the return is: [1, 2], as the target which appears earliest is TargetSet[2], and it occurs at ArrayToSearch[1].

<i>The four-argument version:</i>  TargetSet is a delimited set of targets; the delimiter is given in the 4th. argument. The delimiter is always just one value; if Delimiter is passed as an array, only its first element is taken as the delimiter.
To give examples: Suppose the delimiter is '|'. Then a TargetSet "AA|B|CCC" will result in separate searches for "AA", "B" and "CCC".
The return is: [index in ArrayToSearch;  the number of the target within TargetSet (to base 0) ]. For example, if ArrayToSearch were "12AA34CCC", and TargetSet as just given, then the return would be [2, 0]: the find "AA" is subarray 0 within TargetSet, and it is found at ArrayToSearch[2].

Note that TargetSet must not begin or end with a delimiter, and no two delimiters must touch. Hence, these are illegal: "|AA|BB", "AA|BB|", "AA||BB".


<b>Other searching functions:</b>  <i>findinmx, findbrackets, seekno (this last searches a string for the first valid number contained within it).</i>
============================================================
//FINDDUP//
<b>FIND THE FIRST OCCURRENCE OF A DUPLICATED VALUE WITHIN AN EXTENT OF SOME ARRAY</b>

The function is

	<b>finddup</b>(<# blue>array Subject,  bool OfEarlierValue  [,  scalar FirstIndex  [,  scalar LastIndex ]  ]<# black> )

If 'OfEarlierValue' is TRUE, then the function finds the <b>first</b> value in Subject which is the same as some value <b>earlier</b> in Subject. If FALSE, then the function finds the first value in Subject which is the same as some <b>later</b> value in Subject.

The last two arguments define the extent of 'Subject' which is scanned; if omitted, the whole array is scanned. The only corrections of these pointers are: (1) Negative 'FirstIndex' is corrected to 0;  (2) 'LastIndex' beyond the end of Subject is corrected back to its last element.

RETURNED: Always an array of size 3:
	{  Index of the found element,   Index of the element which it matched,   Value of the matched element }.

EXAMPLES:
	<# blue>aa = data(10, 20, 30, 20, 10);
	ofEarlier = finddup(aa, true);    writeln(ofEarlier);   <# magenta>// produces [ 3, 1, 20 ]<# blue>
	ofLater = finddup(aa, false);      writeln(ofLater);     <# magenta>// produces [ 0, 4, 10 ]<# blue>

============================================================
//FINDLINENO//
//THISLINENO//
<just c><b>IDENTIFYING A LINE OF ASSIGNMENT WINDOW TEXT</b>
<just l>
There are two functions. For each, lines are numbered such that the first line of text is line 1, not line 0.

<b>thislineno()</b> No argument required. Returns the number of the line which contains this instruction.

<b>findlineno</b>(<# blue>scalar LineNo [,  bool  AndGoThere ]<# black>) -- Returns the text that makes up the given line, or the empty array [NaN] if such a line does not exist. Additionally, if there is a second argument and it is TRUE, the cursor is placed at the beginning of that line.
============================================================
//FINDINMX//
<B>findinmx</B>(<# blue>Matrix,  scalar/array Sought,  bool FirstFindOnly  [, FirstRow [, LastRow ] ]<# black>) -- finds a value or a sequence within the ROWS of the matrix. (If a sequence, it must be fully contained within a row, to register a 'find'; it cannot cross into the next row.)

If "FirstFindOnly" is FALSE, then ALL finds will be returned.

The default for "StartRow" is 0, and for "LastRow" is the index of the last row of Matrix.

<u>RETURNED: </u>
A matrix of two rows; row[0] records the row(s) of the find(s), row[1] records the column(s) of the find(s). If there are no finds, then a 2x1 matrix is returned, both values being -1.

(No equivalent function for searching columns is planned, as the time taken by the adapted function would not be significantly less than could be obtained by simply transposing the matrix and then applying this function.)
============================================================
//FINDBRACKETS//
<B>findbrackets</B>(<# blue>Text, scalar Pointer, scalar or array Opener, scalar or array Closer<# black>) -- Intended for text, and only works properly if all relevant values can be coded to UFT8 characters. Typically used to locate brackets within Text which enclose the position Pointer, ignoring any adjacent higher bracket nesting levels.

Pointer is a position in Text.

Opener represents one character, typically an opening bracket; if Opener is an array, only Opener[0] is accessed.

Closer also represents one character, typically a closing bracket.

The return is always an array of length 2, [0] = position of the opener corresponding to the nesting level at Pointer; [1] = position of the corresponding closer. If either is not found, its element is -1. If Pointer points to an instance of Opener, returned [0] will be Pointer; likewise if Pointer points to an instance of Closer, returned [1] will be Pointer.

If Opener and Closer are the same value, the return is always [-1, -1] for all values of Pointer.


<u>EXAMPLES</u>
\t<# blue>txt = "0(2(4)6)8";  <# magenta>// each digit refers to its position in the string.
\t<# blue>bkts1 = findbrackets(txt, 0,  '(',  ')'  );  <# magenta>// returns bkts1 = [-1, -1], as no brackets enclose position 0.
\t<# blue>bkts2 = findbrackets(txt, 1,  '(',  ')'  );  <# magenta>// returns bkts2 = [1, 7], ignoring the higher level brackets at positions 3 and 5.
\t<# blue>bkts3 = findbrackets(txt, 4,  '(',  ')'  );  <# magenta>// returns bkts3 = [3, 5].
\t<# blue>bkts4 = findbrackets(txt, 7,  '(',  ')'  );  <# magenta>// returns bkts4 = [1, 7].

\t<# blue>txt1 = "(1)";
\t<# blue>bkts5 = findbrackets(txt1, -100,  '(',  ')'  );  <# magenta>// returns bkts5 = [0, 2], as a negative position is adjusted to position 0.
\t<# blue>bkts6 = findbrackets(txt1, 2,  '(',  ')'  );  <# magenta>// returns bkts6 = [0, 2].
\t<# blue>bkts7 = findbrackets(txt1, 222,  '(',  ')'  );  <# magenta>// returns bkts7 = [0, 2], as a position beyond the end of txt1 is corrected to the last position.
============================================================
//FINDSEGMT -- see GETSEGMT
============================================================
//FIRFILTER//
<b>FINITE IMPULSE RESPONSE ("FIR") FILTERING</b>

In the following, all times are discretized, the discrete times of the system being t = 0, 1, 2, ... There is an electrical circuit which has an impulse response with a finite number of elements, say, 3. Suppose that the circuit is hit with a theoretical unit impulse (Kronecker delta) signal. At time t=0, the circuit output is 0.5 (volts or amps or whatever); at t=1, 0.2; at t=2, 0.1; and at all times t > 2, zero output. The <b>impulse response</b> of this circuit is then the array [0.5, 0.2, 0.1], and has length 3; call it "IR". Next, you have a signal, "Y"[t], of arbitrary wave form hitting the same circuit. As texts on elementary circuit analysis will tell you, the output of the circuit this time will be found by running the impulse response backwards in time over the input signal. Suppose that at time T, the current and preceding values of the input signal are Y[T], Y[T-1], Y[T-2], Y[T-3], ... Then the output of the circuit at time T will be given by
	Y[T] * IR[0]  +  Y[T-1] * IR[1]  +  Y[T-2] * IR[2].
In general, the rth. term of such a circuit response will be Y[T-r] * IR[r], for as many elements as there are in IR.

But there are <b>end effects</b>. With the above example, if we don't know what the signal was before time 0, then we can only apply the above sum from term 2 onwards. What do we do, then, with the first two terms of the output signal? In the function below, the user's choice is put in there (see argument 'LeftPadder' below); or by default, the constant MINREAL.

It is also possible to introduce <b>delays</b>. Suppose that at time T we are not measuring the output of the circuit at time T but, due to a delay factor, at time T-n (perhaps there is a long transmission line between the circuit and our measuring equipment is at its far end). We allow for this with an argument 'Delay', which is 0 for the example given in the first paragraph, but is n after the delaying transmission line has been inserted. It is possible for Delay to be negative, in which case the filter becomes <i>predictive</i>; it miraculously knows what Y[t] will be in the future, and is able to give an output for time T which tells what the output of the circuit will be in time T+|Delay|.

In the case of the predictive filter only, there will be an <b>end effect</b> at the end of the time period; the user's choice is put here, or the default of MAXREAL is used.

So the function is
	<B>firfilter</B>(<# blue>array InArray,  array / scalar ImpulseResponse [, scalar Delay [,  scalar LeftPadder [, scalar RightPadder ]]]<# black>)
<bullet>InArray -- the input signal; structure ignored.
<bullet>ImpulseResponse -- If a scalar is supplied, and it rounds to ≥ 1, then an averaging filter is built internally, which averages over that number of terms. For example, if ImpulseResponse is the scalar '3', this would be replaced internally by this IR of length 3: [1/3,  1/3,  1/3]. Note that the sum of the equal terms of this internally built IR will always be 1.
<bullet>Delay -- must round to an integer, but can be positive, zero or negative. The default is 0.
<bullet>LeftPadder -- any values allowable, even NaN; but that is not recommended, as error states return the empty array [NaN], so there could be confusion. The default is MINREAL.
<bullet>RightPadder -- same comments. The default is MAXREAL.


The <b>RETURN</b> for SUCCESS is an array of the same length as InArray, representing the filtered signal.

If for the given arguments no output signal can be determined, the <b>RETURN</b> is the 'empty' array [NaN]. (In particular, note that the function never returns an array made up only of the padders.)

Crashing ERRORS are only two: (1) InArray not an array, and (2) ImpulseResponse set to a scalar < 1.


For <b>3D filtering</b>, use function <b>filter(.)</b>.

============================================================
//FIT --see CURVEFIT, in POLYNOMIAL
============================================================
//FIXANGLE//
<b>CONFINE AN ANGLE TO A PARTICULAR 2π RANGE</b>

The function is <b>fixangle</b>(<# blue>Angle [, MinimumAngle ] <# black>) (non-void; returns the adjusted angle). If MinimumAngle is omitted, the range defaults to 0 to 2π. The only other common minimum angle used is -π (but you can use any value you like):  <# blue>ang1 = fixangle(ang, -PI)<# black>
============================================================
//FIXEDSIZE//
<B>fixedsize</B>(<# blue>array InData, scalar Extent,  array/scalar Padder [, bool PadAtStart [, bool TruncateIfTooLong [, array TruncationSign ] ] ]<# black>) -- Nonvoid.

If InData has a length shorter than Extent, the returned copy (always a list array) will be padded out to that length using 'Padder'. The padding by default goes at the end of the array, but if 'PadAtStart' is present and TRUE, it goes on the front instead.

If InData has a length greater than Extent, the remaining arguments decide what happens. If 'TruncateIfTooLong' is absent or zero, InData is returned as is. Otherwise it is truncated back to length Extent (which must be at least 1 to avoid a crash). The final argument, if present, adds an indicator of truncation. E.g. if it were "..", InData were "ABCDEFG", and Extent were 5, the output would be "ABC.."; whereas if the final argument were missing, the output would be "ABCDE".    
============================================================
//FLOOR --see MOD
============================================================
//FOOTER -- see LABELX
============================================================
//FOREACH//
<just c><b>THE "FOREACH"  LOOP</b>
<just l>
This differs from the 'foreach' syntax of other C-type languages, though it is a development from it. There are three forms, depending on the number of arguments that you supply in brackets after 'foreach' (two, three or four). The full four-argument syntax is as follows:
\t<# blue>foreach(x, y, i, AA)   {  ....  }<# black>
where x, y and i are scalar variables (not necessarily declared beforehand), and AA is an array.
Using the particular variable names given in the example above:
<bullet>AA is an existing named array; there will be one loop executed for each element in AA.
<bullet>'x' will be internally assigned to AA[i] at the start of the loop;
<bullet>'y' starts equal to x; whatever value you assign to it will, at the end of the loop, be the new contents of AA[i]. (If you don't intend AA to be changed, simply don't make any reference to 'y' in your loop code.)
<bullet>'i' is the iterator for the loop. You can ignore it, but sometimes it is handy to have access to it. (You actually can change it in the loop code, and so interfere with the order of loopings. This would usually be a daft thing to do, but occasionally could be made to achieve some interesting results.)
<b>NB!</b> No notice is taken of the structure of AA; all its data will be looped through, and 'i' will track the <b>absolute address</b>, not the address by rows and columns.

Here is an example which converts a matrix containing an arithmetic progression into one containing a sequence of factorials.
	<# blue>Mx = data(1,2,3,4,5,6);   redim(Mx, 3, 2); <# magenta>// a matrix with rows  { 1, 2;  3, 4;  5, 6 }.<# blue>
	ylast = 1;
	foreach(x, y, i, Mx)
	{	
		y = x * ylast;   <# magenta>// x was internally set to Mx[i] at the start of the loop.<# blue>
		ylast = y;	
		<# magenta>// Internally, Mx[i] is now set to the final value of y. If y was never introduced, that final value is the original value.<# blue>
	}
	writeln(neat(Mx)); <# magenta>// This will display a matrix with rows  { 1, 2;  6, 24;  120, 720 }.<# black>

<u>Shortened forms of "foreach"</u>
<bullet><# blue>foreach(x, AA)   {  ....  }<# black> -- where you don't want to change elements of AA. This version is significantly faster than an equivalent FOR loop, and <i>much faster</i> than the full 4-argument form of "foreach" (which is about one third slower than the equivalent FOR loop).
<bullet><# blue>foreach(x, y, AA)   {  ....  }<# black> -- where you don't need access to the iterator. There is no significant time saving over the 4-argument version (it is of the order of half a percent). 

<font same, 10><u>Timing considerations</u>
<bullet><i>Case 1 -- You don't want to change the array.</i>  Use the two-argument form; this is a bit faster than an equivalent FOR loop (around 12% faster). Don't use the three or four argument form: these take about 1/3 as long again as the equivalent FOR loop.
<bullet><i>Case 2 -- You DO want to change the array.</i>  You have to use the 3- or 4-argument version (virtually no time difference between the two - of the order of 0.5%). If you only refer to the element once in the loop (that is, one use of 'x' or 'y' in the FOREACH loop, and one of 'Arr[i]' in the equivalent FOR loop), then the FOREACH version takes a tiny bit longer than the FOR loop equivalent - around 5% longer. But if you make two references to the array element in the loop, the 'foreach' version is 8% faster; and it would be faster again for multiple such references.
</font>
============================================================
//FOURIER//
//FFT//
<B>fourier</B>(<# blue>Array [, bool ForwardTransform]<# black>) and <B>fft</B>(<# blue>Array [, bool ForwardTransform]<# black>) -- Both provide the discrete Fourier transform for the array; 'fourier(.)' calculates the transform term by term; 'fft(.)' uses a 'fast Fourier transform' algorithm (the 'Cooley-Tukey' version).

The array may be a list array (representing all real values) or a matrix for which the lowest dimension is 2 (interpretion: an array of complex numbers; column 0 holds the real values and column 1 the corresponding imaginary values). Structures of more than 2 dimensions are also valid, as long as the lowest dimension has size 2.)

If ForwardTransform is TRUE, OR if it is omitted, the forward transform occurs; otherwise the inverse transform. (The forward transform uses a negative index for the exponential, and has no universal multiplier; the inverse transform uses a positive index and a universal multiplier of 1/N). 

The returned value is <I>always</I> a set of complex numbers. In the case of <# blue>fourier(.)<# black> it holds the same number of values as the input argument; in the case of <# blue>fft(.)<# black> it may be larger, as explained below. Unless the input was a list array (all real values), the output object will have exactly the same structure as the input object.

<B><# blue>fourier(.) v. fft(.)<# black>:</B> They give the same result if the input data holds 2<^>N</^> values (real or complex), where N is an integer; if N is otherwise, then in the case of <# blue>fft(.)<# black> the argument is padded with terminal zero values until the next length that is an exact power of 2. <# blue>fft(.)<# black> is faster for all but the smallest arguments, and hugely faster as argument size increases. The main reason for using <# blue>fourier(.)<# black> is where you don't want the argument to be padded upwards when N is not an integral power of 2.
Another distinction: If 'Array' is complex, then the two functions may return different structures; the output of <# blue>fourier(.)<# black> has the same dimensional structure as the input object, whereas for <# blue>fft(.)<# black> it will always be a matrix. (Necessarily so, because the automatic padding with zeroes, where carried out, would otherwise cause a structural mismatch.)
============================================================
//FRAC  --  see MOD
//FROMZERO  --  see MOD
============================================================
//FUNC//
//FUNC1//
//FUNC2//
//SETFUNC//
<just c><B>ANONYMOUS FUNCTIONS</B>

<just l>At times you may want to place different functions into the one code position during runtime. For this there are two dummy (or 'anonymous') functions in <I>MonoMaths</I> called <B>func1(.)</B> and <B>func2(.)</B>. Both functions normally do nothing; but by using function <b>setfunc(.)</b> you can cause any system or user function to be substituted for either during runtime, and can unset each or reset each to some other function at any later stage in the same program.

Here is an example:
<# blue>setfunc(1, "sin"); <# magenta>// Henceforth calls to 'func1(x)' will behave as if they were to 'sin(x)'. 
<# blue>y = func1(1); <# magenta>// 'y' becomes 0.8414..., i.e. sin(1). 
<# black>

<B>setfunc( scalar WhichFunc, array FnName [, bool DontCrashIfNotFound [, bool SearchUserFnsOnly ] ] )</B>
This function is not void, but returns values as follows under the various circumstances:

<i>WhichFunc</i> must be either 1 (in which case it is setting an alias for 'func1(.)') or 2 (for 'func2(.)').

(a) <I>Two arguments:</I> FnName is sought first amongst sytem functions, then amongst user functions. If found, 'func1' (or 'func2') will henceforth stand for that function (till the next call to 'setfunc' changes things). Returned: scalar 1 for a system function, 2 for a user function.  If function name not indentified, the function crashes.
If func1 (or 2) has previously been set, then it is unset by making FnName empty, or blanks only, or scalar.

(b) <I>Three arguments, the third nonzero:</I>  If FnName identified, the same. If not identified, no crash occurs, but 0 is returned.

(c) <I>Four arguments, the fourth nonzero:</I>  As for (b), except that no search through system functions occurs. (This may save a little time where you are using e.g. 'func1' heavily for user functions.)

(d) <I>Two arguments, but 2nd. argument is either scalar or an array of spaces only:</I>  Any function name set by a previous call to 'setfunc' is invalidated. Returns -1.

Note that the only return of 0 occurs if the function name has not been found, and you have set the 'DontCrashIfNotFound' boolean. The test "if (setfunc(FnName, true) { ... use func(..) .... }" would be sufficient to avoid trouble, for example where the name FnName came in through a user's dialog box.


<B>func1( ... )</B>,  <B>func2( ... )</B> 
If either function is called without a prior successful call to 'setfunc(..)', absolutely nothing happens (except that '0' is returned, as for all void functions). In this case the number of arguments is irrelevant; they will all be ignored. The same occurs where the last use of 'setfunc' was the empty cancelling call 'setfunc()'.

However, once you have set a system or user function name with 'setfunc(.)', then e.g. 'func1(..)' behaves exactly as if it were a call to that function. It therefore expects the same number of arguments, and returns the same sort of data. The substitution will continue until altered by another 'setfunc(.)' call.

NB - it doesn't matter where in your program 'setfunc(.)' and 'func1(.)' etc. are placed; as long as <I>somewhere</I> the focus has passed over a valid 'setfunc(1, ..)' call, thereafter 'func1(.)' will stand in for the indicated function <I>everywhere</I>. Therefore you may consider placing the cancelling call 'setfunc(1, " ")' at the end of any segment of code which has been using anonymous functions.

<B>Further Example</B>
<# blue>funkset = split("sin|cos|tan", '|'); <# magenta>// a matrix whose 3 rows are function names
<# blue>for (i, 10)
<# blue>{	n = rand(3); <# magenta>// randomly choose one of the three functions.
	<# blue>theta = rand(90); <# magenta>//  a random 1st. quadrant angle, in degrees
	<# blue>setfunc(2, funkset[n]);
	<# blue>x = func2( rad(theta) );  <# magenta>// convert the angle to radians first
	<# blue>writeln(funkset[n], "(", theta,  "°)  =  ", x); <# magenta>// helpfully prints out a table of 10 trig. assignments.
<# blue>}
<# black>
============================================================
//GAUSS//
<B>gauss</B>(<# blue>scalar or array Value, scalar Mean, scalar SD, scalar CurvePeak, bool IsInverse<# black>) -- SD being standard deviation.

Consider a Gaussian curve plotted in the XY plane. 
(a) If IsInverse is 'false' (0), 'Value' is the X coordinate(s);  the Y coordinate(s) is returned.
(b) If IsInverse is 'true', 'Value' is the Y coordinate(s);  the X coordinate(s) is returned (being coordinate(s) on the positive side of Mean).
gauss(
If CurvePeak is \<= 0 the classical peak of 1 / [ sqrt(2*<| p>) * SD] is used (for which the area under the curve is 1). 

Errors do not crash, but return the value -1e100. (In the case of Value as an array, each element of Value is given a valid value or this error code separately.)

The returned scalar / array is of the same form and structure as 'Value'.

Re arg. SD: Note that this is the <i>half</i>-width of the bell at about 0.6 of the maximum amplitude (0.60653, more exactly). 

============================================================
//GETSEGMT//
//SETSEGMT//
//FINDSEGMT//
//SEGMENT//
<just c><b>FUNCTIONS THAT HANDLE "SEGMENTS" (i.e. DELIMITED SUBARRAYS)  WITHIN A GIVEN ARRAY</b>
<just l>

<b>What is a segment?</b>
In the examples below, we start with an array, called InArray, which is divided up into subarrays by a single-valued delimiter; for the sake of making readable examples, we will make InArray a chars. array, and the example delimiter will be "|".

If InArray is "AA|BBB|C", then subarray "AA" is referred to as "segment 0", subarray "BBB" as "segment 1", and subarray "C" as "segment 2".

If InArray does not contain a delimiter, then the whole array is "segment 0".

Segments are always numbered from 0 upwards. The last segment will have the index (1 + number of delimiters in InArray).

Segments may be empty. Here are some examples:
<bullet>InArray = "AA||BB":  segment 0 is "AA", segment 1 is EMPTY, segment 2 is "BB".
<bullet>InArray = "|AA":  segment 0 is EMPTY, segment 1 is "AA".
<bullet>InArray = "BB|":  segment 0 is "BB", segment 1 is EMPTY.
<bullet>InArray = "||":  all of segments 0, 1 and 2 are EMPTY.

The functions which deal with segments are:

<b>findsegmt</b>( <# blue>array <b>InArray</b>,  array / scalar <b>Delimiter</b>,  array / scalar <b>Target</b> [, bool <b>FullLengthMatchOnly</b> [, scalar <b>StartSegment</b> [, scalar <b>MaxNoFinds</b> ] ] ]<# black> ) -- finds one or more segments in InArray which match 'Target'. Points re the arguments:
<bullet><b>InArray</b> can be any array; if structured, its structure will be ignored.
<bullet><b>Delimiter</b> is a single value. If supplied as an array, only the first element of the array will be used as the delimiter.
<bullet><b>Target</b> is the sequence which you want some segment to match.
<bullet><b>FullLengthMatchOnly</b> -- If omitted, or is TRUE, then the segment must exactly match the target for a find to be recorded. If present and FALSE, then any segment that <i>begins</i> with Target will be taken as a match.
<bullet><b>StartSegment</b> -- Normally the search occurs across the whole of InArray. If this is present, the search only begins from this segment. (NB! 'StartSegment' is a <i>segment</i> index, not an array index.) If StartSegment is negative, it is corrected to 0; if too large, simply no finds will be recorded.
<bullet><b>MaxNoFinds</b> -- Normally only one find is recorded - the first segment which matches Target. If MaxNoFinds is set to a positive integer, multiple finds will be recorded, up to that count. To return all finds, set MaxNoFinds to 0 or a negative value; or else make it larger than any possible number of finds.

<u>RETURNED:</u>  An array of length (3 x the no. of matching segments found), or the array [-1, -1, -1] if no finds.
For each find, there are three values: [segment index,  location in InArray of the first element in the segment,  locn. in InArray of last element in the segment]. For example, if the segment "BB" is a find within an InArray of "AA|BB|CC", then the three values for this find would be [1, 3, 4].

<i>Special case:</i>  You want to find an <b>empty segment</b>. In that case you should set Target to NaN (either as a scalar or as a single-valued array). The form of the find will be different: [segment index, location in InArray of the <i>delimiter</i> to the left, location of the delimiter to the right. For example, if InArray is "AA||BB", and Target is NaN, then the central empty segment will be found, and will be represented as the three values [1, 2, 3].
If the find is the first segment, then the second value will be -1 (as if there were a virtual left delimiter at InArray index -1).
If the find is the last segment, then the third value will be the length of InArray (as if there were a virtual right delimiter just beyond the end of InArray).
So if InArray is "||", Target is NaN, and MaxNoFinds is -1, the returned array will be: [0, -1, 0,    1, 0, 1,    2, 1, 2].

<b>getsegmt</b>( <# blue>array <b>InArray</b>,  array / scalar <b>Delimiter</b>,  scalar <b>WhichSegment</b><# black> ) -- Returns the indicated segment. If it is an empty segment, the return will be the array [NaN].
<bullet><b>InArray</b> can be any array; if structured, its structure will be ignored.
<bullet><b>Delimiter</b> is a single value. If supplied as an array, only the first element of the array will be used as the delimiter.
<bullet><b>WhichSegment</b>: The first segment is numbered segment 0. <b>The function crashes</b> if WhichSegment does not refer to a valid segment; in other words, if WhichSegment is negative, or is \> 1 + number of delimiters present in InArray.

<b>setsegmt</b>( <# blue>NAMED array <b>InArray</b>,  array / scalar <b>Delimiter</b>,  scalar <b>WhichSegment</b>, scalar / array <b>NewData</b><# black> ) -- VOID; changes InArray directly.
<bullet><b>InArray</b> must be a predefined named array; if structured, its structure will be ignored.
<bullet><b>Delimiter</b> is a single value. If supplied as an array, only the first element of the array will be used as the delimiter.
<bullet><b>WhichSegment</b>: The first segment is numbered segment 0. <b>The function crashes</b> if WhichSegment does not refer to a valid segment; in other words, if WhichSegment is negative, or is \> 1 + number of delimiters present in InArray.
<bullet><b>NewData</b>: Whatever will replace the current contents (if any) of the segment. If you want to make the segment an empty segment, set NewData to NaN (or to an array for which element 0 is NaN).

----------------------------------
Remember that you can <i>convert between delimited list arrays and jagged matrices</i> using the functions <b>split</b> and <b>join</b>. Also, see function 'train'.
================================================================
//GETVAL -- see ALIAS
//GRAPH, GRAPH3D  --  see PLOT
============================================================
//GRAPHCOLOURS//
<b>To change colours</b> of graph features, use function <b>graphcolours(<# blue>GraphID, 0 to six colour arguments  in the order given below<# black>)</B>. Colours are ignored if the argument is absent or if it is scalar, as only arrays are accessed. Such arrays would usually be colour names (e.g. "light blue"), but enter 'colour' and key F1 for other possibilities.

The function always returns a matrix 6x3, each row being the RGB values of the colour of the corresponding graph item (whether altered or not).

The six colours in order are of the following (indexes refer to matrix rows): 
	[0] -- the plotting surface (background to the curves);  
	[1] -- the hairlines;   
	[2]: the thin line forming the perimeter of the plotting surface;  
	[3]: the background outside the plotting surface, where scaling information goes;  	
	[4]: scaling text at hairlines ("10, 15, 20, ...");  
	[5]: text of axis scale descriptor (e.g. "velocity (kms.)" ).

No errors are raised in any situation. If an argument is an array but does not validly represent a colour, then the corresponding item will be black.
 
If all you wanted to do was to read the existing colours without altering them, you would call "mx = graphcolours(G)".
============================================================
//GRAPHCOPY//	
<B>graphcopy</B>(<# blue>scalar OriginalGraphID, bool UseStartupDimensions<# black> ) -- Draws a copy of the original graph, but without any plots. The graph ID is returned (or 0, if the original graph was not identified). If <i>UseStartupDimensions</i> is TRUE, the new graph will be sized according to the dimensions of the old graph <i>when it was created</i>. (In the case of 3D graphs, it will also revert to the original graph's startup cage orientation.) If you want to reproduce any changes to that size (as produced by dragging the old graph's margins, or by funtion 'graphresize(.)'), set this argument to FALSE. (In this case, be warned that if there is less than around 0.1 seconds between a call to 'graphresize(.)' on the original graph and a call to this function, the new graph will not reflect that graph-resize operation. I have tried various tricks to overcome this quirk of the underlying Gtk drawing system, but have so far failed.)
============================================================
//GRAPHREDRAW_IRQ  -- see ANIMATE
//GRAPHPARAMS  -- see ANIMATE
//GRAPHKEY -- see ANIMATE
============================================================
//GRAPHTITLE//
<b>graphtitle</b>(<# blue>scalar GraphID,  array TheTitle<# black>) -- Displays TheTitle in the blue top border of the graph window, and - most importantly - also in the panel button representing the graph. Argument errors do not crash; simply nothing happens.
============================================================
//GXMENU -- see ANIMATE
//GXVISIBLE -- see ANIMATE
//GXCLICK -- see ANIMATE
============================================================
//GRAPHRESIZE//
//BOARDRESIZE//
//PLACEBOARD//
//BOARDPLACEMT//
<b>RESITING THE WHOLE BOARD OR ITS CONTAINED GRAPH</b>

<u>GETTING THE INFORMATION</u>

To get the current position and size of the board (i.e. the whole window which contains the graph), use function <i>boardplacemt(.)'</i>; to get the current size of the graphing surface, use function <i>pixels(.)</i>.

<B>boardplacemt</B>(<# blue>scalar GraphID)<# black>  -- If the graph is identified, returns an array of size 4, giving size and position of the whole drawing board; [0] = left (pixels, from edge of screen); [1] = top;  [2] = width;  [3] = height. If graph not identified, returns the 'empty array' - size 1, value NaN.  The returned array can be used directly as the argument for a future call to 'placeboard(.)' -- see below --  for a new graph. (That function simply does nothing - and returns 'false' - if the array is the 'empty array'.)

One adjustment is made: Values returned by this function are integers (pixels), EXCEPT if either [0] or [1] should be 1 (pixel) it actually returns as 1.001. This is because the array returned by this function is often used as the argument to a subsequent call to 'placeboards(.)' on a new graph; if so, then a top or left value of 1 would be interpreted by 'placeboards' as meaning 'full screen width / height', in which case the new graph would disappear beyond the screen.

NB - <i>timing is important</i>; if this is called much less than 1/4 of a second after programmatic resizing, it will return the values existing before the resizing. This time will obviously vary with different computers, so it may be safer to allow 1/2 second. This is a problem inherent in the underlying Gdk/Gtk graphics system.

<B>arr = pixels(g) </B> -- Always returns an array of size 4. For 2D graphs, [0] = width of a pixel in terms of the X axis variable; [1] = height of a pixel in terms of the Y axis variable; [2] = number of pixels from left to right of the plottable surface; [3] = same, vertically. For 3D graphs, [0] and [1] are always simply 0, and [2] and [3] give the width and height of the blue-lined box which contains the actual 3D plot region together with the region to its right where descriptive data goes. If the graph cannot be identified, the return is { -1, -1, -1, -1 }.
NB - <i>timing is important</i>; if this is called much less than 1/10 of a second after programmatic resizing, it will return the values existing before the resizing. This time will obviously vary with different computers, so it may be safer to allow at least 1/4 second. This is a problem inherent in the underlying Gdk/Gtk graphics system.


<u>REPOSITIONING THE BOARD OR RESIZING ITS GRAPH</u>

If you want to reposition and/or resize the board as a whole, use function <i>placeboard(.)</i>. If you are not fussy about the size and position of the board but want to set its contained graph, use function <i>graphresize(.)</i>. Both will alter the size of both; you cannot change the graph size without changing the board size, and vice versa. 

<B>graphresize</B> (<# blue>scalar graphID, scalar HorizPixels, scalar VertPixels<# black> ) -- Void. <i>Attempts</i>  to set exact pixel dimensions for the graph perimeter. However Mono's Gtk# has a mind of its own, and does not always exactly observe the values you provide, especially if they are impossible values.

The two arguments can be replaced by a single array argument of size 2.

No error is raised; if the graph does not exist, simply nothing happens.

<# black><B>placeboard</B>(<# blue>scalar GraphID, char. array PutItWhere)<# black>) -- VOID. Leaves the current board dimensions as is, but places it in one of nine positions in accordance with the value of PutItWhere. Allowed values (case-sensitive) are: "top_left", "top_mid", "top_right", "mid_left", "mid_mid",  "mid_right", "btm_left", "btm_mid", "btm_right", with obvious meaning. (only the first 3 letters of each half of PutItWhere are parsed.) Errors in PutItWhere generate a dialog message but do not crash the program; the graph remains in its preexisting position.

<# black><B>placeboard</B>(<# blue>scalar GraphID,  four values in scalars &/or array(s): Left, Top, Width, Height)<# black>) -- VOID. Attempts to set the overall graphing board dimensions and placement according to the arguments. The rules for the four values:
<bullet>Value negative: Accept the existing parameter.
<bullet>Value in the range 0 ≤ Value ≤ 1: the value is taken as a fraction of screen height or width, as appropriate.
<bullet>Value > 1: the rounded Value is taken as a number of pixels. (If you intend an offset to be just 1 pixel, enter e.g. 1.1 instead.)
As above, no errors crash the program. If the number of arguments is wrong, you get a dialog box with error message. If the values are ridiculously large, GTK will do whatever it will with your graph, but no crash should occur.
============================================================
//GRAPHVISIBLE//
<just c><b>CHANGE VISIBILITY OF A GRAPH</b>
<just l>
<B>graphvisible</B>(<# blue>scalar GraphID [, bool NewVisibility ] )<# black>  -- Always returns the final visible status of the graph as 'true' or 'false'.

If <# blue>NewVisibility<# black> is present, then 'true' forces the graph to be visible, 'false' forces invisibility.

If no graph <# blue>GraphID<# black> exists, the function returns 'false' (with no indication that the graph does not exist).

============================================================
//GRID//
//GRIDX//
//GRIDY//
//GRIDZ//
<b>2D and 3D GRAPHS: SETTING THE SCALE</b>

<u>SETTING THE SCALE FOR JUST ONE AXIS</u>
For the X, Y and (for 3D graphs) Z axes, the corresponding functions are: <B>gridx(.), gridy(.), gridz(.)</B>. 

The four arguments for each are:   <# blue>Graph ID (scalar),  Inner End Value,  Outer End Value,  No. Segments<# black>. 
E.g. for the X axis of a 2D graph, 'Inner End Value' would be the value at the left end of the axis, and 'Outer End Value' at the right end. (Note that I do not use 'minimum value' and 'maximum value'; that is because it is perfectly legal to reverse the direction of increase, so that values of X decrease as one moves from left to right.)
The number of segments is the number of spaces between hair lines (including those at inner and outer ends). For example, if the graph was to stretch from x = 0 to x = 2, and was to have one internal hairline at x = 1, then there would be two segments.

The arguments after the graph ID can occur as three scalars or as a single array (or as some array - scalar combination), as long as there are always exactly three values represented.

The functions RETURN an array. 
If the graph was successfully identified, and arguments were valid (i.e. Inner End and Outer End Values different, and  segments - after rounding - is at least 1), then the array is made up of the same three values passed to it: { Inner End Value, Outer End Value, No. Segments}.
If such an error occurred, the return is an array of size 1, value NaN; and a call to 'empty(.)' would return TRUE.

<u>SETTING THE SCALE FOR ALL AXES AT ONCE</u>
Use the function <b>grid(.)</b>, for both 2D and 3D graphs.
The format for a 2D graph (using "inner" for "inner end value", and "segs" for no. segments):
	grid( GraphID,   Xinner, Xouter, Xsegs,   Yinner, Youter, Ysegs )
The format for a 3D graph:
	grid( GraphID,   Xinner, Xouter, Xsegs,   Yinner, Youter, Ysegs,   Zinner, Zouter, Zsegs )
Again, the arguments after the graph ID can occur as separate scalars, as a single array, or as any array - scalar combination, as long as there are always exactly six values (for 2D graphs) or nine values (for 3D graphs) represented.

The return from "grid(.)" is an array (holding the input argument parameters), if no errors, or an array of size 1, value NaN if error (and a call to 'empty(.)' would return TRUE).
==================================================================
//HEADER: see 'LABELX'
============================================================
//HEX//
//UNHEX//
//BIN//
//UNBIN//
<B>hex(Scalar / Array Values [, scalar MinimumDigits ])</B> -- The hex version of the value(s), with up to 16 hex digits per vaue. (Larger numbers default to hex '8000 0000 0000 0000'). Fractional parts of the number are ignored. Negative numbers return complemented numbers; e.g. 'hex(-1)' returns a string of 16 'F's. If there is a second argument, it forces the least number of digits (with zero padding at the start, if necessary). E.g.: 'hex(1e6)' --> 'F4240';  'hex(1e6,2)' --> the same;  'hex(1e6,7)' --> '00F4240'.

Where 'Values' is an array, the precision (if present) applies to each value. Values are concatenated into the string; e.g
	<# blue>ss = hex(  data(1, 2, 3), 2);  <# magenta>// 'ss' will end up as the string "010203".<# black>
 
<B>unhex(chars. array HexString [, bool isInt16] )</B> -- Converts a hex-coded number (as a string of characters) to its scalar value. If there is no boolean argument, or it is FALSE, will convert up to 16 hex digits; but for HexString beyond "7fff ffff ffff ffff" (16 digits) will result in a negative no. If HexString has more than 16 digits, only the right 16 will be accessed and so converted.
If the boolean is present and TRUE, the function will convert only up to 8 digits, and HexString beyond "7fff ffff" returns a negative value. HexString is not case-sensitive. Spaces and tabs within HexString are tolerated, but no other characters (e.g. no prefix "0X" allowed).

<B>bin</B>(<# blue>scalar Value [, scalar GroupSize [, char. array Delimiter ] ]<# black>) -- the binary version of the number, for numbers up to the 8 hex digits 7FFF FFFF (i.e. 0 to 2,147,483,647). Negative numbers return complemented numbers; e.g. 'hex(-1)' returns a string of 32 '1's. Fractional numbers are rounded first (banker's rounding). 
'GroupSize', if present and >= 1, (a) causes left-padding of the string with '0' till its length is a multiple of GroupSize; and (b) if  Delimiter is supplied, divides the string up into packets of length GroupSize, separated by Delimiter.
Inverse function: 'unbin(.)'.

<B>unbin(array Values [, scalar TreatAsCharsArray]) </B> -- Returns the number represented by the binary digits implied by Values. If Values is to be treated as a chars. array, all chars. other than '0' (unicode 48) and '1' (49) will be ignored; and the first '0' or '1' of the array is treated as the most significant bit. Hence, "unbin('0000-1000')" will produce 8. If Values is to be treated as a non-chars. array, zero is taken to represent binary digit 0 and any nonzero value as digit 1. This time, the first value in the array is taken as the <I>least</I> significant bit. "unbin(data(0, 0, -123))" would also return 8. If pseudoboolean argument 'TreatAsCharsArray' is present, its value overrides the internally stored 'IsChars' rating of array Values.
============================================================
//HOMEDIRECTORY  --  see CHECKDIRECTORY
============================================================
//HOTKEYSOFF//
Occasionally you may want to disable the graph menu's hot keys; I did this, for example, when building an editable table in a graph; I wanted to use Cntrl-Left etc. to move the edit focus from cell to cell. The instruction (VOID) is

	<# blue>hotkeysoff(scalar GraphID)<# black>

If you get the GraphID wrong there is no error message; simply nothing happens.

Even though they are turned off, the hot key prompts on the menus will still be visible.

There is no way of turning the hot keys back on - when they're gone, they're gone!

============================================================
//HSL//
//HSL_TO_RGB//
<B>COLOUR CONVERSION BETWEEN THE HSL SYSTEM AND THE RGB SYSTEM</B>

<B>hsl</B>(<# blue>Colour argument<# black>) -- Returns an array of size 3, being the HSL values (all in the range 0 to 1) corresponding to a given colour.

'Colour argument' can take many different forms, which are exactly the same as are valid for function 'plot(.)'. For a list and code demonstrations of allowed forms, enter 'colour' into the Assignments Window and click on it.

An improper argument returns Black (i.e. the array [0, 0, 0]).

The returned array is made up thus: [0] is Hue, [1] is Saturation, [2] is Luminescence.

Note, when interpreting results, that (a) Hue 0 = Hue 1, due to rap-around of the colour system; and (b) with grey, Hue is indeterminate (though a value is returned here).


<B>hsl_to_rgb</B>(<# blue>HSL array<# black>) -- Given an array HSL of length three, with all values in the range 0 to 1, returns an array of size three, being the corresponding RGB colour values: [0] = Red, [1] = Green, [2] = Blue. Erratic argument returns black - the array [0, 0, 0].


For more on colour, enter 'colour' into the assignments window and then key F1.
============================================================setbins(
//HISTOGRAM//
//SETBINS//
//PLOTBINS//
<just c><b>BAR GRAPHS AND HISTOGRAMS</b>
<just l>

There are two functions which work happily together to produce a histogram, though they can be used separately. The first function, <b>setbins</b>(.), compartmentalizes a given set of data into 'bins' of set width. The second function, <b>plotbins</b>(.) uses the output of 'setbins' (or other separately produced data) to produce a bar graph made up of colour-filled rectangular bar shapes.

<B>setbins</B>(<# blue>DataArray [, scalars BinWidth, LoCentre, HiCentre, IncludeAllData ]<# black>) -- Given an array of data, use it to fill a number of compartments or 'bins' which represent subranges of that data. Note that you have to supply either just one argument (where you simply want a rough idea of the spread of data, and so will accept program defaults) or the full set of five arguments.

<U>Arguments:</U>
<I>DataArray</I> -- Its structure is irrelevant, but it must have a total length of at least 4. For this function to be useful, the data would obviously have to be spread across a significantly large range of values.
<I>BinWidth</I> -- for the histogram that is to be produced, this would be the subrange of data that is to be fitted into each bar of the graph.
<i>LoCentre </i> -- the centre, on the X axis, of the lowest bar. Hence, the central value in the lowest data bin.
<i>HiCentre </i> -- the centre, on the X axis, of the highest bar. Hence the central value in the highest data bin.
It is important, for the sake of appearances and good scaling, to ensure that BinWidth exactly divides (HiCentre ‒ LoCentre). Then the number of bins or bars will be given by  1 + (HiCentre ‒ LoCentre) / BinWidth.
Note also that you must have at least four bins. If the above formula produces a smaller number of bins, BinWidth will be internally reset such that there are four bins.
<i>IncludeAllData</i> -- A boolean which determines what happens to data that is outside of the ranges that you have set; that is, data less than half a bin width below LoCentre and more than half a bin width above HiCentre. If 'true', all that data is included in the nearest bin; otherwise it is simply omitted from the bins altogether (though not from the returned statistics  - see later). (In the case where only one argument is supplied, all data is always included, as LoCentre and HiCentre are internally calculated to include all data.)

<U>Assignment to compartments:</U>
If a given bin extends from some value 'lo' to some value 'hi', then for every datum 'd' in the range  <# blue>lo ≤ d \< hi<# black>, that bin's total will be incremented.

<U>Returned:</U>  
A <B>matrix</B>, with three rows, the row length being the number of bins. 
<bullet>Row 0 holds the lower X axis coordinates of the bins;
<bullet>Row 1 holds their higher X axis coordinates;
<bullet>Row 2 gives the content of individual bins;
<bullet>Row 3 provides (a) an indication of success or failure; and if success, (b) some statistics for the data.
<bullet 50,➯>Element 0 is positive if there is no error; it is equal to the number of bins of data. If there is an error, it is negative. Specific codes for error are: -1, for DataArray too small (\< 4 items); -2 for LoCentre and HiCentre being equal or crossed.

<u>Example of a returned matrix:</u>
Suppose we have data spread over the range 0 to 30, but most of it fits in the range 10 to 18. So we decide to have bins that occupy the ranges 10-12, 12-14, 14-16 and 16-18: four bars in all. it turns out that there are 11 values in DataArray that are smaller than 10; 3 values in the range 10-12; 8 in the range 12-14; 7 in the range 14-16; 4 in the range 16-18; and 6 values larger than 18. The returned matrix would look like this:
	Row [0]: BIN STARTS:	[	10,		12,		14,		16		]
	Row [1]: BIN ENDS:		[	12,		14,		16,		18		]
	Row [2]: DATA:			[ {11+}3,	  8,		  7,		 4{+6}	]   <# magenta>// If IncludeAllData TRUE, the bits in braces are added in.<# black>
	Row [3]: STATS:		[ NoBars	Mean	SD		Var.	]   <# magenta>// SD and Variance use the traditional divisor (pop. size -1)<# black>

<u>What happens in the single-argument case?</u>
The program first computes the statistics, then sets parameters such that there are 3 bins between standard deviations, and a total of at least 12 bins to enclose all of the given data.

	_____________________________________

There are two versions of function <b>plotbins</b>, one for ad hoc usage, and one to directly accommodate the output of function <b>setbins</b>. The format is:

<B>plotbins</B>(<# magenta>matrix Mx <# blue>[, scalar BarWidth [,  scalar/array LineShape [, scalar LineWidth [, scalar/array LineColour [, scalar/array FillColour ]]]]]<# black>)
OR
<B>plotbins</B>(<# magenta>array LeftEdges, array RightEdges, array Heights <# blue>[, scalar BarWidth [,  scalar/array LineShape [, scalar LineWidth [, scalar/array LineColour [, scalar/array FillColour ]]]]]<# black>)

Note that the arguments in blue are the same in both cases. The three magenta arrays in the second form are formatted exactly as for the first three rows of the matrix supplied by function <b>setbins</b>.

'BarWidth' sets the width on the graph of the bar, as a fraction of the X axis extent that it represents. If set to 1, bars will be touching; if very small, bars will be needles. (Values ≤ 0 or \> 1 are reset internally to the default 1).

All the blue arguments from 'LineShape' on are as for other plotting functions - may I refer you to the help notes for function <b>plot</b>? (Small difference - there is no equivalent to the 'plot' function argument 'LineFamily', so you can't e.g. have different lines or colours for different bars within the one graph.)

The outcome is not a single plot, but an <i>array of plot IDs</i>, one plot for each bar.
	_____________________________________

<U>Sample Code</U>
To demonstrate, we generate a set of data. We do this using function <b>randgauss</b>, to ensure that the example histogram will have roughly a bell-shaped distribution of bars.

The first step is to get some general idea of what the data looks like; so we just hand the data to MonoMaths without stipulating any parameters.

The second step, after examining the outcome, is to plan a much nicer-looking histogram for the same data.

<# magenta>// Generate an array 'testdata' holding random values with a Gaussian distribution:
<# blue>popsize = 2000;  mean = 50;  SD = 20;   
<# blue>dim(testdata, popsize);   
randgauss(testdata, mean, SD);
<# magenta>// Step 1 - a general idea of what the data looks like, when plotted in histogram form:
<# blue>mx1 = setbins(testdata);
p1 = plotbins(mx1);
g1 = graph(p1);
header(g1, "ROUGH DRAFT");
<# magenta>// After looking at this graph, we decide to do it again, with chosen parameters. We will choose to have bars centred on 0 and 100,
//    and at intervals of 5 in between. Hence, 'BarWidth' will be 5, 'LoCentre' 0, 'HiCentre' 100; and we will allow out-of-range data
//    to be added to the first and last bars:
<# blue>mx2 = setbins(testdata, 5, 0, 100, true);
p2 = plotbins(mx2);
g2 = graph(p2);
header(g2, "BETTER SPREAD OF DATA");
<# magenta>// This in general looks OK, but let's improve on the appearance...<# blue>
p3 = plotbins(mx2, 0.9, '_', 2, 'red', 'white');
g3 = graph(p3);
<# blue>grid(g3,  -10, 110, 12,   0, 300, 6);
header(g3, "FINAL PRODUCT");
===============================================================
//HYPOT -- see DISTANCE
//HYPOTENUSE -- see DISTANCE
============================================================
//INC//
//DEC//
<B>inc(X)</B> increments X by 1, and <B>dec(X)</B> decrements X by 1. If X is an array, every element is incremented / decremented.

NB - 
(1)  X must be a named variable; if an array, the whole array (not e.g. the matrix row 'Mx[0]').
(2)  This function BOTH changes the value of X AND returns the decremented value/array. (You don't have to access the returned value - you can use the function void: "inc(X);".)

Note that when you write "X++" or "X--" in your code, the pre-parser replaces these with "inc(X)" or "dec(X)". (Array segment increments - "Mx[1]++" - are converted instead to "Mx[1] = Mx[1]+1".)
============================================================
//INDEXED//
//OFFSET//
//ADDRESS//
<just c><b>STRUCTURE ADDRESSING -- CONVERTING BETWEEN OFFSET (ABSOLUTE) ADDRESSES AND INDEXED ADDRESSES</b>
<just l>
Consider a 4 x 3 matrix, called "Mx". Its overall size is 12, and all of its data, row by row, is laid down internally in a single C# array in MonoMaths. The <i>offset address</i> (or <i>absolute address</i>) of some datum is its address within this internal array; while the <i>indexed address</i> is the format which you use in addressing that datum. For example, the last datum in Mx has the indexed address [3, 2] and the offset address 11.

There are two functions available for converting between the two address types. Both can handle multiple addresses if needed.


<u>CONVERTING FROM OFFSET ADDRESS TO INDEXED ADDRESS</u>
<B>indexed</B>(<# blue>array Struct,  scalar / array OffsetAddresses [,  bool  LowToLow ]<# black>)
<i>Struct</i> is either -
<bullet>A 2D or higher order structure (currently MonoMaths only allows up to 3 dimensions). In this case no data is accessed; the argument is used purely to supply dimensional sizing.
<bullet>A list array. In this case its elements are taken as the dimensions of a hypothetical structure of any number of dimensions, Struct[0] corresponding to the highest address. E.g. if modelling a 6-dimensional structure of dimensions 6x5x4x3x2x1, Struct would be the array [6, 5, 4, 3, 2, 1].
<i>OffsetAddresses:</i>  if scalar, then this single offset address will return a <i>list array</i>, which is the indexed address. If an array, then each element is converted to an indexed address, and the return is a matrix for which the number of rows is the number of offset addresses, i.e. the length of array OffsetAddresses.
<i>LowToLow:</i>  If this argument is omitted or FALSE, then the order of parts of the indexed address will be such that the lowest dimension is recorded in the highest element. For example, given a 5x4x3 structure (5 tiers, 4 rows, 3 columns), the last offset address, which is 59, would provide the output array [4, 3, 2]. (Indeed you would refer to this last element in your code as "Mx[4, 3, 2]".)  If you don't like this, reverse the order by making this 3rd. argument TRUE; in which case the returned array would be [2, 3, 4].


<u>CONVERTING FROM INDEXED ADDRESS TO OFFSET ADDRESS</u>
<B>offset</B>(<# blue>array Struct,  array IndexAddresses<# black>)
<i>Struct</i> is either -
<bullet>A 2D or higher order structure (currently MonoMaths only allows up to 3 dimensions). In this case no data is accessed; the argument is used purely to supply dimensional sizing.
<bullet>A list array. In this case its elements are taken as the dimensions of a hypothetical structure of any number of dimensions, Struct[0] corresponding to the highest address. E.g. if modelling a 6-dimensional structure of dimensions 6x5x4x3x2x1, Struct would be the array [6, 5, 4, 3, 2, 1].

The return depends on the form of argument <b>IndexAddresses</b>.
<bullet>If it is a <i>list array</i>, then it is taken as a single address (and therefore must have a length equal to the number of dimensions of Struct); the return is <i>scalar</i>, the offset address.
<bullet>If IndexAddresses is a <i>matrix</i>, then each row is taken as a separate address (so that the row length must equal the number of dimensions in Struct), and the return is a <i>list array</i> containing the corresponding offset addresses.


If what you want instead is to directly read from or write to the internal data strip of the array using the offset address, the function to use is <b>datastrip</b>.
============================================================
//INI_DATA//
<just c><b>ACCESSING INI FILE DATA</b>
<just l>
The function described here would be rarely needed, and is not a 'comfortable' function. I wrote it for a particular specialized purpose. At any rate, here it is...

<b>ini_data</b>(<# blue>optional array SearchTarget)<# black> -- The INI file consists of paragraphs which are all in the form: "some_property=some_value". Of all the LHS's of these assignment statements, those which contain Target are selected. This subset, along with their RHS values, are then returned in the form of a delimited list array. The delimiter is always MAXINT32. For each property there will be two delimited subarrays: the property, the delimiter, the value. The same delimiter separates separate property-value pairs.
Where a value is a string (e.g. a file name), its subarray will consist of the unicodes of the string. Where the value is numerical (an integer or a real number), as a single numerical value, not as a string version of the number. Where the value is a colour, the colour is given as three successive numerical values, being the R, G and B bytes of the colour.

If there were no finds, the return is data(32) - the space unicode.

If there is no argument, or if it is scalar, then all properties within the INI file which have assigned values will be returned.

You can extract data using 'getsegmt'. Remember that you will have to convert subarrays using 'chars(.)', if they are meant to be interpreted as strings. 

E.g. the following returns the name of the font used by the Assignments window, and its size in points. 

	<# blue>nameStuff = ini_data("FontNameAss");
	fontName = getegmt(nameStuff, MAXINT32, 1);
	chars(fontName);
	sizeStuff = ini_data("FontPointsAss");
	arr = getsegmt(sizeStuff, MAXINT32, 1);
	fontSize = arr[0];
	writeln("Font name:  ", fontName, ";  font size (pts.): ", str(fontSize) );


============================================================
//INJECT//
<b>FUNCTION "INJECT"</b>

<b>What does it do?</b>
Very much a niche function. I use it in the following context. In my Hippocampal Modelling program I have to give particular neuron receptors and firing units rather complex names like "GuN_CA1Pyr_1" (glutamatergic receptor of type NMDA in a pyramidal cell of the CA1 area of the hippocampus, this being the first such - no. 1). There can be a large number of these. To save time I do as follows:
	<# blue>NeuronNames = text("GuN_CA3Pyr_1|GuN_CA3Pyr_2|GuA_CA1Pyr_1|GuA_CA1Pyr_2|Ga_CA1CCK_1| .... ");
	inject(NeuronNames);<# black>
I can now use the string NeuronNames as a source of names for graphs and other displays of neuronal activity; and function "inject" has created variables with the delimited names:  GuN_CA3Pyr_1,  GuN_CA3Pyr_1, ..., and assigned to them the values 0, 1, 2, ... (so that now they can be used as indices; e.g. as row numbers in a matrix of neuron properties).  

So, more formally...
	<b>inject </b>(<# blue>[ scalar / array <b>DataToInsert</b> ],   char. array  <b>VarNames</b> [,  bool <b>returnStatsArray</b> ]<# black>) -- Does the following:
<bullet>Devises a set of values from the first argument (or according to an internal rule, if no first argument);
<bullet>Looks for a delimiter in VarNames, and on finding it, divides the char. array into subarrays;
<bullet>Takes these as scalar variable names, and assigns from the set of values to each of these scalars.

RETURN: The function can safely be used as if VOID, as errors all cause a crash. If there is no final optional argument, a SCALAR value is returned: the number of substrings in VarNames (and so the number of values used up from DataToInsert).
But if you really want some statistics, add the final argument and make it TRUE. Then the returned list array is: [0] = the number of substrings in VarNames (and so the number of values used up from DataToInsert); [1] = the number of strings which would be valid as variable names but which do not occur anywhere in the rest of code (at the same function level); [2] = the number of strings which were empty (or consisted only of spaces).

The function CRASHES if a substring of VarNames is NOT one of these: (a) a scalar variable referenced somewhere else in code at the same function level (either before or after the 'inject' statement);  or (b) legal for a variable name, though unused in code at this fn. level; or (b) is an empty string (or a string consisting only of spaces). Hence it crashes if the substring contains illegal characters, or if it is the name of a system function or user function, a keyword, or if the name is already in use for an array or constant.

The arguments...
<bullet><i>VarNames</i>:  The first non-identifier character in the array is taken as the delimiter: e.g. '|' in "var1|var2". If no such character found, the whole array is treated as a single name. Using this delimiter, a set of potential variable names is built. Spaces at the start and end of the array, and around delimiters, are ignored; but internal spaces are not (and so would produce invalid variable names).
<bullet 35,>The variable names dissected out of VarNames obey the following rules:
<bullet 50,➯>If such a variable name refers to a pre-assigned scalar (e.g. "var1 = 10" preceded the call to 'inject' with the above VarNames), that variable simply receives the new value.
<bullet 50,➯>If the name exists in the program only <i>beyond</i> the call to 'inject' - so that it is unassigned at the time of the call - then it is here assigned, and given its value.
<bullet 50,➯>If there is no reference to this variable anywhere in the same code scope (e.g. "var1" is never referred to), it is not created, but the value which would have been assigned to it is used up. So, for example, with "inject(x|y|z)", z will receive the same value (i.e. 2) whether or not x and y exist elsewhere in the code scope.
<bullet 50,➯>If the name is invalid as an identifier (e.g. "var 1" - internal space; or is a keyword or function name - e.g. "sin"), a crash occurs.
<bullet><i>DataToInsert</i>:
<bullet 50,➯>If absent, values are assigned from the arithmetic series "0, 1, 2, 3, ....".
<bullet 50,➯>If scalar, all variables receive this same value.
<bullet 50,➯>If an array, variables receive successive values in the array. (If the array is too short, wrap-around occurs; if too long, ony the required values are used.)
<bullet><i>returnStatsArray</i>:  As mentioned above under 'return'. The returned value will be scalar if this argument is missing or FALSE.

The delimiter can be any character not currently used as an identifier character. Commonly this might be a comma, a semicolon or '|'. You can use spaces, but if you do, understand that (a) leading and trailing spaces for the whole array VarNames will still be removed before delimiters are sought; and (b) every internal space will be taken as a delimiter; e.g. "a  b" - two spaces between 'a' and 'b' - will be seen as made up of three strings, the middle one (notionally between the two spaces) being empty.


<u>EXAMPLES</u>
1. No reference to the variable names elsewhere in code at the same function level. E.g. the whole program is just:
	<# blue>inject("x|y");   <# magenta>// No error raised, but variables x and y will not exist.<# black>

2. Not all variable names are used elsewhere in code. E.g. the whole program is just:
	<# blue>x = 10;   inject("x|y");  <# black>OR <# blue>inject("x|y");  x = 10;	<# magenta>// No error raised, but variable y will not exist.<# black>

3. Array v. scalar return:
	<# blue>n = inject("x|y|z");  <# magenta>// This will provide x = 0, y = 1 and z = 2;  'n' will be scalar value 3.<# blue>
	aa = inject("x|y|z", true);  <# magenta>// assignments as above;  'aa' will be the array [3, 0, 0], if x, y, z used elsewhere; if none are, 'aa' will be [3, 3, 0].<# black>

4. Use of extra delimiters to alter the data assignation. Here we assume that x, y and z are all referred to elsewhere in code. (The next line in each case might be, for example, "p = x + y + z;").
	<# blue>inject("|x|y|z");  <# magenta>// The first name is an empty string, so no assignation is made, but '0; is used up.
				//  Therefore the assignments will be:  x = 1, y = 2 and z = 3.
	<# blue>aa = inject("||x||y||z", true);  <# magenta>// There are four empty strings, so after allowing for these,
				//  assignments will be:  x = 2, y = 4 and z = 6; and 'aa' will be [7, 0, 4].<# black>

5. Use of the argument <b>DataToInsert</b>:
Again, we assume that x, y and z are referenced somewhere within the same function scope.
	<# blue>inject(100, "x|y|z");  <# magenta>// This will provide x = y = z = 100.
	<# blue>inject(data(10, 100, 1000), "x|y|z");  <# magenta>// This will provide x = 10,  y = 100,  z = 1000.
	<# blue>inject(data(1, 2), "x|y|z");  <# magenta>// Too little data, so it is recycled: -->  x = 1,  y = 2,  z = 1.
	<# blue>inject(data(1, 2, 3, 4, 5, 6), "x|y|z");  <# magenta>// Too much data, so some ignored: -->  x = 1,  y = 2,  z = 3.

============================================================
//INSERT  --  see COPY
============================================================
//INSERTCOLS//
//INSERTROWS//
//APPENDROWS//
//APPENDCOLS//
//COPYROWS//
//COPYCOLS//
//COPYROWSTO//
//COPYCOLSTO//
//REPLACEROWS//
//REPLACECOLS//
<B>INSERTING, APPENDING, COPYING, REPLACING MATRIX ROWS AND COLUMNS </B>

<b>insertrows</b> (<# blue>matrix InMatrix, scalar AtWhichRow,  scalar / array NewData [, scalar NoTimesToAdd]<# black> ) -- NOT void. Returns a copy of InMatrix with extra row(s) inserted.
'AtWhichRow' will be the row at which the added material will start; the preexisting row there in InMatrix will be pushed down, along with its later rows. If AtWhichRow is out of range (i.e. does not refer to an existing row of InMatrix) an error is raised.
'NewData' can be: (1) a scalar, in which case it is converted internally to a single row of that value repeated. (2) a list array, in which case it must be divisible exactly by the row length of InMatrix; (3) a matrix, in which case it must have the same row length as InMatrix. 
'NoTimesToAdd' causes the above operation to be repeated that many times, the same row or set of rows being inserted each time. If it is \< 1, the returned matrix is a simple copy of InMatrix (with no error raised).

<b>insertcols</b> (<# blue>matrix InMatrix, scalar AtWhichCol,  scalar / array NewData [, scalar NoTimesToAdd]<# black> ) -- NOT void. Returns a copy of InMatrix with extra column(s) inserted.
'AtWhichCol' will be the column at which the added material will start; the preexisting column there in InMatrix will be pushed to the right, along with its later columns. If AtWhichCol is out of range (i.e. does not refer to an existing column of InMatrix) an error is raised.
'NewData' can be: (1) a scalar, in which case it is converted internally to a single column of that value repeated. (2) a list array, in which case it must be divisible exactly by the no. of rows of InMatrix; (3) a matrix, in which case it must have the same no. of rows as InMatrix. 
'NoTimesToAdd' causes the above operation to be repeated that many times, the same column or set of columns being inserted each time. If it is \< 1, the returned matrix is a simple copy of InMatrix (with no error raised).


<b>appendrows</b> (<# blue>matrix InMatrix, scalar / array NewData [, scalar NoTimesToAdd]<# black> ) -- NOT void. Returns a copy of InMatrix with extra row(s) appended.
'NewData' can be: (1) a scalar, in which case it is converted internally to a single row of that value repeated. (2) a list array, in which case it must be divisible exactly by the row length of InMatrix; (3) a matrix, in which case it must have the same row length as InMatrix. 
'NoTimesToAdd' causes the above operation to be repeated that many times, the same row or set of rows being inserted each time. If it is \< 1, the returned matrix is a simple copy of InMatrix (with no error raised).

<b>appendcols</b> (<# blue>matrix InMatrix,  scalar / array NewData [, scalar NoTimesToAdd]<# black> ) -- NOT void. Returns a copy of InMatrix with extra column(s) appended.
'NewData' can be: (1) a scalar, in which case it is converted internally to a single column of that value repeated. (2) a list array, in which case it must be divisible exactly by the no. of rows of InMatrix; (3) a matrix, in which case it must have the same no. of rows as InMatrix. 
'NoTimesToAdd' causes the above operation to be repeated that many times, the same column or set of columns being inserted each time. If it is \< 1, the returned matrix is a simple copy of InMatrix (with no error raised).


<B>copyrows, copycols</B>(<# blue>Matrix, Scalar  FirstRow/Column), [Scalar Extent]<# black>) -- Copies designated rows / columns from Matrix into a new matrix of appropriate size, which is returned. Unlike with function "copy(.)" and other functions on this page, there is no adjustment of arguments; they must be consistent with the dimensions of Matrix. If Extent is omitted, all rows / columns from FirstRow/Column will be copied.

<B>copyrowsto, copycolsto</B>(<# blue>Matrix, Scalar  FirstRow/Column, Scalar LastRow/Column<# black>) -- differs from the above only in that the final argument is not an extent but instead states the last row or column to be copied. As above, there is zero tolerance of argument mismatches.


<B>replacerows </B>(<# blue>matrix InMatrix, scalar Where,  variable NewData [, scalar Repetitions]<# black>) -- NOT void. Returns a copy of InMatrix with a series of rows overwritten by NewData. 'Where' will be the index of the first overwritten row. If Where is < 0 or > index of last row, an error is raised. An error is also raised if the supplied data would overflow the bounds of InMatrix.
The function behaves differently depending on the argument. Examples using 'x' for scalar, 'Mx' for matrix, and 'arr' for a list array.
<# blue>replacerows(Mx, Where, x) <# magenta>// replaces row Where with a row full of the value in x.
<# blue>replacerows(Mx, Where, x, 3) <# magenta>// replaces 3 rows, starting with row Where, with rows full of the value in x. (If the last argument is absent or < 1, it defaults to 1.)
<# blue>replacerows(Mx, Where, arr) <# magenta>// Replaces one or more rows, depending on the length of 'arr'; \n\t// the length of 'arr' MUST be an integral multiple of the row size of Mx. The data fills\n\t// one row from left to right and then starts at the left of the next row down.
<# blue>replacerows(Mx, Where, Mx1) <# magenta>// Replaces from row Where with the whole matrix Mx1.
<# black>
<B>replacecols </B>(<# blue>matrix InMatrix,  scalar Where,  variable NewData [, scalar Repetitions]<# black>) -- NOT void. Returns a copy of InMatrix with a series of columns overwritten by NewData. 'Where' will be the index of the first overwritten column. If Where is < 0 or > index of last column, an error is raised. An error is also raised if the supplied data would overflow the bounds of InMatrix.
The function behaves differently depending on the argument. Examples using 'x' for scalar, 'Mx' for matrix, and 'arr' for a list array.
<# blue>replacecols(Mx, Where, x) <# magenta>// Replaces a column full of the value in x at column Where.
<# blue>replacecols(Mx, Where, x, 3) <# magenta>// Replaces 3 columns full of the value in x. (If the last argument is < 1, it defaults to 1.)
<# blue>replacecols(Mx, Where, arr) <# magenta>// Replaces one or more columns, depending on the length of 'arr'; \n\t// the length of 'arr' MUST be an integral multiple of the column size of Mx. The data fills\n\t // down one column and then starts at the top of the next.
<# blue>replacecols(Mx, Where, Mx1) <# magenta>// Replaces the whole of Mx1 into Mx.
<# black>Note, in particular, that if you convert Mx1 to a list arr 'arr1' and then carry out 'replacecols(Mx, Where, arr1)', the data will be replaced in a different order, in accordance with the above rule. (There is no equivalent difference in the case of 'replacerows(.)'.)

============================================================
//INSERT_IMAGE//
<b>INSERTING AN IMAGE INTO THE ASSIGNMENTS WINDOW</b>

The function is <# blue><b>insert_image</b>(array FilePathName, scalar Width, scalar Height, array LocationCue)<# black>

<i>FilePathName:</i>  The usual abbreviations, notably "~/" for home directory, can be used.

<i>Width, Height:</i>  If either is less than 10 (e.g. 0, or any negative value), both values are ignored, and the image's natural size is used. Otherwise these will define the dimensions of the image in the Assignments Window.

<i>LocationCue</i>:  This is some string which is sitting where you want the image to go. The image will replace the cue text. Usually you would make it occupy a separate line of text. If you want the image inset from the left edge, use tabs or spaces to the left of the cue string. NB - best to build the string from two parts in your 'insert_image' call, otherwise the picture might end up in the middle of your call to 'insert_image'! E.g. if your cue is "[image1]",  then the argument should be built like this: "LocnCue = text('[', 'image1]');"

<b>Returned:</b>  Always a chars. array. If all went well (and you can see the image), the returned array has length 1, a space character ' '. If not, you won't see an image, and the returned array will tell you why (length always greater than 1).

The only error that crashes the program is where FilePathName is scalar or contains no printable characters.
============================================================
//INTEGRAL//
//INTEGRATE//
//INTEGRATION//
//INTCURVE//
The function <B>integral(..)</B> gives a definite integral between given limits, and the function <B>intcurve(..)</B> gives a matrix of X and Y values for plotting the integral curve.

<B>integral</B>(<# blue>Array (integrand), Scalar (low end of range), Scalar (high end of range)) <# black> -- Produces the definite integral between the given limits. Uses Simpson's rule for numerical integration (which in effect fits quadratic curves between points). The integrand array MUST have an odd number of values, at least 3.  Example:
\t<# blue>yvalues = fill(21, 0, 0, 1/sqr(20)); <# magenta>// creates 21 values for y=x^2, from x=0 to x=1.
\t<# blue>area = integral(yvalues, 0, 1); <# magenta>// area under the curve y = x^2 from x=0 to x=1<# black>

<B>intcurve</B>(<# blue>Array (integrand), Scalar (low end of range), Scalar (high end of range) [, Scalar (const. of integration)]<# black>) -- Returns a matrix which contains X and Y values for plotting the integral curve of the integrand curve. Uses Simpson's rule for numerical integration (which in effect fits quadratic curves between points). The integrand array MUST have an odd number of values, at least 3. If there is a 4th. argument, it is simply added to every value in the returned array as an offset.
\tThe 0th. row of the returned mx is the X values corresponding to the Y values in the 1st. row.

Example:
<# magenta>	// Plot a curve of y = sin(x) from 0 to 2PI:
<# blue>	NoPoints = 101;  
	xx = ladder(NoPoints, 0, 2*PI);
	yy = sin(xx);
	p1 = plot(yy,xx); <# magenta>// the integrand curve (which will be black)
	// Integrate, and plot the curve of the integral (which will be green):
<# blue>	mx = intcurve(yy, 0, 2*PI, -1); <# magenta>// offset of -1 is to balance the curve around the X axis (looks nicer).
<# blue>	p2 = plot(mx[1], mx[0],   '.', 3, "green",  '_', 1, "green" );
<# magenta>	// Graph the two curves:
<# blue>	g = graph(p1, p2); <# magenta>// plot both curves on the one graph.
<# magenta>	// A little embellishment, for the optics...
<# blue>	grid(g, 0, 2*PI, 4,    -1, 1, 2);
	scalefudgex(g, 1/PI, " π", true, true); <# magenta>// convert scale from simple numerals to multiples of PI.
<# black>
============================================================
//INTERPOLATE//
//INTERPOLATION//
<just c><b>INTERPOLATION BETWEEN REFERENCE VALUES</b>
<just l>
You have some reference array, "RefArray", such as [ 10, 20, 25, 20 ]. You can see that RefArray[1] is 20, and RefArray[2] is 25. Now suppose fractional indices were allowed; you would like to be able to evaluate RefArray[1.2], for instance. By inspection, you can see that the linear interpolation for this index would be 21 - i.e. 0.2 of the way from RefArray[1] to RefArray[2].

The function is <b>interpolate(<# blue>scalar / array PseudoIndexes,  list array RefArray<# black>)</b>.

<i>PseudoIndexes</i>:  If RefArray has length L, then values in PseudoIndexes should be within this range for interpolation. Extrapolation is completely legal (i.e. values \< 0 or ≥ L), but you lose accuracy if you stray too far from RefArray's extremes. The values in PseudoIndexes do not have to be in any order.
The function's return will be of the same form as PseudoIndexes - scalar, list array or structured array (a non-chars. array).

<i>RefArray</i>:  Structure ignored; if it is multidimensional, PseudoIndexes values will refer to the absolute address in the array. 
There is no restriction on the ordering of values in RefArray, but it must make mathematical sense to do linear interpolation between its values.

Interpolation only ever involves the two nearest elements of RefArray, these being RefArray[ floor(p)] and RefArray[ceiling(p)], where p is the pseudoindex. (With extrapolation, the two extreme values at the appropriate end of RefArray are used.)  If p is in fact integral and within the range 0 to L-1, the return will simply be RefArray[p].

Try this simple graphing program to see it at work. On the graph, refArray values are represented by red circles and interpolated values by blue dots.
	<# blue>refArray = ladder(10, 0, 1);  
	refArray = refArray^2;  <# magenta>// refArray now consists of the squares of the ten values { 0, 0.1, 0.2, ... 1 }
	<# blue>xx = fill(10, 0, 1);  <# magenta>// the array indices for refArray, for the purposes of graphing.
	<# blue>pseudoIndexes = ladder(0.25, -1.5, 10.5,  true);  <# magenta>// pseudo-indices will be { -1.5, -1.25, -1, ... 10, 10.25, 10.5 }
	<# blue><b>output = interpolate(pseudoIndexes, refArray);</b>
	p1 = plot(refArray,  xx,  'o', 6, 'red', ' '); <# magenta>// Plot refArray v. its indices.
	<# blue>p2 = plot(output, pseudoIndexes,  '.', 3, 'blue', ' '); <# magenta>// Plot the interpolated values v. the pseudo-indices.
	<# blue>g = graph(p1, p2);
	footer(g, "Reference array values are red circles, interpolated values are blue dots.");<# black>

The inverse function is <b>placement(.)</b>. The two work well together where you are consulting a table of X-values v. Y-values. Given an X value which may lie between X values provided in the table, find the corresponding interpolated Y value. To see an example, go to the bottom of the hint for 'placement'.

See also function 'readtable'.
============================================================
//INTERSECTION//
<B>intersection</B>(<# blue>at least two arrays<# black>) -- Returns a list array containing all values common to all arrays (structure and chars. rating ignored).

Duplicates are removed from the returned array.

If no common values found, an array of size 1, content NaN, is returned; and a call to 'empty(.)' returns 'true'.
============================================================
//INVERSE -- see MATRIX
============================================================
//IOFILE//
<B>iofile</B>(<# blue>scalar Dummy or array WhichPart<# black>) -- Always returns a chars. array. Where a file load or save operation has successfully occurred, this will be the file name of that operation, and will remain so until the next such operation. Where such an operation fails, instead this will return an array of length 1, the space character (32). The space character is also returned if there has not yet been such an operation since the run began. <i>Argument:</i>  If a scalar argument, the whole file path and name is returned. If an array, its first character is checked; if 'P' or 'p', only the path is returned (terminated by the character '/'); if 'N' or 'n', only the name is returned; anything else defaults to returning the full path and name.
============================================================
//IOK//
//IOMESSAGE//
Functions <b>iok()</b> and <b>iomessage()</b> reflect the success or failure of the last call to disk I/O functions 'load' and 'save'. (They are not affected by other file functions like 'filesize'.) More complete details of what they return will be found by keying F1 at the name of the appropriate disk I/O function.  But the following generally applies...

<b>iok()</b> returns:
<bullet>TRUE if (a) there has not yet been a disk I/O function call since startup; or (b) if the last such call was successful.
<bullet>FALSE if the disk I/O function call failed because of (a) some error; or (b) cancellation in a dialog box (e.g. asking for a file name) by the user.

<b>iomessage()</b>  always returns a chars. array:
<bullet>A single space, if EITHER there is no error (iok() TRUE) OR the user cancelled from a dialog box.
<bullet>An error message, if iok() is FALSE for any reason other than dialog box cancellation.
<bullet>Where iok() returns TRUE after a call to "load('A', ...)", iomessage() holds not an error message but the name of the array when it was saved, and the time at which it was saved. (Enter 'load' into the Assignments Window and key F1, for details.)

Both functions may be called more than once after a particular I/O function; that is, calls to these functions do not reset internal buffers.

See also function <b>iofile(.)</b>, which returns the full path and / or file name of a successfully loaded or saved file.
============================================================
//IS//
//NOT//
<B>UNARY LOGIC FUNCTIONS </B>

<B>is</B>(<# blue>Variable [, scalar Tolerance ] <# black>)

<I>Single argument:</I>  Nonvoid; the return object has the same structure as Variable (it can even be scalar). Wherever an element of Variable is nonzero, the returned structure's corresponding element will be 1; wherever the element of Variable is exactly 0, the corresponding returned element will be 0.

<I>Two arguments:</I>  As above, except that if 'Tolerance' is nonnegative, any element in Variable which has absolute value <= Tolerance will be scored as if it were exactly 0. (If Tolerance is < 0, it is ignored.)

Check whether function 'matches(.)' is closer to what you want.


<B>not</B>(<# blue>Variable [, scalar Tolerance ]<# black>) -- the exact complement of the above function.

<I>Single argument:</I>  Nonvoid; the return object has the same structure as Variable (it can even be scalar). Wherever an element of Variable is exactly zero, the returned structure's corresponding element will be 1; wherever the element of Variable is nonzero, the corresponding returned element will be 0.

<I>Two arguments:</I>  As above, except that if 'Tolerance' is nonnegative, any element in Variable which has absolute value <= Tolerance will be scored as if it were exactly 0. (If Tolerance is < 0, it is ignored.)

Check whether function 'mismatches(.)' is closer to what you want.


Sometimes it is useful to know if there is <I>any</I> value in an array which is not zero, or <I>any</I> value in an array which is zero. Functions <B>allzero(.)</B> can be used in the first case, and <B>nozero(.)</B> in the second.

See also binary logic functions 'and(.)', 'or(.)', 'xor(.)' and 'xorcomp(.)'; and functions 'matches(.)', 'mismatches(.)'.
============================================================
//ISARRAY//
<B>isarray(<# blue>Array<# black>)</B> evaluates to 0 for a scalar argument and 1 for an array argument.
============================================================
//ISGRAPH,  ISPLOT -- see KILLGRAPHS
//ISINTEGRAL -- see MOD
============================================================
//ISNAN//
<b>isnan</b>(<# blue>a single variable<# black>) -- returns TRUE for each value which is set to NaN. Returns a scalar if a scalar argument, otherwise an array of the same structure as the argument. This function is necessary because "(x == NaN).." will always return false, even when x has been set to NaN. (This is inherent in the underlying C# language in which MonoMaths is written.) 
============================================================
//JAGGER//
//JAG//
//RAGGED//
//SPLIT//
//UNJAG//
//JOIN//
<B>EMULATING JAGGED MATRICES</B>

Jagged 2-dimensional arrays (i.e. arrays with rows of differing lengths) don't exist in MiniMaths. There is, however, a workaround, with three functions...

<B>jagger(.)</B> will start (if desired) with an empty array, and then will apply successive rows of data which you supply. You can dictate the length of the rows if you wish, or allow the row length to be set to the length of the longest array. You can also dictate a padding character (to pad the end of shorter rows), or leave it up to MiniMaths to pad with zeroes. Unlike the others below, this function directly changes the input array, and only returns some statistics.

<b>split(.)</b> will return a jagged matrix, built from a single array which has separate strings (future matrix rows) separated from one another by a delimiter.

<b>join(.)</b>will build a single list array from a jagged matrix, using a delimiter to distinguish material from separate rows.

<B>unjag(.)</B> returns the indicated row from the matrix, and trims off the terminal pad values, returning the right-trimmed row as a list array.
____________________________

Sometimes the job might be better done by using a list array which contains all of the subarrays represented by rows above. There are two mechanisms for doing this. To illustrate, suppose that the jagged matrix has three rows, "AAxxx", "BBBxx" and "CCCCC", where 'x' is the padder. Then we could -
<bullet>Use delimiters; e.g. express the same data as "AA|BBB|CCCCC", where '|' is the delimiter. (There are two functions which assist with such delimited sets: "getsegmt(.)" and "findsegmt(.)".)
<bullet>Use a 'train' structure. This has a header section and a data section. The data section for the above would simply  be the concatenation "AABBBCCCCC". The header section holds the information which determines which piece of data is where. There is a rich set of operations for this structure; all use the function <b>train(.)</b>, its first argument being the name of the operation required.
_____________________________

Deprecated function, temporarily allowed to exist for the sake of old programs:

<B>jag(.)</B>  <# red>*** Deprecated function, will soon be removed; don't use in new programs<# black>  --  returns an existing matrix, updated. It will insert or append a new row, or overwrite an existing row, with the supplied array. You have the same choices as above; the length of existing rows will be adjusted with padding or amputation as necessary (your supplied parameters being the basis for this).

            ---------------------------------------------------

<B>jagger</B>(<# blue>array Subject, array Operation, scalar / array NewRow, [, scalar RowNo [, scalar Length [, scalar Padder ] ] ] )<# black>) -- Requires that 'Subject' be predefined, as it will be directly altered by this function. If it is a list array it will be recreated as a matrix with one row, using the supplied data NewRow. If it is already a matrix it will remain so, and the only data that will be altered is what you have decreed to be altered. 
What happens is determined by argument <I>Operation</I>, of which only the first character is examined. 'I' or 'i' causes insertion; 'O' or 'o' (the letter, not the numeral zero) causes overwriting; 'A' or 'a' causes appending. With the new row in situ, the <I>whole matrix</I>, row by row, will if necessary be padded or amputated as described below.

The RETURN of the function is an array of size 3, reflecting the final state of Subject: { No. of rows,  Row length,  Padder }.

Running through the modes:
<bullet><i>Operation 'A':</i>  Appends a row. <i>RowNo</i> need not be supplied; if it is it is completely ignored. If 'Subject' is a list array, its contents are lost and it is converted to a one-row matrix, <i>NewRow</i> being that row.
<bullet><i>Operation 'I':</i>  Inserts a row, pushing rows upwards to make way for it.  <i>RowNo</i> must be supplied, and must be the number of an existing row. If 'Subject' is a list array, its contents are lost and it is converted to a one-row matrix, <i>NewRow</i> being that row. (RowNo is ignored in this case, even though a value must be supplied.)
<bullet><i>Operation 'O':</i>  Overwrites a row completely (all of the original row is lost, no matter how short NewRow is). <i>RowNo</i> must be supplied, but <i>for this mode only</i> it may be beyond the end of the existing matrix. If so, the new last row will be row RowNo; if necessary, empty rows (i.e. consisting of the pad value only) are interposed between the end of the existing matrix and this new row.

If <i>NewRow</i> is scalar it will be treated as if it were an array of length 1, holding this value. (Typically you would use it to add / insert an empty row, in which case NewRow would be the scalar pad value.)

<I>Final matrix row length:</I> This is set by the Length argument, if it is present and rounds to 1 or greater; otherwise by default the new row length is whichever is greater: the length of existing matrix rows or the length of NewRow. Where a row (old or new) is shorter than the new row length, it is padded (see below). Where it is longer than the new row length, it is truncated.

<I>Padder:</I> If this value is not supplied, the padding value defaults to zero.

If Subject enters as a list array, it takes the 'chars' rating of <i>NewRow</i>. Otherwise it preserves its prior 'chars' rating.

Here is how this function can be used with a loop to build a jagged matrix:
	<# blue>array jaggy;<# magenta>  // 'jaggy' starts life as a list array.
	<# blue>for (i, 3)
	{  <# magenta>// Generate some new rows of unequal lengths:
		<# blue>rowLength = 3 + rand(5);
		newRow = fill(rowLength, 10, 1);  <# magenta>// a row made up of { 10, 11, 12, ... }  
		<# blue><b>stats = jagger(jaggy, 'A', newRow);</b>
		writeln(neat(jaggy), stats, 10);  <# magenta>// Show the matrix at the end of each loop, along with the function's output.
	<# blue>}<# black>


<B>split</B>(<# blue>array Original, array or scalar Delimiter [, array or scalar Padder [, bool AcceptEmptySubarrays [, FixedLength [, array / scalar Prefix [, array / scalar Suffix ] ] ] ] ] )<# black>) -- 
The original array is divided into 'subarrays', being extents between delimiters (and before the first delimiter, and after the last). A jagged matrix is built from these subarrays, rows being padded as necesssary by Padder.

Delimiter may be an array, in which case the whole of the array constitutes an instance in Origin of the delimiter.

Padder may also be an array. If so, the whole array will be appended to the new row until the required length has been reached (in which case the last instance of the padder array may be truncated). The default Padder is 32 (I chose the unicode of the SPACE character, as 'split' is commonly used with strings). Any values can be used, including NAN.

The structure of Original is ignored; its data is read as if it were a list array. The 'characters' rating of the returned array will be the same as that of Original.

If Prefix is present, it is added to the start of every subarray of Original. If Suffix is present, it is added to the end of every subarray. Any padding is only added after Prefix and Suffix have been incorporated into the matrix row. (Prefix and Suffix may include NAN, but Original and Delimiter should not include NAN.)

If AcceptEmptySubarrays is present and TRUE, empty subarrays (occurring where two delimiters are contiguous) are included; in which case they will be built from Prefix (if any) + Suffix (if any) + padding. If AcceptEmptySubarrays is absent or FALSE, such subarrays are simply ignored. (If all subarrays are empty, the 'empty' array [NaN] is returned. This also happens if AcceptEmptySubarrays is false but no fixed length has been specified, as row length then would default to 0.)

If FixedLength is present and rounds to at least 1, then rows will be forced to this exact length, either by padding or by truncation. Otherwise row length is set by the longest subarray (any prefix or suffix inclusive).


<B>join</B>(<# blue>matrix Matrix, array or scalar Delimiter, array or scalar Padder [,  array or scalar EmptyRowCue ] )<# black>) -- Paste the rows of Matrix together, delimited by 'Delimiter'. (The first and last elements of the returned array are never Delimiter.)
<bullet><i>Matrix:</i>  If is a list array, will be regarded internally as a 1xN matrix.
<bullet><i>Delimiter:</i>  If an array, the entire contents of the array becomes the delimiter.
<bullet><i>Padder:</i>  Never optional (as it is in the above functions). If an array, only its first element is used.
<bullet><i>EmptyRowCue:</i>  If this argument is omitted, rows consisting only of Padder will be ignored; if the whole of Matrix is the Padder, then the 'empty' array [ NaN ] will be returned. If this argument is present, rows consisting only of Padder will be replaced in the output by this argument (which may, if an array, have any length).


<B>unjag</B>(<# blue>Matrix, scalar RowNo [, scalar Filler]<# black>) -- Intended for matrices created with e.g. 'jagger(.)', but can be used with any matrix. Returns the row of Matrix indicated by RowNo, after trimming pad values from the end (though not from the start). If Filler is not supplied, it removes any final value from 32.0 down to 0 (no rounding). If Filler is supplied, only that exact value is removed. If trimming would logically return an empty array, an array of size 1, value NaN is returned, and a call to 'empty(.)' will return TRUE. Note that Filler must be a scalar (e.g. '32' or 'asc(" ")', for the space character).

You can safely use a list array in place of Matrix, in which case it will simply return the array trimmed at the end, as for rows of a jagged matrix. This concession is here to allow for functions (such as 'request(.)') which in different circumstances may return either a list array or a jagged matrix.


<B>jag</B>(<# blue>Matrix, array Operation, array NewRow [, scalar RowNo [, scalar Length [, scalar Padder ] ] ]<# black>) -- <# red>Deprecated!<# black> --Operates exactly as for the above function <b>jagger(.)</b>, with just these differences:
<bullet>'Matrix' is NOT altered; instead, an adjusted copy of it is returned.
<bullet>If 'Matrix' is not a matrix but a list array, its data is used, being taken as the first row of a new jagged matrix.

============================================================
//JOIN -- see JAGGER
============================================================
//KEY//
//KEYS//
//KEYED//
//KEYDOWN//
//KEYNAME//
<b>KEY HANDLING</b>

There are three functions which handle key information.
	<# blue>keyed(.)<# black> -- tells what keys and key combinations have recently been keyed.
	<# blue>keydown(.)<# black> -- tells what key(s) are currently being held down.
	<# blue>keyname(.)<# black> -- converts a key value to a key name.


<b>1.  WHAT KEYS AND KEY COMBINATIONS HAVE RECENTLY BEEN KEYED?</b>

<B>keyed</B>(<# blue>[ named array RefArray [,  scalar HistoryLength ] ]<# black>) -- RETURNS a boolean and MODIFIES RefArray (if supplied). The boolean return is 'true' if a key or keys have been keyed since the last call to this function (or since the beginning of the program, if no previous call). The call to <i>keyed(.)</i> resets an internal buffer, so that a subsequent call to the function (with no keyings in between) will return 'false'.

If you use the function without arguments (or with any scalar first argument), that is all that happens. If you proved a named array RefArray, you will get back information about key presses in that array. How that information is returned depends upon:
<bullet><i>HistoryLength.</i>  If this is ≤ 1, you will get back details of the last key combination pressed. (This might be a single key, or a combination like  control-alt-shift X.) Otherwise you get back information on as many past key presses as you specify, up to the capacity of the buffer to remember key presses. (Bear in mind that the relevant buffer can only hold up to 12 single key presses and fewer key combinations.)  If HistoryLength is absent or ≤ 1, the final form of RefArray is a list array. If HistoryLength is \>1, RefArray will be a jagged matrix; every row will end in 0 (whether chars. array or not), and shorter rows will be padded out with further zeroes. The most recent key press or combination will be in the lowest row. (If HistoryLength exceeds the number of keypresses stored, the excess upper rows will consist only of zeroes.)
<bullet><i>The characters rating of RefArray.</i>  If RefArray is a chars. array, the information will be returned in characters form (like "Alt Cntrl Shift V"); if not, in numerical form ( [86, 65505, 65507, 65511]  for the same key combination).

Key combinations are sorted, as the above examples show. If RefArray is not a characters array, they are sorted in ascending order, as shown above. If RefArray is a chars. array, they are sorted in descending order before being submitted to the internal routine which converts numerical codes into key names. (This may not be apparent, e.g. for "Cntrl Shift A", as 'A' is last; but the sorting is in terms of the key codes, and printing characters all have codes much lower than those of helper keys.) Also, Latin letter keys are converted to upper case (as with the 'V' above). (This is not the case with function 'keydown', described below.) For more information re key names, see function 'keydown' below (which uses the same internal routine).

<i>Example of use:</i>
<# magenta>// Polling loop. Enter a key or key combination; its description will go to the Results Window.
<# blue>while (true) 
{	if (keyed())  <# magenta>// true, if a new keypress since startup or since the last call to this function<# blue>
	{	lastkeying = " ";  <# magenta>// define as a characters array<# blue>
		keyed(lastkeying);  <# magenta>// puts the last key into 'lastkeying'<# blue>
		writeln( cull(lastkeying, 0));
	}
}<# black>


<b>2.  WHAT KEY IS CURRENTLY BEING PRESSED?</b>

The function <b>keydown</b>(<# blue>bool asCharArray<# black>)  returns this information. If 'AsCharArray' is TRUE, it returns a string like "Cntrl";  if FALSE, a number is returned.
Qualifications, illustrated by the case where AsCharArray is TRUE:
<bullet>All of the following is based on one particular computer - my laptop. Hence one should experiment with one's own computer. (Code for doing so is supplied at the end of this topic.)
<bullet>When no key is being held down this function returns "null" (or just 0, if the argument is FALSE).
<bullet>Printable character keys return their character as expected; e.g. 'a' for the A key if Caps Lock is OFF, 'A' if CapsLock is ON.
<bullet>Where several keys are held down at once, the return at any instant is the value of the latest key being pressed. For example, if you are keying the combination Cntrl - Shift - F1, and press them down in that order, then this function would return first "Cntrl", then "Shift", then "F1".
<bullet>Where the helper key is the shift key alone, the printable key that follows will be the shifted form. For example, normally if the A key is pressed, 'a' is returned; if Shift-A is keyed, you get first 'Shift', then the <i>capital</i> letter 'A'. (If the Caps Lock is down, then you get 'A' without Shift and 'a' with Shift.)


<b>3.  FINDING A KEY NAME, GIVEN THE KEY VALUE</b>

To translate one or more of the key values mentioned above to key names as mentioned above, use function <b>keyname</b>(<# blue>scalar / array KeyValues  [,  char. array Delimiter])<# black>).
If there is more than one key value, the key names will be separated by Delimiter. The default for absent (or scalar) delimiter is a single space.

This function is useful where you have used <# blue>keydown(false)<# black> for the purpose of processing key presses, but then want to display the keypress in human-readable form. 


<b>Returns for Particular Keys</b> 

The numbers in brackets are as returned for the case where 'asCharArray' is false. (Repeated warning: Experiment with your own computer before coding in these values.)
<stops 125>
<u>Helper Keys</u>
"Shift"	(left Shift key: 65505;  right Shift key: 65506)
"Cntrl"	(left key: 65507;  right key: 65508)
"Alt"	(keys differently arranged on different computers: 65511 to 65514)
"Windows"  (65515)
"AltGr"	(65027)

<u>Cursor Moving Keys</u>
"Home"	(65360;  on numbers pad: 65429)
"Left"	(65361;  on numbers pad: 65430)
"Up"	(65362;  on numbers pad: 65431)
"Right"	(65363;  on numbers pad: 65432)
"Down"	(65364;  on numbers pad: 65433)
"PageUp"	(65365;  on numbers pad: 65434)
"PageDown"	(65366;  on numbers pad: 65435)
"End"	(65367;  on numbers pad: 65436)

<u>Special Action Keys</u>
"Enter"	(65293)
"Backspace"	(65288)
"Tab"	(65289)
"ShiftTab"	(65056)  ("Cntrl" and "Alt" helpers do not alter the Tab key return value.)
"Escape"	(65307)
"Insert"	(65379,  65438)
"CapsLock"	(65509)
"Delete"	(65535,  65439)
"NumLock"	(65407)
Function keys: "F1" (65470)  to  "F12" (65481)

<u>Number Pad Keys</u>
If the Numbers Lock is ON, numbers 0 to 9 return "Pad 0" (65456) to "Pad 9" (65465).
If the lock is OFF, in computers where the OFF keys serve as cursor moving keys, values are as under 'Cursor Moving Keys' above; additionally, the centre key ('5' on the numbers pad) returns "Pad Centre"	(65437).

Whatever the state of the Numbers Lock, these keys associated with the number pad apply:
"Pad Enter"	(65421)
"Pad *"	(65450)
"Pad +"	(65451)
"Pad -"	(65453)
"Pad /"	(65455)


============================================================
//KILL -- see CLEAR
============================================================
//KILL_ON_EXIT//
//SMASH//
<b>CLOSING DOWN AN INSTANCE OF MONOMATHS PROGRAMMATICALLY</b>

The proper way to do this is by using the function:

<B>kill_on_exit</B>() -- After this void function has been processed, the next program exit will be followed immediately by the closure of the MiniMaths instance. That exit may be through the explicit instruction "exit;" or through the completion of all main program code.

This function has no effect if the program ends prematurely  through an error, or through use of the 'crash(.)' instruction. The instance of MiniMaths will persist.

The function was created for use where one instance of MiniMaths invokes a second instance using the 'exec(.)' instruction, so that the second instance can be made to close when its usefulness to the first instance has expired. (In this setting it is important for 'kill_on_exit()' to fail in the presence of unforeseen errors that crash the program.)


Sometimes the above doesn't work. The program ends, but the MonoMaths instance stubbornly persists. In that case you have to resort to:

<B>smash</B>(<# blue>[ array Message [, array FileName ] ]<# black>) -- Sudden death to the MonoMaths instance (by raising an unhandled exception). If there is a first array argument, it is regarded as text and is saved to disk. If there is a second array argument, it is taken as a file name, and an attempt is made to save the message there. If that fails, or if there is no second argument, the message is instead saved in "/tmp/smash.txt".
============================================================
//KILLGRAPHS//
//KILLPLOT//
//ISGRAPH//
//ISPLOT//
//PLOTSOF//
//REMOVEPLOT//
<U><# black> REMOVING PLOTS AND GRAPHS</U>

<B>Does the graph or plot exist?</B> Two functions are used: <B>isgraph</B>(<# blue>scalar GraphID<# black>) -- if the graph exists, evaluates to 2 (for 2D graphs) or 3 (for 3D graphs). Otherwise returns 0, so can be used like a boolean in conditional statements. And <B>isplot</B>(<# blue>scalar PlotID<# black>) -- which also evaluates to 2 (2D) or 3 (3D), or 0 if nonexistent.

A third function is useful to find what plots are present in a graph. <B>plotsof</B>(<# blue>GraphID<# black>)  returns an array. If the graph exists and has plots, the array length is the number of plots in the graph, and the array elements are the plot IDs. Failure produces an array of size 1, value NaN; a call to 'empty(.)' returns TRUE.
It is safe to use this function inside 'addplot(.)', 'killplot(.)' and 'removeplot(.)', even if 'plotsof(.)' returns the failure array just mentioned. For example, "addplot(Graph2, plotsof(Graph1));" can be used to copy all the graphs of Graph1 across to Graph2.

<B>Removing plots</B>. Two functions are used. The first - <# blue>removeplot(GraphID, plotIDs)<# black> - simply removes given plots from a particular graph, but leaves them elsewhere intact and reusable. The second - <# blue>killplot(plotIDs)<# black> - removes all trace of them in memory, including from any graphs currently displaying them. In both cases, the arguments 'PlotIDs' may be any mix of arrays and scalars.

<b>Killing graphs</b>: The function is <# blue>killgraphs( scalar / array GraphIDs, array DoWhatWithPlots )<# black>. A void function which kills the listed graphs. If 'GraphIDs' is exactly the array "all" (or at least begins with this), it will kill all graphs.

<i>DoWhatWithPlots:</i>  Only the first character is checked. These are the options:
<bullet>'!' = kill all plots, whether or not other graphs are using them. No trace of the plots is left in memory; however the display of existing graphs will not be altered. (In such displays, you are looking at a drawing made in the past from the plot, not at the plot itself. If the graph were redrawn or copied, killed plots would not be reproduced in the new instance.).
<bullet>'?' = query plots, to see if some other graph is using them. If so, let them live; otherwise eniolate them. (In the case where GraphID is "all", this has the same effect as '!', as you would logically expect.)
<bullet>'-' (or anything else, for  that matter) = don't kill any plots.

Some further points to note:
<bullet>If speed is the essence (as during an animation), be aware that '?' is much slower than either of the other two options.
<bullet>If you call <# blue>lastclosed()<# black> after killing graphs, it will always return 0. The purpose of 'lastclosed()' is to communicate to the program that the user has closed a graph, usually by clicking the corner icon, so that it can take appropriate action (e.g. close down the program); if the program itself has just closed certain graphs using 'killgraphs', it does not need help from a function like 'lastclosed' to tell it what it has just closed! Moreover, if you have just killed one set of graphs and plan to then draw another set, you would want 'lastclosed' to return 0 during the existence of the new set, till one of them is closed.

============================================================
//KURTOSIS -- see MOMENTS
============================================================
//LABEL//
<B>label</B>(<# blue>One or more variables or literals<# black>) -- Nonvoid. Read or alter the text of any of:
<bullet>Labels: the Assignments Window label ('A'), the Results Window label ('R') or the Comments label, bottom left of the display ('C');
<bullet>The main window title (until the next file I/O operation overwrites it): ('T').

The first value of the aggregated argument must be the unicode of one of these four letters, and defines which window component is to be accessed. The remaining text determines what happens next.

If there is no remaining text (e.g. <# blue>ss = label('C');<# black>), the current contents of the window component is returned. (In all other cases, including errors, a single space is returned.)

Otherwise the remaining text replaces current label contents, <i>with provisos</i> (which apply to labels, not to the main window title):
<bullet>If the remaining text is <i>exactly</i> the string "_DEFAULT_", the label will receive its default text (i.e. text as at startup);
<bullet>If the remaining text is exactly "_DEFAULT_" followed by any text (e.g. "yak"), the label receives the default text followed by 'yak'.

Note that when the program ends, the top two labels are always reset, though the Comments label retains its set data. When a new program starts, all three labels are reset to their defaults. File I/O operations always overwrite any setting of the main window title.
============================================================
//LABELX//
//LABELY//
//LABELZ//
//HEADER//
//FOOTER//
<U>GRAPH HEADING, GRAPH DESCRIPTION, AXIS DESCRIPTIONS</U>

For all of the following text functions, the first argument must be the graph ID. The subsequent argument(s) specifying the text  are handled exactly as for functions 'writeln(.)' and 'show(.)'.
All of the functions work for both 2D and 3D graphs, though for 3D graphs axis descriptions are printed to the right of the graph proper, not along the actual axes.

You can apply <B>heading text</B> to the top of the graph using nonvoid function <B>header(GraphID [, array(s) / scalar(s) Text] )</B> . The composition of 'Text' is exactly as for the argument(s) of functions 'write(.)' and 'show(.)', with the proviso that different rules apply for formatting tags, as the underlying Gdk uses Pango tags only.  You can use the following: \<b> ... \</b>, \<u> ... \</u>, \<i> ... \</i>, \<^> ... \</^> (for superscript), \<v> ... \</v> (subscript).  (Exact pairing is essential, as these are translated into Pango tags - which you would have to google, for details. You can actually use any other Pango tags, but I do not list them here.) 
If GraphID is not identifiable, this function returns the 'empty array' (size 1, value NaN; testable with function 'empty(.)' ). Otherwise, it ALWAYS returns the current heading. If the only argument is the graph ID, the last set heading for this graph is returned, and nothing is changed. Otherwise what is returned is exactly what you have just put in (probably not very useful).

You can put <B>explanatory text under the graph</B> using nonvoid function <B>footer(.)</B>.
There are two forms:
<i>footer(GraphID, <some text>)</i> -- where 'some text' is any mix of arrays and scalars, and is treated exactly as is the argument of 'write(.)' or 'show(.)'. All of the MonoMaths tags are allowed here; to see the options, type 'format' into the Assignments Window and key F1. (If 'some text' consists of a single scalar argument, it is treated as the second form instead.)
Normally no cursor is visible in the footer, though it is editable, so that if you type, characters will appear there. If the values "<some text>" begin with exactly the three unicodes of "|+|", then the cursor will be made visible. It will remain visible with further calls to 'footer(.)' for this graph, until a call for which "\<some text\>" begins with "|-|", switching cursor visibility off. (In both cases, these three initial characters will not be displayed.)

<i>footer(GraphID [, bool FinalVersion])</i> -- returns the existing footer for the graph. If FinalVersion is absent or 'false', the value is the last that was set for this graph using this function 'footer'. It will be complete with any formatting tags. If FinalVersion is 'true', (a) what you get back is whatever is <i>now</i> displayed on the graph; the user may have altered this by typing directly into the graph (as the footer is editable, even though no cursor is visible); and (b) whether altered or not, what you get back is <i>bare text</i>, devoid of all (valid) inserted formatting tags.
If GraphID is not identifiable, this function returns the 'empty array' (size 1, value NaN; testable with function 'empty(.)' ). Otherwise, it ALWAYS returns a chars. array. For the first form, this is simply what you have just put in (probably not very useful).

You can add <b>explanatory text beside the axis scale markings</b> - e.g. "kilometres per hour" below an X-axis scale in such units.
<i>labelx(GraphID [, \<some text\>],   labely(...),   labelz(...)</i> -- where 'some text' is any mix or arrays and scalars, as for 'footer' above. No formatting tags are valid for these texts.
Normally the function is void; but if you supply only the one argument - the graph ID - then the function returns whatever is the current axis label text.
==================================================================
//LADDER//
<B>ladder</B>(<# blue> Variable, Scalar FirstValue, Scalar LastValue [, scalar ConformInterval ]<# black> ) -- provides an array whose entries are an arithmetic progression from FirstValue to LastValue. It comes <B>in three forms</B>, none being void.  FirstValue may be equal to or less than LastValue.

<u>Form 1</u>
Format:  <# blue>NewArray = ladder(ArraySize, FirstValue, LastValue)<# black> -- returns an array of the stated size. E.g.
	<# blue>arr = ladder(5, 10, 11);  <# magenta>//  this returns the array { 10,  10.25,  10.5,  10.75, 11 }<# black>
	
<u>Form 2</u>
Format:  <# blue>Interval = ladder(NamedArray, FirstValue, LastValue)<# black> -- this time 'NamedArray' is exactly that, and has been predefined. Its prior values will be lost, though not its structure. Its new values will be equally spaced between FirstValue and LastValue.
	<# blue>dim(arr, 5);
	<# blue>intvl = ladder(arr, 10, 11);  <# magenta>//  'arr' will now be { 10,  10.25,  10.5,  10.75, 11 }; and 'intvl' will be set to 0.25.<# black>

Note that the above two forms have exactly three arguments. The final form has exactly four arguments, all being scalar.

<u>Form 3</u>
Format:  <# blue>NewArray = ladder(Interval, FirstValue, LastValue, bool ConformInterval)<# black> -- This builds an array starting from FirstValue and adding Interval to successive values. There are two versions:
<bullet>ConformInterval is TRUE:  In this case the interval is, if necessary, adjusted so as to be an exact multiple of (LastValue - FirstValue). In this case, LastValue is guaranteed to be included.
	<# blue>Arr = ladder(3, 10, 20, true);  <# magenta>// No. segments = (20 - 10) / 3 ≈ 3.33. This is rounded to 3, giving a new interval 3.33...
		<# magenta>// The returned array becomes  { 10,  13.33...,  16.66...,  20 }.<# black>
<bullet>ConformInterval is FALSE: The interval stays as is, and values are added successively to the array up to the last value which <i>does not exceed</i> LastValue. (In the case of decreasing values, to the last value which is not below LastValue.)
	<# blue>Arr = ladder(3, 10, 20, false);  <# magenta>// This returns  { 10,  13,  16,  19  }<# black>
With this second version, even if theoretically the interval is an exact divisor of (HighValue - LowValue), there is a risk that systematic numerical error will occasionally cause HighValue to be excluded. If this is a critical problem for your application, make HighValue a tad higher - e.g. 20.0001 instead of 20.


<B>Warning!</B> This function is particularly vulnerable to numerical errors, so do not use exact equality tests. E.g. if we define "xx = ladder(101, -2, 2)", xx[70] should be 0.8; but the test "if (xx[i] == 0.8)..." will register 'false' for i = 70, because of a numerical error residue: xx[70] is computed as (0.8 + 2.2...E-16).
==================================================================
//LADDERCLR//
<b>DEVELOPPING A RANGE OF SHADES GRADING BETWEEN TWO GIVEN COLOURS</b>

The function for this is:
	<B>ladderclr</B>(<# blue>Scalar NoColours, Array/Scalar FirstColour, Array/Scalar LastColour [, array HoldWhatConstant [, bool ColoursAreHSL [, scalar DistortionFactor ] ] ]<# black>).
It is analogous to function 'ladder(.)'; it returns a range of 'NoColours' colours which grade from FirstColour to LastColour. The form of the return is a matrix (NoColours x 3), the rows being R, G, B values respectively. The two input colours may be a literal name ("sky blue"), or an array of size 3 (R, G, B values between 0 and 255), or a hex value (e.g. "0xff8800"), or the integer version of this hex number.

<i>HoldWhatConstant:</i>  Even when you supply RGB arguments, the grading of colours is done internally using their HSL forms. In some cases (see below) you may want to force one or two of the H, S and L components to stay the same as for the FirstColour; in that case, make this argument consist of one or two of the letters H,S,L (or h,s,l). (Any third or later value in the array is ignored, as is any other letter than these three.)

<i>ColoursAreHSL:</i>  The arguments are normally taken as being RGB colours in one of the abovementioned forms; but if this argument is present and TRUE, and the colours are arrays of size 3, then they will be accepted as HSL values instead.

<i>DistortionFactor:</i>  A tweaking factor; it affects how quickly colours change between the two extreme colours. The default is 1. Lower positive values (e.g. 0.5) cause more rapid change over the first few colours, and little difference in the last few colours; Higher positive values (e.g. 2) have the opposite effect. (Values of 0 or below are ignored, and the default is used.)

Where impossible colour arguments are supplied, (a) in the case of RGB arguments, names etc., the default colour black is used; (b) in the case of HSL arguments - for which all values must lie in the range 0 to 1 - overlimit values are taken back to the nearest of 0 or 1.

The only crashing errors:  (1) NoColours rounds to less than 2;   (2) an HSL argument is not of length 3.

<u>EXAMPLES</u>

<i>Ex. 1:  Supply a set of 15 colours, grading from 'red' to 'blue'. The set will be graphed as large dots across a graph surface.</i>
<# blue>RGB1 = 'red';
RGB2 = 'blue';
NoColours = 15;
ClrRange = ladderclr(NoColours, RGB1, RGB2);
<# magenta>// Show the colours as a series of coloured dots stretching across the graph surface:
<# blue>xx = fill(NoColours, 1, 1);
yy = fill(NoColours, 1);
p = plot(yy, xx, '.', 30, ClrRange, ' ',0,0,  xx-1);
grid(0, NoColours+1, 1,   0, 2, 1);
g = graph(p);

<# black><i>Ex. 2:  Supply a set of 15 colours, grading from 'red' to 'white'.</i>
In this case you should use the 4th. argument as 'H' (or 'h'), so that the hue remains the same. Similarly when grading from some colour to 'black'. This is necessary because both white and black have ambiguous forms in the HSL representation.
<# blue>RGB1 = 'red';
RGB2 = 'white';
NoColours = 15;
ClrRange = ladderclr(NoColours, RGB1, RGB2, 'h'); <# magenta>// If you omit the last argument you will get a rainbow of colours.
<# magenta>// Show the colours as a series of coloured dots stretching across the graph surface:
<# blue>xx = fill(NoColours, 1, 1);
yy = fill(NoColours, 1);
p = plot(yy, xx, '.', 30, ClrRange, ' ',0,0,  xx-1);
grid(0, NoColours+1, 1,   0, 2, 1);
g = graph(p);








==================================================================
//LAST//
<B>last</B>(<# blue>Array [, scalar Which] <# black>) -- returns one of the last values in the array, whatever its structure. If Which is absent or 0, returns the last value; if either +1 or -1, the last-but-one value; and so on for higher absolute values of Which. If  | Which |  >= array length, raises an error.

Don't confuse it with the <I>index</I> of the last entry, which is size(arr)-1. I think some computer languages do use the keyword 'last' in that sense.
==================================================================
//LASTCLOSED  -- see ANIMATE
==================================================================
//LETTERCASE//
<b>CHANGING LETTER CASE IN A STRING</b>

The function is <b>lettercase</b>(<# blue>array TheString,  array Model<# black>). It returns a copy of TheString with letter case changed in accordance with the model.

Model:  Only specific values are valid. Any other value does not return an error but also does nothing - the returned string is exactly the same as TheString. For each of the values below, the part that follows is how the given example string would end up.

Effects of different Model values on TheString:  "tHe cAt sAt on the mAt? dRat thAt cAt! tHrow iT oUt."

     <u>MODEL</u>			     <u>OUTPUT</u>
	"A"			"THE CAT SAT ON THE MAT? DRAT THAT CAT! THROW IT OUT."
	"a"			"the cat sat on the mat? drat that cat! throw it out."
	"Aa"			"The cat sat on the mat? drat that cat! throw it out."   (Only the very first letter capitalized.)
	"Aa_Aa"		"The Cat Sat On The Mat? Drat That Cat! Throw It Out."
	"Aa.Aa"		"The cat sat on the mat? Drat that cat! Throw it out." (Punctuations '!', '?' and '.' invoke a following capital.)
	"oops!"		"tHe cAt sAt on the mAt? dRat thAt cAt! tHrow iT oUt."  ( = same as original string.)
==================================================================
//LIST//
//LIST_NEW//
//LISTS_NEW//
//LIST_ADD//
//LIST_ALTER//
//LIST_OPN//
//LIST_READ//
//LIST_READ_TO//
//LISTS_READ//
//LISTS_READ_TO//
//LISTS_COUNT//
//LIST_SIZE//
//LIST_IN//
//LIST_CLEAR//
//LIST_CLEAR_TO//
//LISTS_CLEAR//
//LIST_DELETE//
//LIST_DELETE_TO//
//LIST_FIND//
//LIST_CULL//
//LIST_CULL_RANGE//
//LISTS_KILL//
//LISTS_PRESERVE//
//LIST_PUSH//
//LIST_POP//
//LISTS//
//LISTS_TO//
<B>FUNCTIONS WHICH SERVICE LISTS</B>

<U>General notes:</U> 
<bullet>Lists are global objects; if you create one in a function, it will survive outside the function, so make sure it is killed before return ("lists_kill()").
<bullet>When you 'kill' a list, you are also killing all lists above that list. If you want to do away with a particular list while others created later are still in use, use "list_clear()" to empty it (thus freeing up memory), but leave the poor thing still alive.

<B>list_new()</B> -- no argument. Creates a new list, and returns the new total number of lists (NOT the index of the new list, which is one less than this number). (<I>Hint:</I> rather than keep track of lists by number, try this trick: <# blue>foolist = list_new() - 1; <# black> you can then later use 'foolist' as the index of the list intended for storing foos.)

<B>lists_new(scalar HowMany)</B> -- Creates the stated number of new lists, and returns the new total number of lists.

<B>list_add(list index, one or more scalars or arrays)</B> -- appends all supplied data to the end of the given list. Crashes if the list was not created (using 'list(s)_new(.)' ). Returns the new length of the list.

<B>list_read(list index)</B> -- returns the whole list as an array. NB - crashes if the list is empty, even if the list has been created by 'list_new()'.
<B>list_read(list index, position)</B> -- returns a <I>scalar</I>. NB - crashes if 'position' is beyond the end of the list.
<B>list_read(list index, position, extent)</B> -- returns an extent of a list as an array. NB - crashes if any part of the extent is beyond the end of the list.
<B>list_read_to(list index, first position, last position)</B> -- returns an extent of a list as an array, between and including the two positions. NB - crashes if any part of the extent is beyond the end of the list.
<B>lists_read(padding value,  first list,  no. of lists [, fixed length] )</B> -- retrieves a set of contiguous lists and returns them as a <B>matrix</B>, with one row per list. The length of the list is normally set by the longest list; the end of shorter lists are then padded to full length by appending as many 'padding value' bytes as needed. If the fourth argument is supplied, this overrides this system; list copies will then either be amputated or padded, in order to achieve 'fixed length'. The padding value may be a scalar or an array variable. If an array, only the first element is used; the rest of the array is ignored. The function crashes if any of the lists in the range do not exist.
<B>lists_read_to(padding value,  first list,  last list [, fixed length] )</B> -- behaves exactly as above, except for the different way of fixing the range of lists to be copied.

<B>lists_count()</B> -- returns the number of created lists (0, if none).

<B>list_size(list index)</B> -- returns the size of the given list (0 if empty; -1, if the list does not exist).

<B>list_alter(list index, position, data)</B> -- 'data' is a single variable, array or scalar. List data is overwritten with the contents of the variable, starting at 'position', and extending for the length of the variable. NB - crashes if any part of the extent is beyond the end of the list. Void function.

<B>list_insert(list index, position, one or more variables)</B> -- the content of all of the 'variables' is inserted into the list at 'position' (which must be a valid position in the list). Returns the new size of the list.

<B>list_delete(list index, position [, extent])</B> -- delete list items. If 'extent' missing, deletes all to end of list. If supplied, must not exceed end of list. Returns the new size of the list.
<B>list_delete_to(list index, first position, last position)</B> -- delete list items over the given range (which must exist). Returns the new size of the list.

<B>list_opn(ListIndex, Position, array Operation, scalar Value [, scalar DontChangeList ])</B> -- carries out the operation "List[position] . Operation .  Value", and returns the result. If there is no fifth argument, or if it is present and nonzero, then this value also replaces the old value in the list. Only  Operation[0] is examined; it must be one of these: " + - * / ^ A B S " (small letters allowed). 'A' = absolute value; 'B; = boolean evaluation (replace nonzero values by 1); 'S' = sign (replace with +1, -1, or, if list value is 0, replace with Value). For the unary operations 'A' and 'B' Value is irrelevant, but it cannot be omitted. As usual, it crashes if the list or its index do not exist. It also crashes for division by 0 or by power opns. that would return a complex number.

<B>list_find(list index, scalars value1[, value2])</B> -- finds the first instance of value1 (two argument form) or of any value between value1 and value2 inclusive (three argument version). The order of value1 and value2 is irrelevant. Returns -1 if no find.
<b>list_find(list index, array Sequence)</b> -- finds the first instance of the array Sequence within the list; returns -1 if no find.

<B>list_cull(list Index, any number of scalars or arrays)</B> -- removes all values represented from the list (which may end up empty as a result). Returns final size of list.
<B>list_cull_range(list Index, value1, value2)</B> -- removes all values within the range (inclusive). The order of value1 and value2 is irrelevant. Returns final list size.

<B>list_clear(list no.)</B> -- empties the given list, <I>but</I> does not destroy it. (You can put new data into it in the usual way, with 'list_add(.)'. ) NB - crashes if the list has not yet been created. Void function.
<B>lists_clear(first list, extent)</B> -- empties all lists in the stated range. NB - crashes if any list in the extent has not yet been created. Void function.
<B>lists_clear_to(first list, last list)</B> -- empties all lists in the stated range. NB - crashes if any list in the extent has not yet been created. Void function.

<B>lists_kill(from list no.)</B> -- destroys <I>all</I> lists from the given list upward. (It is not possible to have destroyed lists with existing lists beyond them.) It is safe to use this function even if there are no lists in existence. If you use it without an argument it will destroy all lists (since an empty argument translates internally as the argument 0). Negative 'from' list destroys all (as if it were 0); and if the 'from' list does not exist (too high), nothing happens.  Void function.

<B>lists_preserve()</B> -- If program focus comes across this function call anywhere throughout the program, an internal flag is set which ensures that the lists remain intact and accessible during the next program run, even if it is a different program. (Unless that next program also calls the function, the lists will not persist beyond its run.) Void function.

<B>list_push(list index, data)</B> -- pushes the contents of a single variable (scalar or array) onto the end of the given list, as if it were a stack. Returns the new size of the list. With arrays, the data in the list is in the same order as in the array. NB - crashes if the list does not exist.

<B>list_pop(list index, variable)</B> -- inserts the appropriate length of data into the variable (which must be a previously declared variable, not an expression). If an array, it will contain data in the same order as in the list. The list is shortened by the removal of this data, as with a stack. The function returns the new size of the list.
\tIf the size of the list would not permit complete filling of the variable, nothing happens to either the list or the variable (it retains its preexisting data), but the function returns a negative number, which is the shortfall of space as a negative number. (In the case of trying to pop a scalar from an empty list, it would therefore return -1.) The function only crashes if either the list or the variable does not exist. 

<B>Duplications:</B> If you are not confused by all this, you can omit "_read" from all four functions using it. That is, the following pairs of names invoke the same function internally: <B>list(..)</B> and <B>list_read(..)</B>;  <B>list_to(..)</B> and <B>list_read_to(..)</B>;  <B>lists(..)</B> and <B>lists_read(..)</B>;  and <B>lists_to(..)</B> and <B>lists_read_to(..)</B>.

<B>Displaying lists after the run:</B> Use the menu item "Other | Display Values of System Lists". (You can display them during a run using 'writeln(list(2))' or 'show(list(2))'. )

==================================================================
//LN -- see LOG
==================================================================
//LOAD//
<B>LOADING DATA AND TEXT</B>

There is a single function, <B>load(..)</B>, which handles this task. It has five different working modes, distinguished by the first argument.

In addition there are two functions which are used to detect errors - <B>iok()</B> and <B>iomessage()</B> - and finally there is a function <b>iofile()</b> which can be used to retrieve the full path and name of the loaded file. These three are set at the time of disk operations and will continue to return the same values until the next disk operation occurs. (iomessage() is also used in a non-error situation - see below, under "load('A', ...)".)

<u>FUNCTION 'LOAD' OVERVIEW</u>
The first argument would usually be a chars. array, of which only the first character - NOT case-sensitive - is tested; but a scalar value (the unicode of same) is permitted. Here are the different modes, depending on that character:

<b>load</b>(<# blue><b>'B'</b>, array FileName<# black>) -- will read any file, simply returning its contents in a list array, one file <b>B</b>yte per array element..

<b>load</b>(<# blue><b>'T'</b>, array FileName<# black>) -- will read any file, but will expect it to consist of unicodes (hence 'T' for <b>T</b>ext); it will return the data as a chars.-type list array. (There is some built-in protection against impossible codes, but it would be possible to crash this function by sending it certain values that cannot be decoded into UTF8 characters; so use the function sensibly.)

<b>load</b>(<# blue><b>'A'</b>, array FileName [,  bool ExpectPrefix ] <# black>) -- Used where an <b>A</b>rray has been encoded using Mono's underlying encodement scheme for 'double' values; this code uses 8 bytes per value, that is, per element of the array. This file would usually have gotten onto your disk by your earlier use of <i>save('A', ...)</i>. If 'ExpectPrefix' is present and true, the function will expect to find a prefix listing the array's name, dimensions and chars. rating, together with a time stamp (no. seconds since start of 1AD) preceding the data. This prefix will have been put there by your setting an equivalent boolean when you saved the file using 'save('A', ...)'. You have access to it via function 'iomessage()', as explained below (in section "Successful Outcomes...").

<b>load</b>(<# blue><b>'F'</b>, array FileName,  array VarNameInFile<# black>) -- Returns data that was saved in a specially formatted but human-readable form by function 'save('F', ...)'. Such a file may contain more than one variable; but <i>load('F', ...)</i> will only return data for the variable in the file which corresponds to argument VarNameInFile. To get there, this file would have been saved using <i>save('F', ...)</i>. This file format is verbose, and so not practical for large arrays; but it has the advantage that it alone allows for scalars to be saved. (This is the one situation in which function 'load' will return a scalar.) (For the curious, the formatting system is detailed at the end of the Help section 'Data I/O and Display'; but such knowledge is not required to use 'load('F', ...)' and 'save('F', ...).)

<b>load</b>(<# blue><b>'D'</b>, array FilePath<# black>) -- Use this where you want to browse for the name of a directory, starting from the given one, but don't want to actually load a file. (<i>FilePath</i> may also be a full file name, or one of some abbreviations - see below under 'FileName'.)


<u>MORE ON ARGUMENT 'FILENAME'</u>
If no file path precedes the name, the current data path will be used. Shortcut "~/" is allowed for the user's personal home directory. If 'FileName' is empty (spaces only) or begins with '?', a dialog box will open for user choice of file. Also if 'FileName' is a directory (and so ends in '/'), a dialog box will open at that directory.

 Leading and trailing spaces are trimmed from 'FileName', together with unicode 0, so that a row from a jagged array (as, for example, is produced by function 'split(.)') can be used as is.

<u>TESTING FOR SUCCESS</u>
The function pair <b>iok()</b> and <b>iomessage()</b> - both with no arguments - are vital in assessing the outcome of the function call; the further function <b>iofile()</b> is also useful, where for example you have used a dialog box to find the file during the loading process; it returns the full path and name of the file, if the operation was successful (except for mode 'D', as in this mode no file is loaded). (<i>iofile('P')</i> returns just the path, and <i>iofile('N')</i> just the name.)

 There are 3 situations:
<bullet><i>Success:</i> the file and variable were found (or the directory name, for mode 'D'). In this case, <b>iok()</b> returns TRUE and <b>iomessage()</b> returns a single space (unicode 32).
<bullet><i>Error occurred:</i> the directory, the file or the variable within the file were not available. <b>iok()</b> returns FALSE, and <b>iomessage()</b> tells why. The Function <i>load(.)</i> returns the 'empty' array (size 1, value NaN); but it makes much more sense to test <i>iok()</i> than to test the returned value from <i>load(.)</i>.
<bullet><i>User cancellation:</i> Occurs where the user cancelled out of a dialog box. <b>iok()</b> is FALSE, BUT the iomessage() output consists only of a single space. (In all error cases, the message begins with other than a space.)

Note that the function <i>load(.)</i> <b>only crashes if the arguments are illegitimate in form</b> - e.g. a scalar where an array is expected, or an improper first argument (like 'X'). Where the function fails for functional reasons - e.g. a file or path does not exist, or access is blocked - you find out by calling the two functions <i>iok()</i> and <i>iomessage()</i>, which retain their values. The 'load(.)' function itself returns the empty array (length 1, value NaN); but instead of testing for this, you should always use the functions just mentioned.

<u>SUCCESSFUL OUTCOMES FOR THE DIFFERENT MODES OF 'LOAD'</u>
Where the operation has been successful,

<i>load('A', ...)</i> returns the content of the file. If ExpectPrefix is present and 'true', the resulting array will have the structure and characters rating of the array that was originally saved to disk. Otherwise it will simply be a list array. If ExpectedPrefix is true, a call <# blue>msg = iomessage();<# black> will return something that looks like this: "Foo::63441222019". Note the two colons separating the original variable name from the time stamp (no. seconds since the beginning of 1 AD). If, when this file was saved, no optional chars. argument 'Description' was supplied, then 'Foo' will be the name of the array in the original program. Otherwise 'Foo' will be exactly what was supplied as 'Description'. Where there is neither an array name (a temporary array was saved) nor a Description, the return will instead look like this: "::63441222019".
Note that iomessage() can be used with an argument after a "load('A', ...)" call: "iomessage('name')" just returns the name or description (or a space, if neither); "iomessage('time')" just returns the time.

<i>load('B', ...)</i> and <i>load('T', ...)</i> return arrays, the first as a set of binary values (all elements lying between 0 and 255) and the second as a chars. array.

<i>load('F', ...)</i> returns either a scalar or an array - whichever of these was saved in the file. (If in doubt, test the value with "if (isarray(...)) ..."; but generally if you know the name of the variable in the file, you know what sort it is.) If an array, it is structured as dictated in the file, though it will always return as a non-chars. array. (You shouldn't be saving text in this format.) Note that you must get VarNameInFile exactly right; if not so, the outcome will not be successful. As mentioned above, the one file may contain many variables, and this function will search through the file till it finds this variable. (Any subsequent duplication will never be reached.) The variable name, by the way, can  be a sentence with spaces and most punctuation marks; see under 'save('F', ...)' for more details.

<i>load('D', ...)</i> returns the full path of the last directory which was open in the file dialog. (<i>iofile()</i> is not set, because no file is loaded.)


<u>SOME SPECIAL ERROR SITUATIONS</u>
<bullet>Mode 'A', with 'ExpectPrefix' true: The data and file are found, but either no prefix identifiable, or else it is found to be corrupted: <b>iok()</b> returns 'false', and <b>iomessage()</b> provides the details; BUT all the data of the file is still returned by the function (rather than just the empty array, as with other errors).
<bullet>Mode 'A', with 'ExpectPrefix' false, but in fact the file does have a prefix: What happens is a matter of luck. If the file size - with its prefix included - is exactly divisible by 8, then no error will be detected (how could it be?). In other cases the function will fail, your iomessage() informing you that the file data must be corrupted as its size is not divisible by 8. 

How can you know whether a file holds a prefix or not? There is a way of finding out. Call 'load('A', ...) with ExpectPrefix set to 'true'. If a prefix can be identified, you have success (iok() returns true). If no prefix can be identified, iok() will be false, BUT the message in iomessage() will begin with a hyphen - the only situation in which this is ever allowed to occur. (An identified but corrupted prefix will simply return a conventional error message.) So a test might go like this:
	<# blue>myStuff = load(myFileName, true);   
	noPrefix = (!iok()  &&  (iomessage())[0] == asc('-') );".
<# black>Rather complicated, but should rarely be needed, as you really ought to know whether or not you saved your data with a prefix.


<u>OTHER USEFUL FILE FUNCTIONS</u>
(Details of use not given here).
<b>choosefilename</b> -- similar to <i>load('D') ...)</i>, but allows for choice of multiple files from the one directory. Returns just the file name(s).
<b>currentdirectory</b> -- gets or sets the current directory (i.e. the directory at which file dialogs will open by default). 
<b>homedirectory</b> -- Returns the current user's personalized home directory, e.g. "/home/fred/".
<b>checkdirectory</b> -- returns 'true' if this directory exists AND is also accessible. 
<b>filesize</b> -- Returns the file size, or -1 if the file does not exist (and so is useful as a test for the existence of a file).
==================================================================
//LN//
//LOG//
<B>LOGARITHMS</B>

<B>ln</B>(<# blue>Variable<# black>) -- the logarithm of n to base e = 2.71828...

<B>log</B>(<# blue>Variable [, Variable]<# black>) -- 'log(n)' gives the logarithm of n to base 10; 'log(n,p)' gives the logarithm of n to base p (p must be > 0). In both cases, n must be greater than 0.

There are no dedicated 'antilog' functions; simply use e.g. "10^x" to get the antilog of x.

See also: <B>logfact(.)</B> (returns the logarithm to base 10 of a factorial) and <B>logbinom(.)</B> (returns the logarithm to base 10 of one or more binomial coefficients).
==================================================================
//LOOKUP//
<B>ACCESSING A MAIN PROGRAM VARIABLE VIA ITS QUOTED NAME</B>

Suppose you are writing a function which allows the user to read the value of any nominated main program variable. The user might, for example, provide the name via a dialog box. The function to use is...

<B>lookup(VarName (spelled out in a chars. array) [, ResponseIfNotFound, ResponsIfNotAssigned ] )</B> -- Suppose there is a <I>main program</I> variable "Var1" (of any type). If it has already been assigned a value, you can read that value from anywhere else in the program, whether in the main program or inside a user function, and assign it to another variable using <# blue>xx = lookup('Var1');"<# black>. Note that "lookup(Var1)" won't work; the argument must be the name of the variable spelled out between quote marks. (You cannot use this function - or any other, for that matter - to find the value of a variable in a user function.)

The returned value (in the case of success) is of exactly the same structure as the variable referenced, be it scalar or array.

<I>Error responses</I> depend on how many arguments you supply. (You should supply either one or three; if you supply two, the second will be ignored.)
<bullet>One argument - the program crashes, with the appropriate error message.
<bullet>Three arguments - No crash; instead the function returns either the second argument (if the name can't be identified) or the third argument (if it can be identified but has not yet been assigned a value). Note that the 2nd. and 3rd. arguments can be either scalars or arrays, independently of the type of the named variable.

Example of use (three argument version):

\t<# blue>x = 10;
\t<# blue>Foo();
\t<# blue>z = 20;  <# magenta>// Note that 'z' is not assigned a value till after Foo is called.

\t<# blue>function Foo()  <# magenta>
\t<# blue>{
\t<# blue>\tc1 = lookup("x", "Can't find it", "It's unassigned");  <# magenta>// Success; c1 becomes scalar value 10.
\t<# blue>\tc2 = lookup("z", "Can't find it", "It's unassigned");  <# magenta>// program does not crash, but c2 becomes "It's unassigned"
\t<# blue>\tc3 = lookup("boo", "Can't find it", "It's unassigned");  <# magenta>// program does not crash, but c3 becomes "Can't find it!"
\t<# blue>\twriteln(c1, ".  ", c2, ".  ", c3);
\t<# blue>}
==================================================================
//LOGBINOM -- see FACT
//LOGFACT -- see FACT
//LOP -- see PAD
==================================================================
//MAINMENU//
<b>TURNING MAIN MENU VISIBILITIES OFF / ON</b>

The function for this is <b>mainmenu(.)</b>.

<b>(A)  To change visibility</b>
Use the two argument form
	<# blue>mainmenu( MenuTitles,  bool MakeVisible);<# black>
<i>MenuTitles</i> must be exactly one or more menu titles (case-sensitive), no spaces. If more than one title, the titles must be separated by the character '|' (again without spaces). SPECIAL CASE: If <i>MenuTitles</i> is exactly the word "ALL", then all menus will be made visible or invisible together.

The function is not void; it trivially returns +1 if MakeVisible is TRUE, 0 if FALSE; but more importantly, it returns -1 if ANY of the titles could not be identified. (All of those that could be identified will still be altered.)

Menus return to full visibility as soon as the program stops running.


<b>(B)  To find out visiblity, without changing it</b>
Use the one argument form
	<# blue>vis_state = mainmenu( MenuTitle);<# black>
This time, MenuTitle may only be a single menu title. (There is no 'ALL' option as for the above.)
As for the above, the return is +1 if the menu is visible, 0 if not, and -1 if the menu title could not be identified.

==================================================================
//MATCH//
//MATCHES//
//MISMATCHES//
<U>FUNCTIONS ASSIGNING BOOLEAN SCORES TO MATCHING ELEMENTS</U>

<B>matches</B>(<# blue>Variable1,  Variable2,  [, scalar Tolerance ] <# black>) -- The two variables must conform to one of the following:
<bullet>They are both scalar. (Allowed, but not of much value.)
<bullet>They are arrays of exactly the same length (but not necessarily of the same structure).
<bullet>The first is an array, the second is scalar. (Every value in the array will be tested against this scalar value.)

The returned structure will always have exactly the same structure as Variable1.

<I>Two arguments:</I>  Wherever a pair of corresponding elements of Variable1 and Variable2 are exactly equal, the corresponding returned object's element will be 1; otherwise the returned element is 0.

<I>Three arguments:</I>  As above, except that if 'Tolerance' is nonnegative, any difference between paired elements which has absolute value <= Tolerance will be scored as if there were no difference. (Tolerance < 0: argument ignored.)


<B>mismatches</B>(<# blue>Variable1,  Variable2,  [, scalar Tolerance ]<# black>) -- The two variables must conform to one of the following:
<bullet>They are both scalar. (Allowed, but not of much value.)
<bullet>They are arrays of exactly the same length (but not necessarily of the same structure).
<bullet>The first is an array, the second is scalar. (Every value in the array will be tested against this scalar value.)

The returned structure will always have exactly the same structure as Variable1.

<I>Two arguments:</I>  Wherever a pair of corresponding elements of Variable1 and Variable2 are NOT exactly equal, the corresponding returned object's element will be 1; if they are exactly equal, the returned element is 0.

<I>Three arguments:</I>  As above, except that if 'Tolerance' is nonnegative, any difference between paired elements which has absolute value <= Tolerance will be scored as if there were no difference. (Tolerance < 0: argument ignored.)

Sometimes it is useful to know if <I>any</I> corresponding values of two arrays do or do not match. To check that two structures are exactly equal, simply use the conditional test: "theyreEqual = (Variable1 == Variable2);". To check if two structures have no corresponding elements at all, use maxabs(Variable1 - Variable2).

See also <B>is(.)</B> and <B>not(.)</B>.
==================================================================
//MATRIX -- see DATA
==================================================================
//MATRIXOP//
The function <b>matrixop(.)</b> is intended to help with two tasks:
<bullet>A standard arithmetic operation between a matrix and a vector - e.g. to add the contents of a row vector to every row of some matrix;
<bullet>A nonstandard operation, either between a matrix and a vector, or between two matrices of equal total size.

The format is:
	<B>matrixop</B>(<# blue>matrix <b>SubjectMx</b>,  char. array <b>Operation</b>,   vector or list array <b>Imposed</b> <# black>)

The <b>return</b> is always a matrix of the same dimensions as SubjectMx.

The arguments:
<bullet><b>SubjectMx</b> is any matrix consistent with the operation;
<bullet><b>Operation</b>: Only the first element is read; it must be one of the following. (The operation is always carried out in this order: [SubjectMx element] Opn [Imposed element].)
<bullet 50,➯>"+",  "-",  "*",  "/",  "^";
<bullet 50,➯>"M" -- whichever of the two elements is greater will replace the corresponding element in the returned matrix.
<bullet 50,➯>"m" -- whichever of the two elements is less will replace the corresponding element in the returned matrix.
<bullet><b>Imposed</b> is one of:
<bullet 50,➯>a row vector, its length being the row length of SubjectMx; 
<bullet 50,➯>a column vector, its length being the column length of SubjectMx.
<bullet 50,➯>any structure (other than a vector) which has the same total size as SubjectMx. 

Although it is possible to use the arithmetical operations between two matrices, that is not the intended purpose of this function. Doing so would be much slower than a direct operation.

<u>EXAMPLE 1</u>
<# blue>vector1 = rowvec(100, 200, 300);
mx_in = matrix(2, 3,  1#2#3#4#5#6);
writeln(neat(mx_in));
mx_out = matrixop(mx_in, '*', vector1);
writeln(neat(mx_out));  <# magenta>// Will display, in neat form, the matrix: [100, 400, 900;  400, 1000,  1800]<# black>

<u>EXAMPLE 2</u>
<# blue>mx1 = matrix(2, 3,   2#4#6#8#10#12);
mx2 = matrix(2, 3,   11#9#7#5#3#1);
minima = matrixop(mx1, 'm', mx2);
writeln(neat(minima));  <# magenta>// Will display, in neat form, the matrix: [2, 4, 6;  5, 3,  1]<# blue>
maxima = matrixop(mx1, 'M', mx2);
writeln(neat(maxima));  <# magenta>// Will display, in neat form, the matrix: [11, 9, 7, 8, 10, 12]<# black>

==================================================================
//MAX//
//MAXAT//
//MIN//
//MINAT//
//MAXABS//
//MAXABSAT//
//MINABS//
//MINABSAT//
<B>max</B>(<# blue>One or more variables<# black>) -- Finds the maximum value within the list of scalars and arrays. For example, if scalar x = 25 and Arr = [5,10,20,30], then 'max(15, x, Arr)' will return 30.
 
<B>maxat</B>(<# blue>One or more variables<# black>) -- Returns an array of size 3. If we call that array 'Result', it is made up as follows:
Result[0] = the maximum value within all arguments.
Result[1] = the first <I>argument</I>  to contain this maximum value. (Later occurrences of the same maximum are ignored.) (Re numbering of arguments: the first argument of function 'maxat(.)' is numbered 0, not 1.)
Result[2] = the absolute index of the first occurrence of the maximum <I>within</I> that argument. (In the case of a scalar argument, it will be 0.)

<# blue>Arr1 = data(10, 20, 30, 30, 30);
<# blue>result1 = maxat(Arr1, 15, 30);  <# magenta>// 'result1' returns as [30, 0, 2].
<# blue>result2 = maxat(Arr1, 15, 40);  <# magenta>// 'result2' returns as [40, 2, 0].
<# black>

<B>maxabs(.)</B> and <B>maxabsat(.)</B> behave exactly as above, except that they detect the maximum <I>absolute</I> value. <b>NB!</b> For both functions the returned value retains its original sign. E.g. <# blue>maxabs( data(1, 2, -3) ) <# black>returns "-3", not "3"!


<B>min(.)</B>, <B>minat(.)</B>, <B>minabs(.)</B> and <B>minabsat(.)</B> all behave exactly as above, except that they detect the <I>minimum</I> value (or absolute value).  Again note that both of the last two functions return the value with its original sign.
==================================================================/*1*/
//MEAN  -- see MOMENTS
============================================================
//MENU//
//MENUS//
(A)  MENUS OF THE MAIN WINDOW

To switch (or find out) the visibility of main menu items, see <b>mainmenu</b>.

To generate and service an extra main menu item (with submenus), see <b>xmenu</b>.


(b)  MENUS OF THE GRAPH

To switch (or find out) the visibility of fixed main menu items on a graph, see <b>gfixedvisible</b>.

To generate and service an extra main menu item (with submenus) on a <i>graph</i>, see <b>gxmenu</b>.

============================================================
//MERGE//
//UNMERGE//
<just c><b>BINNING AND COLLATING DATA</b>
<just l>
To 'bin' data (analogous to dealing cards to players), use function <b>unmerge()</b>.  The reverse operation <b>merge()</b> interleaves data from different arrays into a single array.

<B>merge</B>(<# blue>two or more arrays 'Arr1, Arr2, ...',  (optionally) two or more scalars 'Extent1, Extent2, ...' ) <# black> -- Returns an array which contains the interleaved data from the argument arrays. The arrays are rotated through continuously in the hunt for data; at each access of the ith. Array, 'Arri', the amount of data extracted for merging will be 'Extenti'. (If that argument is not there, it defaults to 1.) 
The arrays do NOT have to be the same length. Merging continues until a point where one of the arrays, during its turn, has run out of data.
An Extent may be zero (or negative), in which case its corresponding array will simply be ignored in the merging process. However if ALL Extents are zero (or negative) an error will be raised.
The 'chars' rating of the output array is the same as that of the first argument, Arr1.

<u>Example 1:</u>   (No Extents are supplied, so extents default to 1)
	<# blue>Arr1 = data(1, 2, 3);    Arr2 = data(4,5,6);    Arr3 = data(7,8,9);
	Result = merge(Arr1, Arr2, Arr3);  <# magenta>// produces the array { 1, 4, 7, 2, 5, 8, 3, 6, 9 }.<# black>
	<# blue>writeln(Result);<# black>

<u>Examples 2 and 3:</u>
	<# blue>Arr1 = data(1, 2, 3, 4, 5, 6, 7, 8, 9);    Arr2 = data(10, 20, 30, 40, 50);    Arr3 = data(100, 200, 300, 400, 500);
	brr = merge(Arr1, Arr2, Arr3, 3, 2, 1); <# magenta>// Runs out of data halfway through processing Arr2 for the 3rd. time.
	<# blue>writeln(brr);  <# magenta>// The output:  { 1, 2, 3, 10, 20, 100, 4, 5, 6, 30, 40, 200, 7, 8, 9, 50 }
	<# blue>crr = merge(Arr1, Arr2, Arr3, 3, 0, 1); <# magenta>// the same output as you would get with "merge(Arr1, Arr3, 3, 1)"
	<# blue>writeln(crr);  <# magenta>//The output: { 1, 2, 3, 100, 4, 5, 6, 200, 7, 8, 9, 300 }<# black>


<B>unmerge</B>(<# blue>SourceArray, REF Destination1, REF Destination2 [,  REF Destination3 ... ]<# black>) -- (All of the arrays labelled 'REF' must have been predefined as arrays, though they will be recreated here.) The data in SourceArray will be dealt out to the various destination arrays. If the length of SourceArray is not an exact multiple of the number of destination arrays there will be a remainder which is not distributed; the <b>value returned</b> is the amount of this unused data (and therefore 0 if all data was distributed).
 For example:
	<# blue>SourceArray = data(1, 2, 3, 4, 5, 6, 7, 8, 9);
	N = unmerge(SourceArray, Arr1, Arr2, Arr3); <# magenta>// Arr1 --> { 1, 4, 7 };  Arr2 --> { 2, 5, 8 };  Arr3 --> { 3, 6, 9 }; and N = 0.
	<# blue>SourceArray = data(1, 2, 3, 4, 5, 6, 7, 8);
	N = unmerge(SourceArray, Arr1, Arr2, Arr3); <# magenta>// Arr1 --> { 1, 4 };  Arr2 --> { 2, 5 };  Arr3 --> { 3, 6 }; and N = 2.
<# black>

If you want just one output array - say Arr1, but not Arr2 and Arr3 - then you are  better to use function <b>downsample(.)</b>.

============================================================
//MESH//
<stops 50, 80>
<B>COORDINATES OF A LATTICE</B>

Consider a graph in 2D or 3D, with cuts along the axes as usual. Suppose it is a 2D graph, and the X axis has cuts at 0, 1 and 2 (with 0 corresponding to the left edge of the graph and 2 to the right edge), and the Y axis has cuts at 10, 20, 30, 40 (with 10 referred to the bottom of the graph and 40 to the top). Hairlines are drawn across the graph, at the X and Y cuts. Next, suppose you want access to the coordinates of every single hairline intersection; then you use the function <b>mesh</b>:
	<# blue>Mx = mesh( array XCuts,  array YCuts);<# black>
This will produce a matrix in which row[0] holds all the X coordinates and row[1] holds all the Y coordinates.
For the example given above, this will produce the matrix
	0	1	2	0	1	2	0	1	2	0	1	2
	10	10	10	20	20	20	30	30	30	40	40	40

Next, suppose we have a 3D graph with the same X and Y cuts, and Z cuts at 100, 200. Then we would use
	<# blue>Mx = mesh( array XCuts,  array YCuts, array ZCuts);<# black>
This will produce the matrix
	0	1	2	0	1	2	0	1	2	0	1	2	0	1	2	0	1	2	0	1	2	0	1	2
	10	10	10	20	20	20	30	30	30	40	40	40	10	10	10	20	20	20	30	30	30	40	40	40
	100	100	100	100	100	100	100	100	100	100	100	100	200	200	200	200	200	200	200	200	200	200	200	200

============================================================
//MOD//
//DIV//
//DIVMOD//
//EVEN//
//FRAC//
//DEFRAC//
//INT//
//ISINTEGRAL//
//ROUND//
//CEILING//
//FLOOR//
//FROMZERO//
//TOZERO//
<B>div(.), mod(.), divmod(.), frac(.), defrac(.), round(.), isintegral(.), ceiling(.), floor(.), fromzero(.), tozero(.), even(.)</B>
<# green>(Note that the fn. 'int(..)' of some languages is replaced by 'defrac(..)' in MiniMaths.)<# black>

The <b>first argument</b> may be scalar or an array. The <b>return of the function</b> will have the same structure as this argument in all cases except for function 'divmod'.
In functions which have a <b>second argument</b>, that argument must be scalar.

<B>mod(X,Y)</B>  --  returns X modulo |Y|. (Args. rounded internally before calculation.) The sign of X is preserved, if Y is positive.
<B>div(X,Y)</B> -- returns the integral part of X divided by Y (e.g. 'div(-7,3)' --> -2). (Args. rounded internally before calculation.) The sign of X is preserved, if Y is positive.
<B>divmod(X,Y)</B> -- If X is scalar, returns the list array [X div Y,  X mod Y]. If X is an array of data length L, returns a matrix of L rows, row i being [ X[i] div Y,  X[i] mod Y ]. The sign of X is preserved, if Y is positive.
<B>frac(X)</B> -- returns the absolute value of the fractional part of X. For example, 'frac(-7/3)' returns 0.3333...
<B>defrac(X)</B> -- returns the whole part of X. If X = data(-1.3, -0.3, 0.9, 1.9), defrac(X)' returns the array [-1, 0, 0, 1]. (Note that the sign of X and of defrac(X) differ in the range 0  to  -0.9999..)

<B>round(X)</B> -- rounds the variable to the nearest integer above or below. A value with a fractional part of  exactly 0.5 is rounded away from zero; e.g. 3.5 rounds to 4,  -3.5 rounds to -4.
<B>round(X,Y)</B> -- The second argument is a decimal point precision specifier. For example, 'round(1.56789, 3)' --> '1.568'. This specifier can be negative - 'round(123, -2)' returns 100. But it must always lie between -15 and +15.

<b>isintegral(X [, Y ] )</b> -- A test: returns a boolean. If X is above or below the nearest integer by more than Y (which must be positive), returns FALSE; otherwise TRUE. If Y is not supplied (or is zero or negative), a default value of 1e-10 is used. (X may be positive or negative.)
If X is an array, the return is an array of booleans, being individual outcomes for elements X[i].

<B>ceiling(X) </B> -- Gives the first integer which is at X (if X happens to be an integer) or greater than X. E.g. 'ceiling(1.234)'  returns 2; 'ceiling(-1.234)'  returns -1.
NB:  Internal numerical handling errors can cause unexpected results; e.g. if x, the result of a division, should theoretically be 1 but in fact is 1.000...001 due to such errors, then  the theoretical value of ceiling(x) would be 1 but the actual value would be 2.
<B>ceiling(X, Y) </B> -- Gives the nearest number at or above X which has precision Y decimal places. E.g. 'ceiling(1.234,1)'  returns 1.3; 'ceiling(-1.234,1)'  returns -1.2.  Negative numbers are allowed: 'ceiling(5.7, -1)' returns 10, 'ceiling(5.7, -2)' returns 100.

<B>floor(X) </B> -- Gives the first integer which is at X (if X happens to be an integer) or less than X. E.g. 'floor(1.234)'  returns 1; 'floor(-1.234)'  returns -2.
NB:  Internal numerical handling errors can cause unexpected results; e.g. if x, the result of a division, should theoretically be 1 but in fact is 0.99999... due to such errors, then  the theoretical value of floor(x) would be 1 but the actual value would be 0.
<B>floor(X, Y) </B> -- Gives the nearest number at or below X which has precision Y decimal places. E.g. 'floor(1.234,1)'  returns 1.2; 'floor(-1.234,1)'  returns -1.3.  Negative numbers are allowed: 'floor(123, -1)' returns 120, 'floor(-123, -2)' returns -200.

<B>fromzero(X) </B> -- Gives the first integer which is at X (if X happens to be an integer) or further from zero than X. E.g. 'fromzero(1.234)'  returns 2; 'fromzero(-1.234)'  returns -2.
NB:  Internal numerical handling errors can cause unexpected results; e.g. if x, the result of a division, should theoretically be 1 but in fact is 1.000...001 due to such errors, then  the theoretical value of fromzero(x) would be 1 but the actual value would be 2.
<B>fromzero(X, Y) </B> -- Gives the nearest number at X or further from zero than X which has precision Y decimal places. E.g. 'fromzero(1.234,1)'  returns 1.3; 'fromzero(-1.234,1)'  returns -1.3.  Negative numbers are allowed: 'fromzero(5.7, -1)' returns 10, 'fromzero(5.7, -2)' returns 100.

<B>tozero(X) </B> -- Gives the first integer which is at X (if X happens to be an integer) or closer to zero than X. E.g. 'tozero(1.234)'  returns 1; 'tozero(-1.234)'  returns -1. ('tozero(X)' and 'defrac(X)' give the same result.)
NB:  Internal numerical handling errors can cause unexpected results; e.g. if x, the result of a division, should theoretically be 1 but in fact is 0.99999... due to such errors, then  the theoretical value of tozero(x) would be 1 but the actual value would be 0.
<B>tozero(X, Y) </B> -- Gives the nearest number at X or closer to zero than X which has precision Y decimal places. E.g. 'tozero(1.234,1)'  returns 1.2; 'tozero(-1.234,1)'  returns -1.2.  Negative numbers are allowed: 'tozero(123, -1)' returns 120, 'tozero(-123, -2)' returns -100.

<B>even(X)</B> -- a quasi-logic function; returns 1 ('true') if X is even, 0 if odd. (Recall that X is rounded before checked for parity.) (Arg. rounded internally before calculation.)
<B>even(X, Y)</B> -- returns 1 ('true') if Y exactly divides X (after both rounded), otherwise 0. Y must be a positive integer, 2 or higher. (Args. rounded internally before calculation.)

See also <b>sign(X, ...)</b>, dealt with separately.
============================================================
//MOMENTS//
//MEAN//
//VARIANCE//
//KURTOSIS//
//STATISTICS//
<B>moments</B>(<# blue>DataArray [, WithKurtosis]<# black>) -- Returns an array of size 5 (no kurtosis) or 6 (with kurtosis); element [0] is the mean of the data in DataArray; element [1] is the standard deviation and element [2] is the variance, calculated in the statistician's way by dividing the sum of the squares by (size of DataArray)-1; elements [3] and [4] are the same, but using a divisor of just DataArray size. If WithKurtosis is present and 'true' (i.e. anything but 0), [5] is the kurtosis, using the divisor DataArray size.

The structure, if any, of the array is ignored.

DataArray must have at least 2 elements, or an error is raised.
============================================================
//MONOTONICITY//
<just c><b>IN SOME GIVEN ARRAY, ARE VALUES MONOTONIC (ALL ASCENDING OR ALL DESCENDING)?</b>
<just l>
The following function checks for this, and also detects contiguous duplicates.

<B>monotonicity</B>(<# blue>array <b>InArray</b>,  bool  <b>ExpectAscending</b> [, scalar <b>StartIndex</b> [, scalar <b>VirtualZero</b> ] ]<# black>)

ARGUMENTS
<bullet><i>InArray</i> -- Must have size of at least 2. Its structure will be ignored, so that returned values will be <i>absolute addresses</i> within the array.
<bullet><i>ExpectAscending</i> -- If TRUE, then any successive values which are descending will be regarded as anomalous; if FALSE, any successive values which are ascending will be regarded as anomalous.
<bullet><i>StartIndex</i> -- The array will be regarded as if it started here, all earlier values being ignored. Therefore the earliest anomalous value or duplicated value that could be detected would be at InArray[StartIndex+1]. It is therefore an error for StartIndex to point to the last element of InArray.
<bullet><i>VirtualZero</i> -- If two successive values differ by this amount or less, they will be regarded as equal. It can be zero, but negative values will be ignored (taken as zero).

RETURNED
An array of size 4:
	<# blue>[	No. of anomalous values,   Index of first anomaly,       No. of contiguous duplicates,    First such duplicate  ]<# black>

Re duplications: 
<bullet>A duplication is not considered to be an 'anomaly', so does not register in the first two elements of the returned array.
<bullet>A sequence "n, n, n" would register as two duplicates, "n, n, n, n" as three.

If no anomalies and no duplicates were detected, the result would be [0, 0, 0, 0]. (Note that where no first anomaly or first duplicate exists, the relevant element is set to 0. It could never take this value if there were a first anomaly / duplicate.)

EXAMPLE
	<# blue>InArray = data(10, 30, 50, 20, 30, 10, 10);
	result = monotonicity(InArray, true);  <# magenta>// 'result' will be an array of four values: [2, 3, 1, 6]<# blue>
	NoAnomalies = result[0];
	FirstAnomaly = result[1];
	NoDuplications = result[2];
	FirstDuplication = result[3];<# black>
==================================================================
//MOUSE//
//NEWCLICK//
<B>FUNCTIONS THAT HANDLE MOUSE CLICKS ON A GRAPH</B>

There are two functions for this, <B>newclick(.)</B> and <B>mouse(.)</B>. The first detects that a click has occurred; the second returns a wealth of data about the last click or (if you choose so) the last five clicks. (If you are looking for a function to handle mouse clicks in the Assignments Window, go instead to help data for function <i>btnrelease(.)</i> ).

<b>newclick</b>(<# blue>GraphID<# black>) -- returns '1' (TRUE) if the particular graph has been clicked, and '0' (FALSE) if not. The call to the function resets the flag in the graphing unit which signals the click, so that a second call immediately following would always return FALSE. Also, if the graph does not exist the function returns FALSE. Note that this function returns TRUE from the moment that the button goes down, even if at the time of the call the button is still down.

This function does not give you any information about the click; it normally sits in a code loop, allowing all the click-handling code to be bypassed until the user finally clicks the graph.


<B>mouse</b>(<# blue>scalar GraphID [, bool ReturnHistoryMatrix ]<# black> )
If you provide a positive GraphID, this will only return data for click(s) on that particular graph; but if GraphID is 0 (or negative), it returns data on any graphs clicked.  
Usually you just want information about the latest mouse click. If so, don't provide a second argument. We will look at that case first.

<u>(Case 1) Just the Last Click</u>
The return is a <i>list array</i> of size 18, made up as follows. Note that after a mouse button has gone down, some fields have different values before and after it then goes up.
<i>All elements default to 0</i> where there has been no click yet on the graph. (To check for this state, either element [0] or [1] are suitable.)
If you supplied a particular GraphID and that graph could not be identified, the return array will consist entirely of values -1.

<bullet>[0]: ID of clicked graph.
<bullet>[1]: Button: 1 = left, 2 = middle (if none, usually simulated by pressing left and right buttons simultaneously); 3 = right button.
<bullet>[2]: TRUE (i.e. 1) if the button is still down; otherwise FALSE (0). 
<bullet>[3]: Time at which the button went down, in milliseconds since the beginning of 1 AD. Can be compared with the present time, as returned by (datetime())[9].
<bullet>[4]: Period in milliseconds for which the button was down; 0 if the button is still down.
<bullet>[5] to [9]: Currently unused.
The rest are mouse pointer coordinates:
<bullet>[10], [11] are the x and y SCALED coordinates of the pointer at the instant when the button went DOWN. (Always (0, 0) for 3D graphs.)
<bullet>[12], [13] are x and y PIXEL coordinates corresponding to the above. (The reference point (0, 0) is the top left of the whole Drawing Area, not of the plotting surface; the Drawing Area covers all below the header label and above the footer label and between the side margins of the window.)
<bullet>[14], [15] are the x and y SCALED coordinates of the pointer at the instant when the button went UP. (Always (0, 0) for 3D graphs.) 
<bullet>[16], [17] are x and y PIXEL coordinates corresponding to the above. Both the last and this set of coordinates are all zero while the button is still down.
  
<u>(Case 2) Click History Required</u>
This returns a matrix of five rows, each of length 18, and each with data corresponding to the above schema. Row [0] corresponds to the latest click, and is exactly as above. Higher rows however will have no UP coordinates and no button-down period (i.e. elements [4], [14] to [17] will all be zero). Where there have not yet been five clicks, rows above the latest click (if any) will consist entirely of zeroes.

<U>What about double-clicks?</U>
You would have to write a double-click detector in your code, using the times provided by 'mouse(.)'; your code would decide if two clicks were close enough together to constitute a double-click. Also, your code should delay the response to a single click until sure that it is not the first of a double-click pair.
			______________________________

Here are two examples; the first shows how to detect clicks which occur while the control key is being held down. The second is a model for use where you want to be able to distinguish between single and double clicks on a graph surface.

<u>EXAMPLE 1</u>
You may or may not want some response to a single click on a graph; but you particularly want some response to occur if the control key is being held down while you click; in this case, the required response is to display the coordinates of the click.

<# magenta>// Create a simple graph - y = x^2 will do fine:<# blue>
xx = ladder(101,0,1);  
yy = xx*xx;
p = plot(yy, xx,   ' ', -1, -1, '_', 1, 'blue');
g = graph(p);
<# magenta>// Ignore clicks unless they occur while the control key is being held down:<# blue>
while (true)
{	if (lastclosed() > 0) break; <# magenta>// User closed the graph, so end the program.<# blue>
	if (newclick(g))
	{	thisClick = mouse(g);
		clickX = thisClick[10];  clickY = thisClick[11];
		if (keydown(true) == "Cntrl") <# magenta>// The control key is being held down while the click occurs:<# blue>
		{	show("Click point:   (", round(clickX, 2), ",  ", round(clickY, 2), ")");
		}
	}
}<# black>

<u>EXAMPLE 2</u>

<# red>__ DISTINGUISHING BETWEEN SINGLE- AND DOUBLE-CLICKS ON THE GRAPH SURFACE
<# magenta>// This demo program starts with an empty graph. Whenever you single-click, a new point appears at the place
//  where you clicked. When you double-click, the nearest point (if any) is removed from the graph.
<# blue>doubleClickIntvl = 300; <# magenta>// clicks closer together than this no. of msecs. are taken as constituting a double-click.
// Set up the empty graph:
<# blue>grid(0, 1, 1,   0, 1, 1); <# magenta>// The graph will have no hairlines.
<# blue>g = graph();
<# magenta>// Set up the repositories of X and Y coordinates of clicked points, and of the IDs of their plots, as lists:
<# blue>listX = list_new()-1;     listY = list_new()-1;
listPlots = list_new()-1;

<# magenta>// WAIT FOR CLICKS, AND THEN HANDLE THEM:
<# blue>lastClickTime = 0;
handleSingleClickTime = 0;
while (true)
{	if (lastclosed() > 0) break; <# magenta>// User closed the graph, so end the program.
	// The first section of the WHILE loop checks for a new click, and processes it.
	<# blue>if (newclick(g))
	{	thisClick = mouse(g); <# magenta>// Details of the latest click.
		<# blue>thisClickTime = thisClick[3];
		<# magenta>// Is it the second of a double-click pair?
		<# blue>if (thisClickTime - lastClickTime < doubleClickIntvl)
		{	HandleDoubleClick(g, thisClick);
			lastClickTime = 0; <# magenta>// so that 3 clicks in rapid succession is not taken as two double-clicks
			<# blue>handleSingleClickTime = 0; <# magenta>// cancel the first click's provisional status as being a single-click.
		<# blue>}
		else <# magenta>// a single click, or possibly the first click of a double-click pair
		<# blue>{	lastClickTime = thisClickTime;
			handleSingleClickTime = thisClickTime + doubleClickIntvl; <# magenta>// only after this time will a single click be handled.
		<# blue>}
	}
	<# magenta>// The second section of the WHILE loop checks if there is a single-click response pending.
	// A click is only regarded as a single click if it has not been followed by a 2nd. click after doubleClickIntvl milliseconds.
	<# blue>if ( handleSingleClickTime > 0  &&  (datetime())[9] > handleSingleClickTime)
	{	HandleSingleClick(g, thisClick);
		handleSingleClickTime = 0;
	}
}
lists_kill(); <# magenta>// Not nec. for a short program like this, but good practice.

<# red>__  ~~~~~~ FUNCTIONS ~~~~~~~~~~~~

<# blue>function HandleSingleClick(GraphID, ClickData)
{	import scalar listX, listY, listPlots; <# magenta>// The lists themselves are global, but their names have to be imported.
	// plot the point as a blue cross:
	<# blue>p = plot( ClickData[11], ClickData[10],  'x', 5, 'blue', ' ');
	list_add(listX, ClickData[10]);     list_add(listY, ClickData[11]);
	list_add(listPlots, p);
	addplot(GraphID, p); <# magenta>// display the new cross on the graph.
<# blue>}

function HandleDoubleClick(GraphID, ClickData)
{	import scalar listX, listY, listPlots; <# magenta>// The lists themselves are global, but their names have to be imported.
	// Find the nearest point:
	<# blue>sz = list_size(listX);   if (sz < 1) return; <# magenta>// No points, so no dice.
	<# blue>X = ClickData[10];  Y = ClickData[11]; <# magenta>// Coordinates on the graph of the mouse click (scale coordinates, not pixel coordinates)
	<# blue>nearest = -1;   proximity = 1e10;
	for (i, sz)
	{	X1 = list(listX, i);   Y1 = list(listY, i); <# magenta>// coords. of one of the points on the graph
		<# blue>d = (X - X1)^2 + (Y - Y1)^2; <# magenta>// The square of the distance will do fine.		
		<# blue>if (d < proximity) { nearest = i;  proximity = d; }
	}
	<# magenta>// Expunge the plotted point first from the graph and then from the lists:
	<# blue><# blue>p = list(listPlots, nearest);
	killplot(p); <# magenta>// This removes the plot from the graph and also from the separate list of plots internal to MonoMaths.
	<# blue>list_delete(listX, nearest, 1);   list_delete(listY, nearest, 1);    list_delete(listPlots, nearest, 1);
	return; <# magenta>// We have to put this return in, even though the function is void, because we inserted a conditional return higher up.
<# blue>}

===============================================================/*1*/
//MOVESHAPE  --  see PLOTSHAPE
==================================================================
//MULTIBOX//
<just c><b>THE MULTIBOX</b>
<just l>
Function <b>multibox</b> allows you to design your own box (within limits); you may choose any number and deployment of these widgets: Labels, Text boxes, Check buttons, Radio buttons. You can have them in vertical layers, each layer being stacked from the left to the right with your widgets.

The function goes like this:
	<# blue>ButtonID = multibox(array Heading, array LayoutString, array Texts, array ButtonTitles [, array TextsDelimiter ] )<# black>
The first three arguments are all <i>named arguments</i>. (With other dialog boxes you can e.g. write the heading directly with quote marks into the function; not so with this one.)

<u>LayoutString</u>
Each widget is represented by a single letter. The possibilities are:
	'L' -- a label, with text wrap.
	'l' -- a label, without text wrap. (The window stretches to accomodate long texts.)
	'T' -- a text box.
	'V', 'W' -- a text view, editable; 'W' accepts and interprets text tags.
	'v', 'w' -- the same, but not editable.
	'X' -- a check button, which is to be checked when the dialog opens.
	'x' -- a check button, which is to be unchecked when the dialog opens.
	'R' -- a radio button, which is to be checked when the dialog opens.
	'r' -- a radio button, which is to be unchecked when the dialog opens.

To pack widgets from left to right into a single horizontal layer, simply put the letters one after the other. For example, "LT" will put a label on the left and a text box, level with it, on the right. Or "LRRR" will put a label on the left and a group of three radio buttons on the right.

To start a new horizontal level, insert a '|'. For example, this will give three label-text box pairs, one under the other: "LT|LT|LT".

Radio buttons are automatically grouped if they are listed side by side in the one horizontal level. (On the other hand, "RrrLrrR" would give you two independent groups of radio buttons on the one horizontal level, with a label between them, which may remain empty if you just want it to act as a divider.) As is usual for radio buttons, only one in any one group can be checked at once. (If you enter "rrr", with no capital R, the first button will start off checked. If you enter "RRr", the last button with a capital will start off checked, in this case the 2nd.)

Check buttons are also visually grouped in the same way, but can be checked independently of one another.

<i>Return value:</i>  LayoutString is altered by the function, but only to reflect check button and radio button choices. A checked button will again be represented by a capital letter. For example, if LayoutString started as "LT|Rrr|xxx", and the user checked the middle button of each of the two button groups, then the return value of LayoutString would be "LT|rRr|xXx".
You may find function <b>getsegmt</b>(.) useful for extracting a delimited portion of LayoutString.

<u>Texts</u>
There must be exactly one substring, within the string Texts, for each widget. (In the case of buttons, this is the text that will be printed beside it. In the case of text boxes, it will be the initial text for the box.) Again the delimiter is '|' (unless you alter it - see below), but this time it must be placed between the text of every widget, without reference to horizontal and vertical placement. Texts will be processed in the order in which widgets occur in LayoutString. If you don't want visible text for some widget, you can either make the text a space or else leave it out altogether (E.g. for three labels, <# blue>Texts = "||"<# black> would make them all blank.)
Useful functions for manipulating 'Texts' are <b>getsegmt</b> (as in the example below) and <b>findsegmt</b>.

<i>Return value:</i>  Texts is returned as is, except that components representing text boxes are replaced by the final text of the text box. Also, if the entrance value of Texts for a label or a button was empty (e.g. two delimiters side by side), the corresponding returned value for that subtext will be a single space.
Again, you may find function <b>getsegmt</b>(.) useful for extracting a delimited portion of Texts.

<u>ButtonTitles</u>
Button names delimited by '|'. This does not have to be a named array, so you can enter e.g. "ACCEPT|CANCEL" directly as the function argument. Any (sensible) number of buttons can be used.

<u>TextsDelimiter</u>
It may be that you want the character '|' to be a valid character to enter into a text box. In that case, you can change the delimiter for Texts (<i>but not for the other arguments</i>) by adding this argument. The first element of the array will be taken as the delimiter. It should be a printable character, avoiding specialized ones (e.g. Chinese symbols) which may not be handled well by the string handling methods of the underlying Mono language. If in doubt, try it out first. The other reason for using a different delimiter would be where you think there is a significant risk that the user will insert a '|' into a text box, even though it is not called for. Doing so will result in a return value of Texts that will be out of synch with that and later widgets.

<u>The Returned value - ButtonID</u>
Buttons acquire numbers from no. 1 for the leftmost (i.e. the first referenced in ButtonTitles). Closure of the dialog box by clicking on the corner icon returns 0.

You can <i>change box size and position</i> by a prior call to function <b>setbox</b>, as with other dialog boxes. (Small restriction for this dialog: you cannot change box placement unless you also supply specific values for width and height.)


<u>AN EXAMPLE OF USE</u>
<# blue>heading = "A SURVEY";
texting_delimiter = '‖';  <# magenta>// Unlikely to be entered by user. Get the character by entering a double-quote and then keying cntrl-shift-H.<# blue>
layout = "L|LT|Rrr";
texting = "Tell us about yourself...‖My favorite colour is‖‖I am young‖I am middle-aged‖I am old";
buttons = "ACCEPT|CANCEL";
<b>btn = multibox(heading, layout, texting, buttons, texting_delimiter);</b>  <# magenta>//!<# blue>
if (btn == 1) <# magenta>// 'ACCEPT'<# blue>
{
	<# magenta>// Deal with the text box entry:<# blue>
	ss = getsegmt(texting, texting_delimiter, 2);
	writeln("How nice that your favorite colour is ", ss, "!");
	<# magenta>// Deal with the radio buttons:<# blue>
	radio = find(layout, 5, 'R'); <# magenta>// Radio buttons in 'layout' start from layout[5].<# blue>
	sift(radio)
	{	5: writeln("Great that you are still young.");
		6: writeln("Middle-aged? You still have some life left, I suppose.");
		7: writeln("Sad, though, that you are such an old fossil.");
	}
}
else writeln("Coward!"); <# magenta>// 'CANCEL', or corner icon closure<# black>




==================================================================
//MXCENTRE//
<just c><b>FIND THE CENTRE OF A CLUSTER WITHIN A MATRIX MAP</b>
<just l>
<i>The Scenario:</i>  You have a matrix which in some sense is analogous to a map. There is a cluster of data, like an island on the map; it is surrounded by a sea of zeroes. You want to find the matrix element which best represents the centre of the island. The function to use is:

	<b>mxcentre</b>(<# blue>char. array <b>Mode</b>,  matrix <b>InMatrix</b> [, bool <b>RoundToNearestEvenNo</b>] <# black>).

The return is always an array of length 2:  [0] = row no., [1] = column no.  Values are rounded, hence the optional final argument. If <# blue>RoundToNearestEvenNo<# black> is absent or 'false', rounding is away from zero (2.5 rounds to 3); otherwise towards the nearest even number (2.5 rounds to 2,   3.5 rounds to 4).

If the function cannot find such a centre (as explained below), it returns the array { -1, -1 }.


<u>MODES</u>
If <# blue>Mode<# black> exactly = "<b>of rectangle</b>", then the centre of the rectangle which fully contains the data cluster is returned. Some data always lies on the perimeter of this rectangle; "fully contains" means that no element of data is <i>outside</i> the perimeter of the rectangle.

For this mode, 'data' is defined as ANY NONZERO VALUE. Outside the containing rectangle are only zeroes. (Of course zeroes may well be anywhere inside the rectangle as well.)

The only case where no centre can be found for this mode is where there are no non-zero elements in <# blue>InMatrix<# black>. 

Here are some examples of containing rectangles. All values within or on the containing rectangle are coloured <# red>red<# black>. The asterisked value is at the centre of the rectangle; its row and column index would be returned by the function. Where the value depends on the rounding method there are two asterisked values.
<stops 20, 40>
		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0
		0	<# red>1	1	1<# black>	0		0	<# red>5	0	0<# black>	0		0	<# red>1	2	3	4<# black>		0	<# red>5*<# black>	0	0	0		0	0	0	0	0
		0	<# red>1	1*	1<# black>	0		0	<# red>0	0*	0<# black>	0		0	<# red>0	0*	0*	0<# black>		0	0	0	0	0		0	0	0	0	0
		0	<# red>1	1	1<# black>	0		0	<# red>0	0	3<# black>	0		0	<# red>5	6	7	8<# black>		0	0	0	0	0		0	0	0	0	0
		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0

In the 3rd. matrix there are two asterisked values. The theoretical central column is 2.5; for 'round to nearest even no.', the left asterisk applies; for 'round away from zero', the right asterisk applies.
In the 5th. matrix there are no nonzero values; the return for this matrix would be the array {-1, -1}.


If <# blue>Mode<# black> exactly = "<b>of mass</b>", then the centre of mass of all data in the whole matrix is returned. In this case - as not above - the actual nonzero values ARE relevant, representing masses. (Masses may be negative; the function does not take their absolute value, but accepts signed values as is.) (The algorithm for obtaining the centre of mass is explained at the end of this display.)

Again, the asterisked value is returned as the centre, in the following examples.

	0	0	0	0	0		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0
	0	1	1	1	0		0	9*	0	0	0		0	1*	0	0	0		0	1	0	-2	0		0	0	0	0	0
	0	2	1*	2	0		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0
	0	1	1	1	0		0	0	0	1	0		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0
	0	0	0	0	0		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0		0	0	0	0	0

In the 4th. matrix the theoretical column for the centre of mass is 5; but there is no column 5, so that value is out of range; the return would therefore be {-1, -1}. (In many cases, however, negative values would return a legitimate value; for example, if in the 4th matrix you replace -2 by -3, then the returned array will be {1, 4}.)

In the 5th. matrix the centre of mass is indeterminate. It is also indeterminate if the sum of all values in the matrix comes to exactly zero.


<i>The algorithm for computing the centre of mass:</i>  To get the first value in the returned array, the columns are summed, producing an array which therefore has the same length as the number of columns in the matrix. Let's call this array 'SumOfCols'. Then for the 1st matrix in the set immediately above, SumOfCols = { 0  3  5  3  0 }. The centre of mass of this array is found from the formula   Σ (i * SumOfCols[i])  /  Σ SumOfCols[i] ,  where 'Σ' sums over all indices i in SumOfCols. In this example, this is (0*0 + 3*1 + 5*2 + 3*3 + 4*0) / (0 + 3 + 5 + 3 + 0), yielding 22/11, or 2. The first value of the returned array will therefore be 2. The second value is returned similarly, using the sum of rows.

See also function <b>cluster(.)</b>.

===============================================================
//MXHALF//
<B>READING FROM OR WRITING TO THE UPPER OR LOWER TRIANGLE OF A MATRIX</B>

<u>READING THE TRIANGLE</u> 
<B>mxhalf</B>(<# blue>square matrix SqMx, array WhichHalf<# black>) -- arguments as below. Returns a <b>list array</b>, being the data read along successive rows.

<u>WRITING THE TRIANGLE</u> 
If it has at least four arguments, function <B>mxhalf(.)</B> returns a copy of the input square matrix with one of its triangles altered. The opposite triangle may optionally be filled by copying (reflecting), with or without sign change. Optionally the main diagonal may also be altered. The format is:
<B>mxhalf</B>(<# blue>square matrix SqMx, array WhichHalf, array OtherHalfAction, array Data [, array / scalar MainDiagonal] <# black>)

<u>ARGUMENTS</u>
<# blue>SqMx<# black> -- at least a 2x2 matrix.
<# blue>WhichHalf<# black> -- (Only the first letter accessed; case sensitive.) "L" = lower matrix triangle (i.e. all to left of / below the main diagonal), "U" = upper triangle. Any other value crashes the function.
<# blue>OtherHalfAction<# black> -- (Only the first letter accessed; case sensitive.)   " " (space) =  leave other triangle alone; "C" = copy this triangle to the other (so that SqMx[i,j] = SqMx[j,i], i ≠ j).  "N" = same, but with sign reversal of each element on copying (so that SqMx[i,j] = ‒ SqMx[j,i], i ≠ j).  Any other value crashes the function.
<# blue>Data<# black> -- the data that will fill the given triangle, filling across rows. It must have exactly the right size, which for an NxN matrix is (N<^>2</^> ‒ N) / 2.
<# blue>MainDiagonal<# black> -- If this argument is omitted, the main diagonal is not altered. If present and scalar, that value repetitively fills the main diagonal. If an array, it must have exactly the right length to fill the main diagonal (from above down).
============================================================
//MXMULT//
//DETERMINANT//
//INVERSE//
//TRANSPOSE//
<B>SPECIFIC MATRIX OPERATIONS</B>

To create an MxN matrix, use the void function "dim(Mx, M, N);" (note order of M and N).
To turn a list array (of size M*N) into an MxN matrix, preserving data, use "redim(Arr, M ,N);". (The first N entries of the array will become row 0 of the matrix; the next N will be row 1; etc.)

Structuring an array like this does not interfere with the operation of <B>general array functions</B>; for example "Mx1 = sin(Mx)" will produce a matrix Mx1 of the same dimensions as Mx, but with all elements having undergone a sine operation.
 
<B>Arithmetic signs</B> take no regard for structure; operations are simply carried out on every element. For example, Arr*5 will produce an array with the same structure as Arr, but with every element multiplied by 5. If you multiply Mx1*Mx2, as long as the two have an equal amount of data this will not produce an error; the result will be an array of the same structure as Mx1, with every element being the product of corresponding elements. (Mx2 could even be a list array, of the same total size as Mx1.)

<B>Functions specifically for matrices and vectors</B>

<B>transpose(Mx)</B> -- returns a transposed copy of Mx. (One concession: a list array will be interpreted as a <I>row</I> vector, and so would not raise an error. This is also true with 'mxmult(.)', but is not generally true for matrix-handling functions.)
<B>determinant( SquareMx [, CutOff])</B> -- produces the determinant of Mx (which must be square and at least 2x2). If the second argument is supplied, it should be a very tiny positive value (e.g. 1e-5); a value of zero will be then returned for determinants below CutOff. (This overcomes the problem of internal rounding errors producing very tiny nonzero determinants were zero determinants would be expected.)
<B>inverse(Mx [, CutOff])</B> -- Returns the inverse of the matrix, which must be square, and at least 2x2. If the matrix is singular (and therefore cannot provide an inverse), the function instead returns an array of size 1, value NaN; a call to 'empty(.)' would return 'true'.
<B>mxmult(Mx1, Mx2)</B> -- matrix multiplication, where Mx1 has dimensions MxN and Mx2 dimensions NxP. Note the difference to 'Mx1*Mx2', mentioned at the top. (One concession: a list array will be interpreted as a <I>row</I> vector, and so would not raise an error where a row vector is allowed. This is also true with 'transpose(.)', but is not generally true for matrix-handling functions.)
<b>matrixop(Mx1, Operation, Arr)</b> -- operations between matrix and vector, or matrix and matrix.
<b>mxhalf(.)</b> -- fills the upper and/or lower triangle of a matrix, ± the main diagonal. Key F1 with the cursor at 'mxhalf'.
<B>mxdiag(.)</B> -- returns / manipulates square matrix diagonal. Key F1 with the cursor at 'mxdiag'.
<B>shufflemx(..)</B>-- rearrange the order of rows or columns.
<B>selectrows / selectcols(Matrix, arrow of row / column nos.)</B> returns a matrix made up of the indicated rows or columns.
<B>pokerows / pokecols(matrix Destination, list array Row/ColNos, matrix Source)</B> -- the inverse: overwrites existing rows / cols with supplied new ones.
<B>insertrows(.),  insertcols(.)</B>.
<B>appendrows(.),  appendcols(.)</B>.
<B>copyrows(.),  copycols(.),   copyrowsto(.),  copycolsto(.)</B>.
<B>replacerows(.),  replacecols(.)</B>.
<B>deleterows(.), deletecols(.)</B>.
<B>sumrows(.),  sumcols(.)</B>.
<B>prodrows(.),  prodcols(.)</B> -- products of all terms in each row / column.
<B>chainrows(.),  chaincols(.)</B> -- generate matrices with given no. of repetitions of an input row / column.
<B>findinmx(..)</B> -- find a value in a matrix and return the row and column of the find.
<B>push(.),  pop(.)</B> -- cause the array to act like a stack, rows being pushed onto / popped off the stack. (Not confined to matrices, but would usually be used with a matrix.)
<B>ones(..)</B> -- creates a matrix with a variable number of 1s in each row.
<B>rowop / colop (..)</B> -- replaces a row / column with a multiple of any compatible row / column (unary version) or with an operation between two rows / columns, or even a row and a column (if a square matrix).
==================================================================
//MXDIAG//
<B>MAIN DIAGONAL OF A SQUARE MATRIX</B>

The function to use is <B>mxdiag(.)</B>, which takes either one argument (for reading the main diagonal) or three arguments (for changing it) - never two arguments.;

<B>Reading the Main Diagonal</B>
	<# blue>arr = mxdiag(Mx);  <# magenta>// Returns the main diagonal of Mx as a list array.
<# black>
<B>Altering the Main Diagonal</B>
The <I>second argument</I> is an array, the first element of which is the character code for one of: '=', '+', '-', '*', '/'. This character is the <I>operator</I>.
The <I>third argument</I> can be either scalar or an array. If it is an array, it must have the same length as the side of the square matrix. If it is a scalar, it will be internally replaced by an array which replicates the scalar in every element.
In each case a <I>matrix</I> is returned, being a copy of the original matrix with the operation applied to the main diagonal.
If the operator is '=', the main diagonal is simply replaced by the supplied value(s). In all other cases, 
	new diagonal = old diagonal  <B>.</B>  <I>operation</I>  <B>.</B>  third argument array
 
Suppose a 3x3 array [ 1  2  3;    4  5  6;    7  8  9], called 'Mx', for the following examples.
	<# blue>newMx = mxdiag(Mx, '=', 10);  <# magenta>// Returns [10  2  3;  4  10  6;  7  8  10].
	<# blue>arr = data(10, 20, 30);
	<# blue>newMx = mxdiag(Mx, '=', arr);  <# magenta>// Returns [10  2  3;  4  20  6;  7  8  30].
	<# blue>arr = data(10, 20, 30);
	<# blue>newMx = mxdiag(Mx, '-', arr);  <# magenta>// Returns [-9  2  3;  4  -15  6;  7  8  -21].

<# black>See also the function <B>ones(..)</B>, which sets a variable number of the leading elements in each row to 1.
===============================================================
//NEAT//
<B>neat</B>(<# blue> variable DisplayObject [, variable Formatting [, variable Tabbing ] ]<# black>) -- Used typically in 'write(..)' and 'writeln(..)', to provide formatted display of matrices and higher order structures. The output is a chars. array, ready for display, and including formatting tags e.g. for colour settings. Consider the single-argument case first. If DisplayObject is a scalar, the result is simply the chars. version of its value (not very useful). If a list array, the output consists of its values either separated by commas and spaces ("1, 3, 5;") or, if a chars. array, as contiguous characters. If a matrix, each row is on a separate line, the line being introduced by the row number. If a higher-dimensional object, each submatrix is headed by the location of its first element (e.g. "[1, 2, 0]"), and the submatrix 's row number again introduces each row. Each row will be as above: values separated by commas or by contiguous characters.

<I>Argument 'Formatting':</I> If a scalar in the range 0 to 15, sets the maximum number of decimal places (rounding occurring if necessary). If a chars. array, it is handed directly to .NET; if it makes sense to .NET (e.g. "E3", "G4"), the formatting applies to all displayed numbers. If .NET raises an error, 'neat(.)' fails with an error message. Any negative value causes this argument to be ignored, so '-1' is suitable if you want a dummy value (where you are setting the 3rd. argument to a functional value).
 To get a list of allowed values, enter 'str' into the Assignments Window, key F1, and scroll down a bit.

<I>Argument 'Tabbing':</I> If omitted, or is zero or negative, the default of no tabbing applies, as in the first paragraph above. If 'Tabbing' is scalar, then the delimiter is a tab, and the interval between tabs is 'Tabbing' pixels. A practical value for up to 3 digits would be 50. 

If 'Tabbing' is a chars. array, its first character is examined. If it is 'C' or 'c', then each row is displayed as a set of contiguous characters (no delimiters), irrespective of its 'chars.' rating. ('neat(.)' always ignores chars. rating, and defaults to displaying numerical values for all arrays.) In this case, the 'Formatting' argument has no effect on the display. If it is 'T' or 't', then tab-delimiting is enforced, the number of 'T's and 't's in the whole array setting the number of default tab steps. (Small print: Scalar values of Tabbing less than 10 have the same effect as multiple instances of 't'; e.g. Tabbing = 3 has the same effect as Tabbing = "ttt".)

<U>CODE EXAMPLES</U>
The output is not displayed here; run the code below, to see the effects in the Results Window.

<# magenta>// Define three structures all holding the same data, which happens to be
<# magenta>//  the unicode values of capital letters 'A' to 'H'. 'Dims1' is a list array,
<# magenta>//  'Dims2' a matrix and 'Dims3' a 3-dimensional structure.
<# blue>Dims1 = data(65, 66, 67, 68, 69, 70, 71, 72); <# magenta>// list array
<# blue>Dims2 = Dims1;  redim(Dims2, 4, 2); <# magenta>// matrix
<# blue>Dims3 = Dims1;  redim(Dims3, 2, 2, 2); <# magenta>// 3D structure.
<# magenta>// Display with various uses of 'neat(.)':
<# blue>writeln("SINGLE ARGUMENT:");
writeln("Dims1:", 10, neat(Dims1), 10, "Dims2:", 10, neat(Dims2), 10, "Dims3:", 10, neat(Dims3) ); <# magenta>// unicode '10' is the line feed
<# blue>writeln("----------------------");
<# magenta>// Show the use of tabs instead of commas as delimiter:
<# blue>writeln("USING TABS AS DELIMITER:");
writeln("Dims2, default tab step (50 points):", 10, neat(Dims2, -1, 'T'), 10, 
	"Dims2, specific tab step (choose 72 points):", 10, neat(Dims2, -1, 72), 10, 
	"Dims2, 3 x default tab step:", 10, neat(Dims2, -1, 'ttt') ); <# magenta>// Same effect, if you replace 'ttt' by scalar 3.
<# blue>writeln("----------------------");
<# magenta>// Force characters:
<# blue>writeln("AS CHARACTERS:");
writeln("Dims1:", 10, neat(Dims1, -1, 'c'), 10, "Dims2:", 10, neat(Dims2, -1, 'c'), 10, "Dims3:", 10, neat(Dims3, -1, 'c') );
writeln("----------------------");
<# magenta>// Using just a list array, show some formatting examples:
<# blue>writeln("FORMATTING EXAMPLES");
Arr = data(1.23456,  2.99999);
writeln("Original data:  ", neat(Arr));
writeln("to 3 dec. places:  ", neat(Arr, 3)); <# magenta>// Equivalent to .NET format string "F3" (to which it is in fact internally converted).
<# blue>writeln("forced to exponential form:  ", neat(Arr, "E2")); <# magenta>// the '2' is the no. digits after the decimal point. This is a .NET format string.
<# blue>writeln("---------------------------------");



============================================================
//NEWCLICK -- see MOUSE
============================================================
//NORM -- see DISTANCE
//NOT -- see IS
//NOZERO -- see ALLZERO
============================================================
//NTH//
//ORDINAL//
<B>nth</B>(<# blue>scalar Number [, bool JustTheSuffix [, bool NoFullStop] ]<# black>) -- Returns a chars. array with the appropriate suffix. Examples: nth(1) --> "1st.", nth(22) --> "22nd.", nth(0) --> "0th.". Sign is preserved:  nth(-3) --> "-3rd.".  The scalar argument is first rounded.
Optional arguments: If 'JustTheSuffix' is present and TRUE, then eg. 23 --> "rd.".  Independently, if 'NoFullStop' is present and TRUE,  then e.g. 23 --> "23rd". (These would be useful where you were using formatted script and wanted to superscript the two added letters.)
============================================================
//ODOMETER//
//COUNTER//
<B>odometer</B>(<# blue>Named array, Scalar NoBase[, Scalar Direction]<# black>) -- (This function alters the argument array, and returns a scalar indicator.)

The fn. treats the array as if it were an odometer, and increments or decrements the mileage. For example, if the array is [1, 2, 2] and NoBase is 3, successive calls (to increment) will change the array to [2, 2, 2], then [0, 0, 0], then [1, 0, 0], [2, 0, 0], [0, 1, 0]...

If Direction is present and any of 'D', 'd' or 0, then decrementing occurs; any other value, or omission, results in incrementing.

Returned value: 0 = returned array has all zeros;  2 = returned array has all digits maximal (i.e. NoBase-1); 1 = any other arrangement.
============================================================
//OFFSET -- see INDEXED
===========================================================
//ONES//
<B>CREATING A MATRIX PARTLY FILLED WITH 1s</B>

The function <B>ones(..)</B> always returns a matrix; it comes in two basic forms -
\t<# blue>mx = ones(4, 3, ...)  <# magenta>// this creates a 4x3 matrix.
<# black>and
\t<# blue>mx1 = ones(mx2, ...)  <# magenta>// this creates a matrix modelled on mx2.

<# black>One or two arguments may follow the above.
The <I>first further argument</I> applies to both versions above, and indicates how many 1's to put into the rows of the generated matrix. If it is scalar, that no. of 1's will be inserted in every row.
\t<# blue>mx = ones(3, 3, 1);  <# magenta>// Creates the 3x3 matrix: [1,0,0; 1,0,0; 1,0,0].
\t<# blue>mx = ones(3, 3, 3);  <# magenta>// Creates the 3x3 matrix: [1,1,1; 1,1,1; 1,1,1].
<# black>If it is an array - which must have exactly the same length as there are rows in the matrix - then the ith. element gives the length of 1s to go into the ith. row of the matrix:
\t<# blue>arr = data(1,2,3);  mx = ones(3, 3, arr);  <# magenta>// Creates the 3x3 matrix: [1,0,0; 1,1,0; 1,1,1].
<# black>It is not an error for this length of 1s to be out of range. If it is <= 0, no 1s are inserted; if it exceeds the row length, the whole row becomes 1.

<# black>The <I>second further argument</I> applies only to the case where the new matrix is modelled on an old one. It is a boolean, representing: "Keep values in mx2 which are not overwritten by 1's". The default (for omission) is FALSE. 
Suppose mx2 is: [10,11,12;  20,21,22;  30,31,32];
Then,
\t<# blue>mx1 = ones(mx2, 1);  <# magenta>// Creates the 3x3 matrix: [1,0,0; 1,0,0; 1,0,0].
\t<# blue>mx1 = ones(mx2, 1, true);  <# magenta>// Creates the 3x3 matrix: [1,11,12; 1,21,22; 1,31,32].

<# black>See also the function <B>mxdiag(..)</B>, which sets the main diagonal of a matrix to any desired value(s).
============================================================
//OR -- see AND
============================================================
//OVERLAY//
<B>overlay</B>(<# blue>array Underdog,  array Overlay, array Operation [, scalar Pointer1 [, scalar Pointer2 ]]<# black>) -- Returns an array which is the overlap of Overlay onto part or all of a copy of Underdog, the outcome for overlapping elements of the two arrays being decided by argument 'Operation'.

Operation codes are always just a single character. They are as follows. (The next section will indicate which elements in Overlay and Underdog are 'OverlayElement' and 'UnderdogElement' in the following.)
<bullet>The four mathematical signs '+', '-', '*', and '/', the order being "Underdog OPN Overlay". (E.g. '-'  results in the subtraction (UnderdogElement - OverlayElement) ).
And various overwriting operations, where the Overlay element overwrites the corresponding Underdog element:
<bullet>'#' --  overwriting is unconditional; OverlayElement always overwrites UnderdogElement.
<bullet>'\>' -- OverlayElement overwrites UnderdogElement only if OverlayElement \> UnderdogElement.
<bullet>'\<' -- OverlayElement overwrites UnderdogElement only if OverlayElement \< UnderdogElement.
<bullet>'o' -- OverlayElement overwrites UnderdogElement EXCEPT where OverlayElement = 0. ('o' is the lower-case letter, not the zero digit.) 
<bullet>'u' -- OverlayElement overwrites UnderdogElement EXCEPT where UnderdogElement = 0 
<bullet>'b' -- OverlayElement overwrites UnderdogElement EXCEPT where EITHER OverlayElement = 0  OR  UnderdogElement = 0.

In the case where Underdog and Overlay are both LIST ARRAYS, each element of Operation is significant. The element which applies when OverlayElement is Overlay[n] is Operation[n <b>modulo </b>length-of-Operation]. For example,
\t<# blue>aa = overlay( data(10, 20, 30, 40, 50),   data(1, 2, 3, 4, 5),  "+-*", 0); <# magenta>//  aa --> [11,  18,  90,  44,  45]   
<# black>
If either (or both) Underdog or Overlay is not a list array, then the only significant element in Operation is Operation[0], which will apply for all Underdog-Overlay interactions.

<b>Allowed Interactions</b>

<i>Overlaying of one list array on another:</i>  Exactly one pointer must be supplied. If this has value n, then Overlay[i] will overlay Underdog[n + i]. The value of 'n' may be negative or beyond the end of Underdog; for any index [n + i] less than 0 or beyond the end of Underdog, no interaction will happen. 

<i>Overlaying of one matrix on another:</i>  Exactly two pointers must be supplied; the first is the row pointer, the second the column pointer. If these have values 'r' and 'c', then Overlay[i, j] will overlay Underdog[r + i, c + j]. The values of 'r' and 'c' may be negative or beyond the extent of Underdog rows / columns; for any index [r + i, c + j] out of range, no interaction will happen. 

<i>Overlaying of a row vector or a column vector across a matrix: </i>  This time there are <i>no pointer arguments</i>; the overlaying always starts at Underdog[0, 0]. If Overlay is a row vector, then the operation will occur between it and each row of the matrix; and analogously for column vectors. There must be an exact match between the length of Overlay and the row / column length of Underdog.
(NB: If you want to overlay a row vector on just one row of a matrix, use the method above this one; a row vector is also a matrix. The program distinguishes between the two cases by the number of arguments you supply.)


Example with two list arrays:
<# blue>\tunderArr = data(100, 200, 300, 400, 500);
<# blue>\toverArr = data(1, 2, 3);
<# blue>\tresult1 = overlay(underArr, overArr, '+', 1);  <# magenta>// --> [100, 201, 302, 403, 500] 
<# blue>\tresult2 = overlay(underArr, overArr, '+', -2);  <# magenta>// --> [103, 200, 300, 400, 500] 

<# black>Example with two matrices:
<# magenta>\t// Produce a 3x3 base matrix:
<# blue>\tunderMx = data(100, 200, 300, 400, 500, 600, 700, 800, 900);    redim(underMx, 3, 3);
<# magenta>\t// And a 2x2 overlay matrix:
<# blue>\toverMx = data(1, 2, 3, 4);    redim(overMx, 2, 2);
<# blue>\tresult3 = overlay(underMx, overMx, '#', 1, 0);
<# magenta>\t// This produces matrix  [100, 200, 300;   1, 2, 600;   3, 4, 900 ].

<# black>Example of a matrix-row operation:
<# blue>\tMx = fill(12, 1, 1);   redim(Mx, 3, 4);  <# magenta>// --> matrix [1, 2, 3, 4;  5, 6, 7, 8;  9, 10, 11, 12]. 
<# blue>\tRowVec = rowvec(100, 200, 300, 400); <# magenta>// Must have length = the row length of Mx.
<# blue>\tNewMx = overlay(Mx, RowVec, '+'); <# magenta>// --> matrix [101, 202, 303, 404;    105, 206, 307, 408;    109, 210, 311, 412].   

============================================================
//PAD//
//TRUNCATE//
//LOP//
<B>PADDING AND TRUNCATING ARRAYS</B>

<B>pad</B>(<# blue>array InArr,  scalar DesiredLength, array or scalar PadValue [, bool AndTruncateIfLonger ]<# black>) -- returns a list array (which we shall call OutArr), whatever the structure of InArr.

If InArr is shorter than DesiredLength, OutArr will contain it + as many pad values as necessary to reach DesiredLength.

If PadValue is an array, its first element is taken as the pad value. If InArr is longer than DesiredLength, OutArr simply copies it unless the 4th. argument is present and nonzero, in which case it is trimmed to DesiredLength. (For truncating only, without padding shorter arrays, see fn. "truncate(.)" below.).

OutArr has the same characters rating as InArr.

This function can take an 'empty' array as its argument (i.e. an array of length 1, content NaN), in which case the whole returned array will consist of PadValue. (Fails in the unlikely event that DesiredLength is 1.)


<B>truncate</B>(<# blue>Array, scalar DesiredLength<# black>) -- returns a copy of Array, truncated to the desired length. (If Array is shorter, it is returned in toto.)


<b>lop</b>(<# blue>Array,  scalar HowMany [, scalar MinimumLength ]<# black>) -- returns a copy of the data of Array (ignoring its structure) with HowMany elements removed from the end. If MinimumLength is present and ≥ 1, the data will not be lopped shorter than that. Otherwise it is possible to remove all elements, in which case the 'empty' array [NaN] is returned. The 'chars' rating of Array is transferred to the returned array.  No errors raised by inappropriate arguments; negative scalars taken as 0.


============================================================
//PAINTSHAPE  --  see PLOTSHAPE
//PALETTE --  see COLOUR
============================================================
//PAUSE//
//PAUSABLE//
//DELAY//
<B>INTRODUCING A DELAY</B>

<B>Wait for a specified period</B>
Simply use a timer, with a 'while' loop waiting for the gong.
\t<# blue>starttimer(2); <# magenta>// Timers are numbered from 0 to 9. We chose no. 2.
\t<# blue>while (timer(2) < 1000){ } <# magenta>// After a 'startimer(.)' call, a timer counts up from 0 (msecs.), till the next 'starttimer(.)' call resets it.

<B>Pause the program at a break point</B>
When trouble-shooting a long-running program it is useful to be able to pause the program at a given point, while you check values of variables and perhaps alter them. (You can display values of scalars, arrays and lists in the main program from the menu; you can also display scalars and arrays in the main program <I>and</I> in the currently active user function, if the break point is in that function, by keying F1 while the cursor is at the variable name in the Assignments Window.)

Use the function <B>pause(n)</B>, where n is any value from 0 to 9. (The empty instruction "pause()" is equivalent to "pause(0)", as with other system functions.)

Simplest use: Just insert "pause()" or "pause(0)"  to create a break point:
\t<# blue>if ( mod(cntr, 1000) == 0) { pause(); } <# magenta>// Click on 'GO' to continue the program.

<# black>Note that when a program is paused, the form title has " [PAUSED n]" after the program file name; this replaces the suffix " [RUNNING]" that normally follows the file name during program execution. Also, the line containing the active pause will now have a special colour, for easy identification. (You can search for this coloured line by using the scrollbar or the up / down keys, but long range keypresses  like PageDown and PageUp will remove the special colouring, as will any text change.)

<# black>The numbered pauses are useful where you don't want the pause to be activated until a certain stage has been reached. "pause(0)" is activated automatically at startup, but "pause(1)" to "pause(9)" are not. You can set the activation state programmatically or from the keyboard. 

<B>Setting activation using the keyboard:</B> You can toggle all ten of the pauses between activated and inactivated state using the double keypress [Cntrl-Shift-P] + [0 to 9]. (Make sure that focus is in the Assignments Window first, or the keypress will have no effect.)

<B>Setting activation programmatically:</B>  The function <B>pausable(.)</B> allows you to activate or inactivate pauses (two-argument version), or just to check the present activation status (single argument version):
\t<# blue>canpause = pausable(8);  <# magenta>// Is pause no. 8 activated? Returns 'TRUE' (1) or 'FALSE' (0).
\t<# blue> pausable(8, TRUE);  <# magenta>// Pause no. 8 is activated. (Returns 1.)
\t<# blue> pausable(0, FALSE);  <# magenta>// Pause no. 0 is inactivated. (Returns 0.) 
<# black>( Where there is a second argument, it is only interpreted as 'false' if it is exactly zero.)

Don't forget that you can also halt a program during operation simply by clicking on the 'GO' button; this offers the opportunity to pause the program, though at an unpredictable point. While it is so halted you may wish to activate or inactivate one of the above break points, before continuing the program.
============================================================
//PECK -- see SUBSTITUTE
============================================================
//PERTURB//
<b>PERTURB VALUES IN AN ARRAY IN A GAUSSIAN MANNER</b>

Suppose you have an array InArray of values, and you want to perturb these, using a Gaussian random number generator, in accordance with some standard deviation SD. Moreover, suppose you don't want these values to deviate more from the mean than a given amount (which, for example, may be 3 x SD). The perturbed version, OutArray, would be developed as follows:
	<# blue>OutArray = perturb(InArray,  SD,  MaxDeviation);<# black>
Note that the first argument must be an array, and the remaining arguments must be scalar and \> 0.
Caution: Gaussian values are first generated and then tested for lying within ± MaxDeviation of the InArray value. This testing is done in a loop, which bravely soldiers on until a value within limits is generated. Consequently if you make MaxDeviation much less than SD, you will need to go for a coffee break while waiting for the result.

See also function <b>randgauss(.)</b>.
============================================================
//PERSISTENT_ARRAY//
MonoMaths sets aside an internal array which can be set or read by the user via function <# blue>persistent_array(.)<# black>. It is always initiated to the empty array (length 1, content NAN) when the MonoMaths instance starts up; it is never altered again by MonoMaths, apart from by the use of this function, and so persists across any number of user program runs.

<b>To set the persistent array</b>
Just call the VOID function <# blue>persistent_array(DataArray)<# black>. The fact that the argument is an array tells the function that this call is to set the internal array.

<b>To get the persistent array</b>
Call the function with NO argument (or a scalar argument), which makes it NONVOID:  <# blue>arr = persistent_array();<# black>

============================================================
//PGM_LOAD -- see EXEC
//PIXELS -- see ANIMATE
============================================================
//PLAYSOUND//
//SOUND//
<B>playsound</B>(<# blue> FileName[,  bool WaitTillSoundFinished ] <# black>) -- plays a recorded sound (typically a .WAV file) stored at FileName. If the file is not found or is not playable, no error is raised but no sound occurs.

If 'WaitTillSoundFinished' is present and nonzero, program operation stops till the sound is finished; otherwise the program continues on while the sound is occurring on another thread. Normally you don't want this wait; but you have to use it if you are going to queue sounds, as otherwise the only sound you will here will be the last in the queue. 
============================================================
//PLACE//
//PLACES//
//PLACEMENT//
The scenario: You have a <i>reference array</i> containing values sorted in ascending order. You also have some new value, and you would like to know where it might fit into the sorted array, if it were to be inserted there. The function to use is:

<b>placement</b>(<# blue>scalar / array Value,  array RefArray [, scalar StartIndex ]<# black>) -- returns a set of placements for each of the values in Value; the returned structure has exactly the same dimensionality as Value.

It is <b>vitally important that RefArray be sorted</b>, in ascending order. There is no test for this; you will simply get meaningless results if you don't observe the rule. Duplications are tolerated, but for all i \> 0 it must be true that RefArray[i-1] ≤ RefArray[i].
There is no such restriction on Value; however if Value is even approximately in ascending sorted order, operation is many times faster. (This is because internally the placement of Value[i] starts from the placement of Value[i-1] if it is found that Value[i] \> Value[i-1].)

These placements take the form of virtual indexes, for which fractional indexes are possible. Suppose Value[i] is V. Then if V = RefArray[N], the return will be N; but if V is halfway between RefArray[N] and RefArray[N+1], the return will be (N + ½).

More exactly, here are the rules. Suppose we have a Value element V; we define 'result' as what will be returned for V. 
<bullet>If V  \< RefArray[0],  then return = NEGINF.
<bullet>If V = RefArray[N],  then return = N.
<bullet>If V \> RefArray[N]  but  V \< RefArray[N+1],  then return = N +  (V - RefArray[N-1]) / (RefArray[N] - RefArray[N-1] ).
<bullet>If V  \> the last element in RefArray,  then return = POSINF.

If <i>StartIndex</i> is supplied, then the search for all elements of Value begins only at that index of RefArray. 
This argument needs some care. If StartIndex is fractional, it is adjusted to the nearest integer below. If StartIndex is negative, it is adjusted to 0.
If you are going to use this argument, be careful to ensure that it is definitely lower than a possible placement; otherwise it will return NEGINF. For example, if RefArray is [10, 20, 30], and Value is 25, then a StartIndex of MINREAL to +1.9999... will return a placement of 1.5; but a StartIndex of 2 or more will return NEGINF. 
If RefArray is large, the use of StartIndex will give a huge improvement in performance.

Two more points:
<bullet>Duplications within RefArray are not a problem; simply the duplicated values will be hopped over. For example, if RefArray where [10, 20, 20, 20, 30], then V = 15 would return 0.5,  V = 20 would return 1, V = 25 would return 3.5.
<bullet>If Value has been mathematically derived, then tiny numerical rounding errors may have pushed some value that should be, e.g. 10, to being 10 ± 1e-15. To allow for this, any value closer to RefArray[N] then <b>1e-10</b> is regarded as equalling RefArray[N]. This is particularly important if V should equal either the first or last element in RefArray, as a slight numerial error taking V from RefArray[0] to, say, RefArray[0] - 1e-15, would return NEGINF rather than the logically expected 0.

The inverse function is <b>interpolate(.)</b>  (version 1). An example of the use of the two together is given at the end of this window.

See also function 'readtable'.

Two other functions exist; <# red>they are now deprecated, and should not be used in future programming, as they will certainly be removed in the near future.<# black>

<B>place</B>(<# blue>Array, Scalar LowLimit[, Scalar HighLimit]<# black>) -- returns the index of the first array element which is at or above LowLimit and also at or below HighLimit. (If HighLimit is not supplied, there is no upper limit to be satisfied.) Returns -1 if no array value is in range.

<B>places</B>(<# blue>Array, Scalar LowLimit[, Scalar HighLimit]<# black>) -- differs from the above in returning an array of size 6, which contains more information. If we call a value 'in range' if it is at or above LowLimit and also at or below HighLimit, then array values have the following meanings: [0] = index of first value in range (= the same that 'place(.)' would return). [1] = index of last value in range. (If no values are in range, both return as -1.)   [2] / [3] = the number of values <I>between these indexes</I> which are below / above range;  [4] / [5] = the number of values <I>throughout the whole array</I> which are below / above range.

<# blue>\tarr = data(-100, 100,  1, 2, -100, 100, 100,  3, 4, 5); 
<# blue>\tpls = places(arr, 1, 3);  writeln(pls);  <# magenta>// -->  pls = [2, 7, 1, 2, 2, 5]
<# black>

				_______________________________________________________

<b>Using functions <# blue>placement<# black> and <# blue>interpolate<# black> together</b>
In modelling neuronal synaptic effects, sometimes you have an action curve which has rapid changes for a few milliseconds but then slowly settles over several minutes, or even hours, to its original rest value. The very long tail is almost linear. The modelling system typically needs a sampling time of 0.1 to 1 msec to follow rapid changes in the system being studied; in such a case, using (as I usually do) 0.1 msec as the time quantum, to store a long-tailed curve lasting one hour would require an array length of 36 million. Much better to store the rapidly-changing part at 0.1 msec intervals, but the long linear tail at e.g. ten minute intervals and interpolate for intermediate values.

To exemplify the process, suppose we have a curve with the following coordinates, X being evenly distributed (corresponding to X axis scale graduations).
<stops 30>
X:	0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
Y:	0	5	10	8	6	5	4.5	4.4	4.3	4.2	4.1	4	3.9	3.8	3.7	3.6	3.5	3.4	3.3	3.2	3.1

Notice that all the action occurs from X = 0  to X = 6; for the rest of the array Y, variation is completely linear. So I could set up two new arrays which condense down the linear stretch:

X1:	0	1	2	3	4	5	6	20
Y1:	0	5	10	8	6	5	4.5	3.1

Suppose, then, that I want to know what is the value of Y when X = 16?
First I would retrieve the required value of X from X1 using function <b>placement</b>:
	<# blue>X = placement(16, X1);<# black>
This would return (6 +  10/14), i.e.  6.714...
Next I would interpolate within Y1 to retrieve Y:
	<# blue>Y = interpolate(X, Y1);<# black>
This would return 3.5, which we can see from the X, Y table above is the correct value.





==================================================================
//PLACEBOARD -- see GRAPHRESIZE
==================================================================
//PLOT//
//PLOT3D//
//PLOTMESH//
//PLOTMESH3D//
//GRAPH//
//GRAPH3D//
<just c><B>GRAPHING -- 2D and 3D</B>

<just l><U>GRAPHING DURING THE PROGRAM RUN</U>
Graphing in two dimensions (2D) is described first. Graphing in 3D is basically the same; a section at the end of this 'help' page deals with the differences.

There are two stages to displaying a graph. First you define a 'plot' and assign it to a scalar variable. Then you define a 'graph' - the axes and other adornments - in which the graph will be displayed, also (usually) assigning it to scalar variable. As you define this graph you (usually) pass the plot to it as an argument.

The plotting functions for 2D are:  <B>plot(.), plotmesh(.), plotshape(.).</B>
The plotting functions for 3D are:  <B>plot3d(.), plotmesh3d(.).</B>

Here is a simple example:
\t<# blue>xx= data(0,1,2,3,4);
\t<# blue>yy=xx*xx;
\t<# blue>p = plot(yy,xx); <# magenta>// xx holds horiz. axis values, yy holds corresponding vert. axis values.
\t<# blue>g = graph(p);

<# black><U><B>FUNCTION  plot(..)</B></U>
This takes at least one argument, but can take up to twelve arguments, depending on the amount of sophistication you want in your plot. The function returns a unique scalar identifier:

\t<# blue>p  =  plot(<# red>YValues,  XValues,  <# green>PointType, PointWidth, PointColour, <# magenta>LineType, LineWidth, LineColour,
\t\t\t\t\t\t<# orange>PointFamily, LineFamily,  <# brown>Texts, FontName);

<# black><B>Arguments</B>

<I>YValues, XValues:</I>  Usually two arrays of equal length, the first holding the vertical axis values and the second holding the horizontal axis values.

Four other variants are allowed: 
(1)  <I>YValues and XValues are both scalar</I>: The plot will consist of a single point.
(2)  <I>YValues is an array, and is the <b>only</b> argument</i>:   A machine-generated array will be used for the horizontal axis values, starting from 0, and adding 1 on each time (so the generated array is: [0, 1, 2, 3, ...] ). Used where you want an instant but unadorned survey of the array.
(3)  <I>YValues is an array, but XValues is scalar</I>: As for (2), but the machine-generated array starts at XValues (incremented again by 1 each time). This has the advantage over (2) that further arguments can be supplied to make the graph more visually presentable.
(4)  <I>Both are arrays, but they are not equal</I>: Whichever is shorter will be recycled, leading to curve duplication either in the X direction (YValues shorter) or in the Y direction (XValues shorter).  HINT: The first may be a matrix, its <i>row</i> size being the size of XValues. In that case you will get a family of curves, maybe corresponding to different values of some parameter. <i>However</i> the last point of one curve will be joined to the first point of the next - not very nice. To avoid this, use 'plotmesh' instead (see below).

<I>PointType:</I>
Determines the shape of the point. Supply a single character, which is one of the following:
<bullet>' . ' (fullstop) -- a dot (solid circle).  This is the default for the two argument form "plot(yy, xx)".
<bullet>' o ' (small letter 'O', not a zero) -- an outlined circle.
<bullet>' O ' (capital letter 'O') -- a thicker outlined circle.
<bullet>' [ '  --  a solid square. 
<bullet>' ] ' -- an outlined square.
<bullet>' x ' -- a cross. 
<bullet>' X ' -- a thicker cross.
<bullet>' + ' -- a plus sign.
<bullet>' # ' -- a thicker plus sign.
<bullet>' $ ' -- display some text (see below re how to assign the text).
<bullet>'    ' (a space) -- points will not be visible.  (Any unrecognized character has the same effect.)
<bullet> scalar 0 -- points also not visible, but also completely skips the point-plotting loop in MonoMaths, so saving time.

This argument may be scalar; if so, it should be the unicode value for one of the above.

<I>PointWidth:</I>
The number of pixels per side of the shape's containing square. The default is 3. (Where characters are plotted, PointWidth is the font size instead.)

<I>PointColour:</I>
You can specify colour in several different ways.
<bullet>Use a standard colour name (e.g. 'blue'). There are 141 names currently stored; they are those recognized by .NET. Letter case is not important. To see the list, with demonstration of the colours, enter 'colour' into the Assignments Window, select it, and then press the F1 key. Scroll to the bottom of the message box that appears.
<bullet>Use a scalar value, which will be taken as an index to the system palette, as explained below. Or directly use the function itself...
<bullet>System function "palette(n)" to return one of 10 colours in the system palette. ('palette(.)' returns a chars. array holding the colour name.) The modulus of the rounded absolute value of 'n' is used, so that out-of-range values do not cause a crash. Colour names returned for different values of 'n' are: <# blue>0:"blue"; <# red>1: "red";  <# green>2: "green";  <# orange>3: "orange";  <# magenta>4: "magenta";  <# darkviolet>5: "darkviolet";  <# deepskyblue>6: "deepskyblue";  <# brown>7: "brown";  <# grey>8: "grey";  <# black>9: "black"; <# black>10: "white". 
<bullet>Use a hexadecimal number, exactly 6 digits long, prefixed by "0x" - e.g. "0xff00ee". Letter case not important. (The initial '0' is the cipher zero, not the letter 'o'.) The first two digits ("ff" in the example) are for the red component, the next two for the green, the last two for the blue component.
<bullet>Use a <I>non-</I>character row vector of length 3 ( i.e. matrix 1 x 3); then it will be interpreted as an opaque RGB colour - [0] holding the red value, [1] the green, [2] the blue. E.g. 'rowvec(255, 255, 0)' would give you yellow points. Each value must be in the range 0 to 255.

<I>LineType:</I>
Determines the form of the line. Supply a single character, which is one of the following:
<bullet>' _ ' (an underscore) -- a continuous line. 
<bullet>' - '  (a dash) --  a dashed line " - - - - ". 
<bullet>' . ' (a fullstop) -- a dotted line  ".........".
<bullet>' ! ' -- a line of alternating dots and dashes:  " -.-.-.-.-". 
<bullet>' : ' -- a 'dash-dot-dot' sequence:  "-..-..-..-..-".
<bullet>'    ' (a space) -- no line at all.

<I>LineWidth:</I> 
The width of the line, in pixels. The default is 1.

<I>LineColour:</I>
As for PointColour above.

<I>PointFamily and LineFamily</I>
Not often needed, but valuable when they are. Suppose you want some points and/or connecting lines to look different to others. For example, you want points to be alternately shaped like a cross 'x' or like a circle 'o'. For the PointType field use a 2-character array with the two point shape cues as listed above: "xo". Then set PointFamily to to the array 'data(0,1)':
\t<# blue>xx= ladder(11, 0, 1);   yy=xx*xx;
\t<# blue>p = plot(yy,xx,  "xo", 10, 'red',   '_', 1, 'blue',  data(0,1)); 
\t<# blue>g = graph(p);

<# black>To make the graph look even uglier, make every third connecting line a dotted line:
\t<# blue>xx= ladder(11, 0, 1);   yy=xx*xx;
\t<# blue>p = plot(yy,xx,  "xo", 10, 'red',   "__.", 1, 'blue',  data(0,1),  data(0,1,2)); <# magenta>
\t<# blue>g = graph(p);

<# black>It might seem from these that there is no point in the fields PointFamily and LineFamily; all you need to do is to add more elements to PointType and LineType. Not so. These arrays PointType and LineType are <I>data bases</I> of the available types; the actual <I>deployment</I> of the types is the duty of arrays PointFamily and LineFamily. For example, suppose you want points to be shaped 'x' if y is 0.5 or less, and 'O' if greater. You could work like this:

\t<# blue>xx= ladder(11, 0, 1);   yy=xx*xx;
\t<# blue>ptfamily = is(yy, 0.5); <# magenta>// ptfamily is now { 0, 0, .., 1, 1, ...}
\t<# blue>p = plot(yy, xx,  "xO", 10, "red",   '_', 1, "blue",  ptfamily); <# magenta>
\t<# blue>g = graph(p);

<# black>What is happening is that MonoMaths is counting points as it plots them; at the nth. point, it looks in ptfamily for the nth. value, which in this case will be either 0 or 1. If it is 0, then PointType[0] is accessed; if 1, PointType[1] is accessed.

You can do this with colours also; only this time you separate colours by the vertical divider '|'. This is a rehash of the above, but this time with points being red if y is 0.5 or greater:

\t<# blue>xx= ladder(11, 0, 1);   yy=xx*xx;
\t<# blue>ptfamily = is(yy, 0.5); <# magenta>// ptfamily is now { 0, 0, .., 1, 1, ...}
\t<# blue>p = plot(yy, xx,  'x', 10, "blue|red",   '_', 1, "blue",  ptfamily); <# magenta>
\t<# blue>g = graph(p);

<# black>Here, more formally, are the rules for PointFamily:
<bullet>If PointFamily is supplied, and has length L, then when the nth. point is being plotted MonoMaths will reference PointFamily[n modulo L]. (The effect of the modulus is to recycle values in PointFamily; that is why, in order to alternate point types, we supplied just a two-valued PointFamily.)
<bullet>Once some value  ndx = PointFamily[..] has been extracted, MonoMaths will then look at each of the three fields PointType, PointWidth and PointColour; and it will use PointType[ndx modulo {length of PointType}],  PointWidth[ndx modulo {length of PointWidth}],  PointColour[ndx modulo {no. of colours in PointColour}]. (If PointWidth or PointColour is scalar, the effect will be the same as if it was an array of length 1; i.e. the same value will be used for every point.)

Warning: don't use scalar 0 in array PointType; if PointType[0] is 0, then no plotting of any points occurs, whatever is the value of PointFamily. This problem doesn't arise if you use the space character in PointType[i] to indicate that some points should not be plotted. 

The rules for LineFamily are exactly analogous. 
If you want to set LineFamily but don't want to vary points, simply use a dummy scalar value for argument PointFamily, e.g. 0.

 
<I>Texts:</I>
If you supplied '$' as the point type, then this argument will be accessed to find out what text to place on the graph. If you want the same text for each point, just use a single text, e.g. "hello". If you want successive points to have different texts, separate entries with the vertical bar '|'. For example, if you have five points and want them to be numbered, you would use the string "1|2|3|4|5". As with PointFamily, recycling occurs, so that if you had ten points with this value of Texts, then the sixth point would display "1" again.
(It is permissible to have adjacent delimiters: "1||3|4". The program will not try to display text at the second of the four locations, in this case.)
Here is an example, which prints the numbers 1 to 12 for a clock face:

\t<# blue>angle = fill(12, 60, -30); <# magenta>// angle in degrees: 60, 30, 0, -30 ...  - for placement of numbers 1 to 12.
\t<# blue>angle = rad(angle); <# magenta>// convert from degrees to radians.
\t<# blue>xx = 0.95 * cos(angle);   yy = 0.95 * sin(angle); <# magenta>// The factor ensures that the numbers fit fully onto the graph.
\t<# blue>p = plot(yy, xx, '$', 16, 'red',  ' ',0,0,   0,0,  "1|2|3|4|5|6|7|8|9|10|11|12"); <# magenta>// no lines, just points.
\t<# blue>g = graph(p);
\t<# blue>graphresize(g, 500, 500); <# magenta>// just to make the clockface circular rather than elliptical.
<# black>
If you want a different delimiter (because you would like '|' to be printed as part of some text), then prefix the string with these three characters: "}c{" - where 'c' is replaced by any character you would like to use as the delimiter instead. E.g. "}‖{string1‖string2‖string3".

<# black><I>FontName:</I>
Supply the name of a font that is on your system. You can use a comma-separated list of font names in the order of your preference (most preferred first); if the first is not present, the 2nd. will be used; etc.  E.g. you could use: "Comic Sans MS, Arial, Verdana, Sans".


<# black><U>FUNCTION  <B>graph(..)</B></U>
Once you have generated one or more plots as above, you can make them visible with this function, which generates a single graph containing one or more plots, and returns a unique graph identifier:

\t<# blue>g  =  graph(any number of plot identifiers);

<# black>Arguments may be any mix of scalars and arrays; in other words, if you have generated lots of plots and it pleases you to store their identifiers in arrays, then you are free to use such arrays as arguments. If you supply no arguments at all, or if none of the plot identifiers turn out to be valid, a blank graph will result.

<U>CHANGING GRAPH VISIBILITY</u>
<b>graphvisible</b>(<# blue>scalar GraphID [, bool NewVisibility ] <# black>) -- Always returns the final visible status of the graph as 'true' or 'false'. If NewVisibility is present, then 'true' forces the graph to be visible, 'false' forces invisibility. If no graph GraphID exists, the function returns 'false' (with no indication that the graph does not exist).

<U>SETTING THE SCALE, POSITIONING THE HAIRLINES</u>
As in the example at the start, you can leave it to the program to generate its own values for the axis limits and the number of hairlines. But more usually you would control these using the functions <B>gridx(..)</B> and <B>gridy(..)</B>, or the function which combines these two, <B>grid(..)</B>.

The syntax is as follows. 'graphID' is the number returned by the 'graph(..)' function above; 'lo' and 'hi' represent values at the low and high end of an axis, and 'segmts' the number of segments into which hairlines should cut the axis extent:
\t<# blue>gridx(graphID, lo, hi, segmts ); <# magenta>// Set the X-axis extremes and hairlines
\t<# blue>gridy(graphID, lo, hi, segmts); <# magenta>// Set the Y-axis extremes and hairlines
\t<# blue>grid(graphID, Xlo, Xhi, Xsegmts, Ylo, Yhi, Ysegmts); <# magenta>// Set for both axes at once.
<# black>(Note that 'lo' does not have to be less than 'hi'; reversed order is allowed on axes. However the two values must not be equal, and 'segmts' must round to 1 or more.)

Obviously the graph will have to be drawn twice by using these functions: first, at creation, it will use default axis parameters, then it will be redrawn using your supplied grid values. This usually happens far too fast for you to notice.  If you want to avoid this double-dealing, in the case of 'grid(.)' alone you can omit the graphID, and place the instruction just before the graph definition.

Although the grid functions are usually used in a void manner, as above, they do return an array. If there is no error, it simply holds the values of the arguments (not including the graph ID). For an error it has length 1, value NaN; and a call to 'empty(.)' would return TRUE.

<U>HIDING THE HAIRLINES</u>
You can choose to have full hairlines (the default), or hairlines reduced to just stubs on the axis, or no hairlines or stubs. The function is <b>showhairlines</b>(<# blue>GraphID, scalar HowX [, HowY [, HowZ ] ] <# black>). If e.g. HowX is zero, the graph's X axis will have no hairlines or scale markers; if 1, no hairlines but small scale markers will occur where hairlines would go; if 2 (the default) - or any other value - full hairlines are present. Note that scaling strings at hairline locations are not affected by this function.

<U>TEXT EMBELLISHMENTS</U>
For all of the following text functions, the first argument must be the graph ID.

You can display a <b>window title</b> in the blue upper border of the window, using <b>graphtitle(GraphID, array TheTitle)</b>. The main point of doing so is so that the same title will appear in the panel button representing the graph, vital if there are many graphs present at once (otherwise you have a row of empty buttons in the panel). Note that there are exactly two arguments.

You can apply <B>heading text</B> to the top of the graph using the nonvoid function <B>header(GraphID [, array(s) / scalar(s) Text] )</B> . The composition of 'Text' is exactly as for the argument(s) of functions 'write(.)' and 'show(.)', with the proviso that different rules apply for formatting tags, as the underlying Gdk uses Pango tags only.  You can use the following: \<b> ... \</b>, \<u> ... \</u>, \<i> ... \</i>, \<^> ... \</^> (for superscript), \<v> ... \</v> (subscript).  (Exact pairing is essential, as these are translated into Pango tags - which you would have to google, for details. You can actually use any other Pango tags, but I do not list them here.) 
If GraphID is not identifiable, this function returns the 'empty array' (size 1, value NaN; testable with function 'empty(.)' ). Otherwise, it ALWAYS returns the current heading. If the only argument is the graph ID, the last set heading for this graph is returned, and nothing is changed. Otherwise what is returned is exactly what you have just put in (probably not very useful).

You can put <B>explanatory text under the graph</B> using the nonvoid function <B>footer(.)</B>.
There are two forms:
<i>footer(GraphID, <some text>)</i> -- where 'some text' is any mix of arrays and scalars, and is treated exactly as is the argument of 'write(.)' or 'show(.)'. All of the MonoMaths tags are allowed here; to see the options, type 'format' into the Assignments Window and key F1; or consult main menu item "Help | Formatting with Text Tags". (If 'some text' consists of a single scalar argument, it is treated as the second form instead.)
Normally no cursor is visible in the footer, though it is editable, so that if you type, characters will appear there. If the values "<some text>" begin with exactly the three unicodes of "|+|", then the cursor will be made visible. It will remain visible with further calls to 'footer(.)' for this graph, until a call for which "<some text>" begins with "|-|", switching cursor visibility off. (In both cases, these three initial characters will not be displayed.)

<i>footer(GraphID [, bool FinalVersion])</i> -- returns the existing footer for the graph. If FinalVersion is absent or 'false', the value is the last that was set for this graph using this function 'footer'. It will be complete with any formatting tags. If FinalVersion is 'true', (a) what you get back is whatever is <i>now</i> displayed on the graph; the user may have altered this by typing directly into the graph (as the footer is editable, even though no cursor is visible); and (b) whether altered or not, what you get back is <i>bare text</i>, devoid of all (valid) inserted formatting tags.
If GraphID is not identifiable, this function returns the 'empty array' (size 1, value NaN; testable with function 'empty(.)' ). Otherwise, it ALWAYS returns a chars. array. For the first form, this is simply what you have just put in (probably not very useful).

You can add a few words beside the scale markings to explain what the scale is - e.g. 'miles per hour' - using void functions <B>labelx(.)</B> and <B>labely(.)</B> (for X and Y axes respectively). No formatting tags are valid here. If you use the function with only the one argument - the graph ID - then the function is no longer void, but returns whatever is the current axis label.

<U>MODIFYING THE GRAPH BOX - SIZE, POSITION, COLOUR</U>
By default, graphs have a size much smaller than the full screen, and can end up anywhere on the screen according to an algorithm which is part of .NET. You can of course tow a graph away with the mouse, or drag its borders around, or minimize or maximize it, or close it down, as with most other Windows windows. But you also have some programmatic control over things:

<B>Size the plot surface</B> of the graph (i.e. excluding headers, scaling etc.) using function <B>graphresize(<# blue>GraphID, PixelsWide, PixelsHigh<# black>)</B>. This is especially useful if you want the plot surface to be exactly square, for example to correctly show angles, or to make a circle not look like an ellipse. Both arguments must be > 20, or else no resizing occurs. You may have to experiment, as Mono's Gtk sometimes disagrees with your values by a few pixels, and ignores them if they are too large. (If you are more interested in the size of the whole form holding the graph, use function <i>boardresize(.)</i> instead.)

<B>To change the screen position</B> and size of the whole form containing the graph, use function <B>placeboard</B>(<# blue>Scalar GraphID, Scalars Left, Top, Width, Height<# black>). Values <= 1 are taken as a fraction of screen width or height; values > 1 as pixels. To produce a full-screen graphing form, use arguments { GraphID, 0, 0, 1, 1 }. You can retrieve the current values using function 'boardplacemt(.)'.

<b>To change colours</b> of graph features, use function<b>graphcolours(<# blue>GraphID, 0 to six colour arguments  in the order given below<# black>)</B>. A colour is ignored where the corresponding argument is absent or is a scalar, as only arrays are accessed. Such arrays would usually be colour names (e.g. "light blue"), but enter 'colour' and key F1 for other possibilities. The function always returns a matrix 6x3, each row being the RGB values of the colour of the corresponding graph item (whether altered or not). The six colours in order are of the following (indexes refer to matrix rows): [0] -- the plotting surface (background to the curves);  [1] -- the hairlines;   [2]: the thin line forming the perimeter of the plotting surface;  [3]: the background outside the plotting surface, where scaling information goes;  [4]: scaling text at hairlines ("10, 15, 20, ...");  [5]: text of axis scale descriptor (e.g. "velocity (kms.)" ).
 
<# black><U>MODIFYING OR OVERRULING AUTOMATIC SCALING</U>
In all of the following functions, <B>the graph ID must be present</B>.
Also, only the X axis versions are described; in each case, change the 'x' in the function name to 'y' or 'z' for use with other axes.

<B>(a) Don't have every hairline labelled.</B>
You can cause some automatic scaling tags to be dropped. Suppose we count the left extreme of the X axis as division 0, and then call the successive hairlines division 1, 2, 3, ... We require that the first hairline to be labelled will be hairline 1, and thereafter every 3rd. hairline: { 1, 4, 7, ...}. The function call is:
\t<# blue>firstLabelled = 1;  hairlineJumps = 3;
\t<# blue>scalejumpx(graphID, firstLabelled, hairlineJumps);
<# black>
<B>(b)  Multiply automatic scaling values by a scaling factor and a suffix</B>
Suppose you are graphing a trigonometric function; the X axis is to extend from 0 to 2 π. You want four segments between these two limits. If you use the function "gridx(0, 2*π, 4), the automatic scale generation will supply these scale tags: "0,  1.571,  3.142,  4.712,  6.283". You can change this to "0 π,   0.5 π,   1 π,   1.5 π,   2 π " using this function call:
\t<# blue>scalefudgex(graphID, 1/π, " π"); <# magenta>// note the leading space before 'π'. You must supply such a space, if you want it.

<# black>But you have two further arguments to refine this.
<bullet>If you want to replace "0 π" with just "0", add a boolean argument:
\t<# blue>scalefudgex(graphID, 1/π, " π", 1);  <# magenta>// Now the scale will be: "0,   0.5 π,   1 π,   1.5 π,   2 π "
<bullet><# black>If you also want to replace "1 π" by just "π", add a second boolean argument:
\t<# blue>scalefudgex(graphID, 1/π, " π", 1, 1);  <# magenta>//Now the scale will be: "0,   0.5 π,   π,   1.5 π,   2 π "

<# black>The program doesn't let you use a scaler (like 1/π here) in the absence of a suffix; this, for example, will achieve nothing:
\t<# blue>scalefudgex(graphID, 1/π, "   ");
<# black>It's not that we don't trust you; it's just that it is too risky - you could make the adjustment to the wrong graph, for example, and have no way of knowing that the scale was actually false. If you <I>must</I> fudge the purely numerical results, you can use method (c) below.

<# black>You can't use formatting tags in 'scalefudgex'. However you can implant special characters (as we did with 'π' above) simply by copy-and-paste from a character source.

<B>(c)  Supply a characters array that overwrites the machine-generated values</B>
The function to achieve this has exactly two arguments - the graph identifier (which cannot be omitted), and the characters array of tags, using commas as separators. (Spaces are significant.)
Suppose that the naturally generated scale numbers were "1, 2, 3, 4, 5". You could alter this as follows:
\t<# blue>scaleoverx(graphID, "cat,dog,rat,hog,bat"); <# magenta>// The scale tags will be: "cat, dog, rat, hog, bat".
<# black>If too few new tags are supplied, naturally generated numbers make up the rest:
\t<# blue>scaleoverx(graphID, "cat,dog,rat "); <# magenta>// The scale tags will be: "cat, dog, rat, 4, 5".
<# black>If too many new tags are supplied, excess tags will be ignored:
\t<# blue>scaleoverx(graphID, "cat,dog,rat,hog,bat,sat,mat,hat"); <# magenta>// The scale tags will be: "cat, dog, rat, hog, bat".
<# black>Empty tags are permitted. For example you could blank all five scaling tags with:
\t<# blue>scaleoverx(graphID, ",,,,");
<# black>An easier shorthand for blanking ALL scaling tags is to supply as argument a single '#' (no blanks):
\t<# blue>scaleoverx(graphID, "#");

<# black>You can't use formatting tags in 'scaleoverx', however as with 'scalefudgex' you can implant special characters simply by copy-and-paste from a character source.

<# black>Function <I>scalejumpx(.)</I> is ignored for the scaling extent which is overwritten by this function.

One other set of functions occasionally of use is <B>scaleformatx(GraphID, char. array)</B>, and the -y(.) and -z(.) equivalents. the array is any format string as recognized by .NET. These are not listed here, save to say that the default is "G4", which allows for 4 significant digits, and presents them either in decimal format or scientific format, whichever is shorter. (1234567 --> '1.235E+06';  123.4567 --> '123.5';  0.1234567 --> '0.1235';  0.00012345 --> '0.0001235'.).


<U>PLOTTING A SET OF CURVES, WITH OR WITHOUT A MESH</U>

(If you don't want a mesh but just a family of curves, you might do better with function <b>plotmx(.)</b>, which is described separately; key F1 with the cursor on the word in the Assignments Window for details.)

You can use the function <B>plotmesh(.)</B> to draw a family of curves, all with the same number of points; if you wish you can also join corresponding points in the different curves so as to develop a mesh. I will describe the case for the mesh; then I will point out how to do away with the joins between curves.
In what follows, the original family of curves is called the 'forward' curves, and the lines that cross-link them will be called the 'transverse' curves.
Here is a simple example, to illustrate the point.
\t<# blue>PtsPerCurve = 5; <# magenta>// The number of points on a 'forward' curve.
\t<# blue>xx = ladder(PtsPerCurve, 0.2, 1); <# magenta>// X-coordinates for the first forward curve.
\t<# blue>yy = xx^2; <# magenta>// Y-coordinates for same.
<# magenta>// Now build two matrices, one for X-coords and one for Y-coords, each with a separate row for each forward curve:
\t<# blue>NoCurves = 3;
\tdim(MX, MY, NoCurves, PtsPerCurve);
\tMX[0] = xx;    MX[1] = xx - 0.02;    MX[2] = xx - 0.05; <# magenta>// We choose to vary the X-coords. slightly for the three curves.
\t<# blue>MY[0] = yy;    MY[1] = yy + 0.1;     MY[2] = yy + 0.2;
<# magenta>// Construct a basic mesh graph - no embellishments:
\t<# blue>p = plotmesh(MY, MX);
\tg = graph(p);
<# black>
If you want corresponding points on  curves to share the same X value, then the second argument need only be a list array of the X values. To see this at work, replace "plotmesh(MY, MX)" in the above code with "plot(MY, xx)".

Here is the full format for function 'plotmesh(.)'. It has exactly the same arguments as function <b>plot</b>(.), but with two extra arguments (underlined). Only the first two arguments are obligatory.

\t<# blue>p  =  plotmesh(<# red>YValues,  XValues,  <# green>PointType, PointWidth, PointColour, <# magenta>LineType, LineWidth, LineColour,
\t\t\t\t\t\t<# orange>PointFamily, LineFamily, <b><u>TransverseLineFamily</u>,  <u>Looping</u></b>,  <# brown>Texts, FontName);

<# black>All arguments in common with 'plot(.)' have exactly the same interpretation as for function 'plot(.)' above. <i>PointFamily</i> and <i>LineFamily</i> apply to all forward curves (there is no way of making different curves appear differently).

New argument <b>TransverseLineFamily</b> applies to lines linking the curves transversely. Again, all transverse curves will be the same as one another.

The other new argument <b>Looping</b> acts as a boolean array. If Looping[0] is 'true' (nonzero), then the forward curves all loop (that is, the last point of each curve is joined back to the first point). If Looping has two elements and [1] is 'true', the transverse curves all loop. (If Looping is scalar, it is ignored, leading to the default - no looping of any curves.)

If you <i>don't want a mesh</i> - just a set of forward curves - set <i>TransverseLineFamily</i> to the array "data(-1)" (NB, not just to scalar "-1"), and unwanted prior values (e.g. point family, line family, if not using them) to -1.

<U>PLOTTING A SHAPE</u>
There are four functions involved; <b>plotshape(.)</b> creates the shape; if necessary, <b>moveshape(.)</b> can later be used to redeploy the same shape, <b>paintshape(.)</b> can change its outline and fill colouring, and <b>copyshape(.)</b> can be used to duplicate the shape. Enter any of these function names into the Assignments Window and key F1 for details of use.

<U><# black>KILLING, REMOVING AND PRESERVING </U>
<B>Does it exist?</B> Two functions for existence are used: <B>isgraph</B>(<# blue>scalar GraphID<# black>) -- if the graph exists, evaluates to 2 (for 2D graphs) or 3 (for 3D graphs). Otherwise returns 0, so can be used like a boolean in conditional statements. And <B>isplot</B>(<# blue>scalar PlotID<# black>) -- which also evaluates to 2 (2D) or 3 (3D), or 0 if nonexistent. 
A third function is useful to find what plots are present in a graph. <B>plotsof(</B>(<# blue>GraphID)<# black>)  returns an array. If the graph exists and has plots, the array length is the number of plots in the graph, and the array elements are the plot IDs. Failure produces an array of size 2. If the graph can't be identifired, the array is [0, -1]; if it can, but the graph has no plots, it is [0, 0]. In general, a sufficient test for a valid outcome is that [0] is not zero.  It is safe to use this inside 'killplot(.)' and 'removeplot(.)'; for example, "killplot( plotsof( graphID));" will not crash, even if the graph or its plots don't exist, and so is a good way to empty the graph of all existing plots (before replacing them with others).

<B>Removing plots</B>. Two functions are used. The first - <# blue>removeplot(GraphID, plotIDs)<# black> - simply removes given plots from a particular graph, but leaves them elsewhere intact and reusable. The second - <# blue>killplot(plotIDs)<# black> - removes all trace of them in memory, including from any graphs currently displaying them. In both cases, the arguments 'PlotIDs' may be any mix of arrays and scalars.

<B>Killing graphs</B>.  You can kill graphs using function <# blue>killgraphs<# black>; see help or hints for its usage.

<B>Preserving graphs between runs</B>. At the end of your program run, the graphs will still be there, but will vanish when next you click on 'GO'. If you want them instead to be preserved, use the menu setting "Graphing | Preserve old graphs...". (On the subject of the graphing menu, note that you can also use it to kill all the graphs that have persisted after the run. This is useful if your run generated, say, ten graphs, and you don't want to be bothered with closing these windows one by one.)


<U>ALTERING EXISTING GRAPHS</U>
You can change the plots on an existing graph, for example to produce animation effects. The subject is too long to put here; read all about it in Help menu item <I>Graphing - Interactive</I>.

<U>COPYING A GRAPH</U>
<B>graphcopy</B>(<# blue>scalar OriginalGraphID, bool UseStartupDimensions<# black> ) -- Draws a copy of the original graph, but without any plots. The graph ID is returned (or 0, if the original graph was not identified). If <i>UseStartupDimensions</i> is TRUE, the new graph will be sized according to the dimensions of the old graph <i>when it was created</i>. (In the case of 3D graphs, it will also revert to the original graph's startup cage orientation.) If you want to reproduce any changes to that size (as produced by dragging the old graph's margins, or by funtion 'graphresize(.)'), set this argument to FALSE. (In this case, be warned that if there is less than around 0.1 seconds between a call to 'graphresize(.)' on the original graph and a call to this function, the new graph will not reflect that graph-resize operation. I have tried various tricks to overcome this quirk of the underlying Gtk drawing system, but have so far failed.)

_______________________________

<B>GRAPHING IN 3D</B>

The functions involved are <B>plot3d(.), plotmesh3d(.)</B> and <B>graph3d(.)</B>.

They take exactly the same arguments as <B>plot(.), plotmesh(.)</B> and <B>graph(.)</B>, <I>except</I> that 'plot3d' and 'plotmesh3d' start with three array arguments, rather than two:

\t<# blue>p  =  plot3d(<# red> <b><u>ZValues</u></b>,  YValues,  XValues,  <# green>PointType, PointWidth, PointColour, <# magenta>LineType, LineWidth, LineColour,
\t\t\t\t\t\t<# orange>PointFamily, LineFamily,  <# brown>Texts, FontName);

\t<# blue>p  =  plotmesh3d(<# red> <b><u>ZValues</u></b>,  YValues,  XValues,  <# green>PointType, PointWidth, PointColour, <# magenta>LineType, LineWidth, LineColour,
\t\t\t\t\t\t<# orange>PointFamily, LineFamily, TransverseLineFamily,  Looping,  <# brown>Texts, FontName);

<# black>Only the initial three arguments are obligatory; any number of remaining arguments can be supplied.

In the case of <b>plotmesh3d(.)</b>, <i>ZValues</i> must always be a matrix, dimensioned as (no. of forward curves x no. of points per curve). <i>XValues</i> and <i>YValues</i> may also be matrices of the same dimensions. However if you are content for the lines of the mesh to be strictly and regularly aligned with the X and Y axes - so that a vertical view of the mesh from above the XY plane will appear like a piece of graph paper - then <i>XValues</i> can be an array with one value per forward curve (forward curves being those which start from the X axis and are in a plane parallel to the ZY plane), and the <i>ZValues</i> can be an array with one value for corresponding points on all forward curves. In other words, the length of <i>XValues</i> must be the number of <i>rows</i> in <i>ZValues</i>, and the length of <i>YValues</i> must be the number of <i>columns</i> in <i>ZValues</i>. 

<# black>See above for all the details of the remaining arguments.

<U>Setting the axis limits and hairlines</U> uses the function <B>grid(.)</B> exactly as for 2D graphing, but with the obligatory addition of three extra arguments:
\t<# blue>grid([graphID,] Xlo, Xhi, Xsegmts, Ylo, Yhi, Ysegmts, Zlo, Zhi, Zsegmts);
<# black>As with 'grid(.)', the argument values may be presented all together in one array (or in any mix of scalars and arrays, as long as the total number of values is 9 or 10). If GraphID is not present, the parameters will be applied to the next graph created (but not to subsequent graphs). On the other hand, <b>gridx(.), gridy(.)</b> and <b>gridz(.)</b> all require the GraphID, each taking arguments in the form (GraphID, LoValue, HiValue, NoSegments).

'graphresize(..)' works for 3D, affecting the graph margins but only indirectly affecting the size of the contained 3D axis grid.

<B>header(.)</B> and <B>footer(.)</B> work exactly as for the 2D case; no special 3D function is needed. Other functions working in 3D as for 2D include <B>isgraph(.), isplot(.), killgraphs(.), killplot(.), scaleformatx(.)</B>. However <b>scaleoverx/y/z(.)</b> work differently, as 3D graphs have the scale summarized to the right of the plotting surface of the graph. Each must have exactly three values in the argument array: the 'from' value, the 'to' value and the 'step' value. Also because of this, functions <b>scalefudgex/y(.)</b> have no effect in 3D. Functions <b>labelx(.)</b> etc. work as for 2D graphs, but their text will also be printed to the right of the plotting surface.

<b>Setting the initial viewpoint:</b> If you don't want the default viewing angles, use function <b>aspect</b>(<# blue>[graphID, ] scalar Declination, scalar RightAscension)<# black>. Imagine that your graph is of a man standing and facing you, and consider the plane of your table top as you view him on your vertical computer screen. <i>Declination</i> would then be the angle between the man and the table plane (0 when he is prone before you in an act of adoration; PI/2 when he is standing proud and vertical). The man can be rotated through a full circle, to face all directions; in doing so, his declination is unaltered. Now return him to face you, at whatever rakish declination angle he is standing relative to the table. His <i>RightAscension</i> is now 0. Rotate him through a right angle to face the wall to your right; his RightAscension is now PI/2. 
The default settings for 3D graphs are: Declination = PI/3;  Ascension = PI/6. If you want to use a default and cant remember these, write the system constant NAN in place of the angle.
If you omit graphID, then the settings apply to the next 3D graph to be drawn.
You can also retrieve the current settings by calling with only one argument: <b>aspect(graphID)</b>. This will return an array of length 2: [0] = current Declination, [1] = current Ascension. If graphID could not be identified or is 2D, the return is an array of size 1, value NaN, and a call to 'empty(.)' returns 'true'. (The 3-argument version also returns these values; but the 2-argument version is void.)

<B>Two 3D mesh examples:</B> The first example uses a 'graph paper' mesh - when you look down vertically on the XY plane, all lines are parallel to the X or Y axis, evenly distributed. The second has no such restriction; each node of the mesh has its own X, Y and Z coordinates without restrictions.

<# magenta>// FUNCTION GIVING THE HEIGHT OF THE MESH above each point in the XY plane:
<# blue>function ZMesh(x,y){ return (1 - x^6)*(1 - y^2); }
<# magenta>// PREPARE THE MESH:
<# blue>xnodes = 21;  ynodes = 20; <# magenta>// no. of axis intercepts of mesh wires.
<# blue>xmin = -1;  xmax = 1;  ymin = -1;  ymax = 1;  zmin = 0;  zmax = 2; <# magenta>// axis extremes
<# blue>rowNo = ladder(xnodes, xmin, xmax); <# magenta>// a locn. for every X-axis wire intersection in the mesh.
<# blue>colNo = ladder(ynodes, ymin, ymax); <# magenta>// same for the Y- axis.
<# blue>populate MeshArr through rowNo, colNo using ZMesh; <# magenta>// The array MeshArr is not predefined, but is created by this statement.
<# blue>grid(xmin, xmax, 5, ymin, ymax, 5, zmin, zmax, 5);
<# magenta>// PLOT THE MESH:
<# blue>p = plotmesh3d(MeshArr, colNo, rowNo, ' '); <# magenta>// Note the order of axis arrays; the dims. of MeshArr must be (size of rowNo) x (size of colNo).
<# blue>graph3d(p);

<# black>The second example:

<# magenta>// Draw the skeleton of a hemisphere (lines of latitude and longitude)

<# magenta>// Function to return the X,Y coordinates of a circle in the XY plane:
<# blue>function Circle(centreX, centreY, radius, angle) <# magenta>// Returns array of size 2: [0] = x, [1] = y.
<# blue>{	dim(result,2);
	result[0] = radius*cos(angle) + centreX;
	result[1] = radius*sin(angle) + centreY;
	return result;
}

<# magenta>// Program proper.
<# blue>centreX = 0.5;  centreY = 0.5;   sphereRadius = 0.5;
norows = 9;  nocols = 37;  
dim(mX, mY, mZ, norows, nocols);
for (i=0; i < norows; i++)
{	for (j=0; j < nocols; j++)
	{	radius = sphereRadius*cos(PI*i/(2*norows));  <# magenta>// radius of a latitude circle as projected onto the XY plane.
		<# blue>angle = 2*PI*j / (nocols-1); <# magenta>// On the XY plane, points on the latitude circle are taken at regular angles of 10 degrees around it.
		<# blue>xy = Circle(centreX, centreY,   radius,   angle); <# magenta>// returns each point on each projected circle in the XY plane.
		<# blue>mX[i,j] = xy[0];  mY[i,j] = xy[1];  
		mZ[i,j] = sqrt(sphereRadius*sphereRadius - radius*radius); <# magenta>// successive circles as defined above are elevated to where they would lie on the hemisphere, at 10 degree intervals.
	<# blue>}
}
grid(0,1,5,  0,1,5,  0,1,5);
p=plotmesh3d(mZ, mY, mX,    ' ', -1, -1,    '_', 1, "blue",   '.', 1, "magenta" ); <# magenta>// Points: don't show. Main lines: blue, continuous. Cross connections: magenta, dotted.
<# blue>graph3d(p);

<# black>--------------------------------------------------------------

<U>SEE ALSO:</U>
<B>header(..), footer(..)</B> -- text above and below the graph.
<B>gridx(..), gridy(..), grid(..)</B> -- set graph extremes, and no. of divisions along axes.
<B> scaleoverx(..), scalefudgex(..), scalejumpx(..), scaleformatx(..)</B> [and the same for -y, -z] -- modify / replace some or all of the automatically generated scale numbers.
<B>labelx(..), labely(..), labelz(..)</B> -- short descriptions of axis scaling.

<B>lastclosed()</B> et al. -- enter 'animation' and then key F1, for an explanation of its use.
==================================================================
//PLOTMX//
<b>PLOTTING A FAMILY OF CURVES</b>

There are currently three ways of doing so:
<bullet>Use function <b>plot(.)</b> and just plot them one by one in a loop. This allows the maximum flexibility (you can have different point and line features along each curve, separately to the rest), but is the most long-winded. See the separate section for this function.
<bullet>Use function <b>plotmesh(.)</b>. This allows you to have different point and line features across curves, but the features will be reproduced for each curve; for example, if you make one curve have alternating green and red points, every other curve will have the same. See the separate section for this function.
<bullet>Use function <b>plotmx(.)</b>, described below. Definitely the simplest way. This function allows you to have different point and line features for each curve, but not across curves. For example, you can have one green and one red curve, but you cannot have a curve which is made up of green and red segments (as you can with either of the above two functions). It also allows you to plot curves of unequal lengths on the one graph.


Function <b>plotmx</b>(<# blue>Matrix, XX,   PointType,  PointWidth,  PointColour,   LineType,  LineWidth,  LineColour<# black>) -- all of the arguments except the first are optional.  RETURNS an array of plot IDs.

<i>Matrix:</i>
This argument must be a matrix; a list array would raise an error.
Each row of this matrix is taken as a separate curve, and will be plotted separately on the same graph.
If the value MAXREAL is encountered anywhere in a row, that row's curve will be truncated, this and all later values being ignored. (If the first row value is MAXREAL, that row will simply not be plotted.)

<i>XX:</i>
A list array of X values. Its length must match the row length of Matrix. If the argument is omitted, it is generated internally as the sequence { 0, 1, 2, 3, ... }.

<I>PointType:</I>
Determines the shape of the point. Supply a single character, which is one of the following (exactly as for function <b>plot(.)</b> ):
<bullet>' . ' (fullstop) -- a dot (solid circle).  This is the default for the two argument form "plot(yy, xx)".
<bullet>' o ' (small letter 'O', not a zero) -- an outlined circle.
<bullet>' O ' (capital letter 'O') -- a thicker outlined circle.
<bullet>' [ '  --  a solid square. 
<bullet>' ] ' -- an outlined square.
<bullet>' x ' -- a cross. 
<bullet>' X ' -- a thicker cross.
<bullet>' + ' -- a plus sign.
<bullet>' # ' -- a thicker plus sign.
<bullet>'    ' (a space) -- points will not be visible.  (Any unrecognized character has the same effect.)
This argument may be scalar; if so, it should be the unicode value for one of the above.

PointType may be an array of length \> 1, in which case successive curves will have different point types, cycling through this array; e.g. if you have 10 curves, and supply PointType as the array("xo."), then curves 0, 3, 6, 9 will have point type 'x', curves 1, 4, 7 point type 'o', curves 2, 5, 8 point type '.'.
<i>NB - This meaning of PointType arrays is different to their meaning with <b>plot(.)</b> and <b>plotmesh(.)</b>!</i> 

<I>PointWidth:</I>
The number of pixels per side of the shape's containing square. The default is 3.
PointWidth may be an array of length \> 1, in which case successive curves will have different point widths, cycling through this array as explained for PointType. Again, <i>this meaning of PointWidth arrays is different to their meaning with <b>plot(.)</b> and <b>plotmesh(.)</b>!</i> 

<I>PointColour:</I>
You can specify colour in several different ways.
<bullet>Use a standard colour name (e.g. "blue"). There are 141 names currently stored; they are those recognized by .NET. Letter case is not important. To see the list, with demonstration of the colours, enter 'colour' into the Assignments Window, select it, and then press the F1 key. Scroll to the bottom of the message box that appears.
<bullet>Use a scalar value, which will be taken as an index to the system palette, as explained below. Or directly use the function itself...
<bullet>System function "palette(n)" to return one of 10 colours in the system palette. ('palette(.)' returns a chars. array holding the colour name.) The modulus of the rounded absolute value of 'n' is used, so that out-of-range values do not cause a crash. Colour names returned for different values of 'n' are: <# blue>0:"blue"; <# red>1: "red";  <# green>2: "green";  <# orange>3: "orange";  <# magenta>4: "magenta";  <# darkviolet>5: "darkviolet";  <# deepskyblue>6: "deepskyblue";  <# brown>7: "brown";  <# grey>8: "grey";  <# black>9: "black"; <# black>10: "white". 
<bullet>Use a hexadecimal number, exactly 6 digits long, prefixed by "0x" - e.g. "0xff00ee". Letter case not important. (The initial '0' is the cipher zero, not the letter 'o'.) The first two digits ("ff" in the example) are for the red component, the next two for the green, the last two for the blue component.
<bullet>Use a <I>non-</I>character row vector of length 3 ( i.e. matrix 1 x 3); then it will be interpreted as an opaque RGB colour - [0] holding the red value, [1] the green, [2] the blue. E.g. 'rowvec(255, 255, 0)' would give you yellow points. Each value must be in the range 0 to 255.

You can have different point colours for different curves as follows:
<bullet>Use a list of colours, delimited by '|'.  For example, "blue|red" will alternate blue and red curves.
<bullet>Use a jagged matrix of colour names, or an Nx3 array of RGB values (where N is the number of different colours to cycle through).
<bullet>Use a non-chars. list array of integers which are to be arguments to function <b>palette(.)</b>.
If there are less colours than curves, successive curves will rotate through the same colour set. If there are more colours than curves, excess colours are ignored.
As with previous arguments, realize that this system of handling multiple colours is different to the system used in <b>plot(.)</b> and <b>plotmesh(.)</b>.

<I>LineType:</I>
Determines the form of the line. Supply a single character, which is one of the following:
<bullet>' _ ' (an underscore) -- a continuous line. 
<bullet>' - '  (a dash) --  a dashed line " - - - - ". 
<bullet>' . ' (a fullstop) -- a dotted line  ".........".
<bullet>' ! ' -- a line of alternating dots and dashes:  " -.-.-.-.-". 
<bullet>' : ' -- a 'dash-dot-dot' sequence:  "-..-..-..-..-".
<bullet>'    ' (a space) -- no line at all.
The same system of using an array of more than one line type applies as for PtType above.

<I>LineWidth:</I> 
The width of the line, in pixels. The default is 1.
The same system of using an array of more than one line width applies as for PtWidth above.

<I>LineColour:</I>
As for PointColour above.

<u>HINT RE COLOURS</u>
It might be nice to colour your curves using system function <b>ladderclr(.)</b>, to give you gradually changing colours. For example, <# blue>ladderclr(NoCurves, "light blue", "dark blue")<# black> will give you curves gradually changing from light blue to dark blue.

==================================================================
//PLOTBARS  --  see HISTOGRAM
==================================================================
//PLOTSHAPE//
//MOVESHAPE//
//PAINTSHAPE//
//COPYSHAPE//
<U>PLOTTING A SHAPE</u>
Drawing a shape in MonoMaths has three stages (though they can be combined in a single 'plotshape(.)' call). (1) You create the 'docked' shape - the shape as it would be if it were docked at the graph origin, with its defining axes (if any) aligned with the X and Y axes of the graph; then (2) you move the shape to where you want it to be, rotate it to the angle you want, and stretch or shrink it (either as a whole, or along just one of its original axes). Finally, (3) you 'paint' the shape - give it an outline colour and thickness, and a fill colour.
The function 'plotshape(.)' will do all three stages at one time for you. But if you want to (a) duplicate the shape but vary details of each copy, or (b) move the shape around the graph on some trajectory - or both - then you can divide the task up into four stages:
<bullet><i>Create the docked particle, but don't make it visible.</i> Use <b>plotshape</b>(.) for this, but don't include it in the graph yet. If you are going to rotate the shape later, make sure that you define the docked shape in such a way that the origin is the most suitable centre of rotation for the shape.
<bullet><i>Deploy the particle</i> to where you want it, stretched or shrunk as you want it, and rotated as you want it, using <b>moveshape</b>(.) with the same plot ID.
<bullet><i>Insert the plot into the graph</i>, thus making it visible (Optionally, this can be done as part of the previous step, using one variety of 'moveshape'.). Continue to reposition it, if desired, using the same function with the same plot ID.
<bullet><i>Change its appearance</i> - its outline thickness and colour and its fill colour - as time goes on, using function <b>paintshape</b>(.).
<bullet><i>Duplicate the shape</i> - create a new docked shape identical to the original docked shape, using <b>copyshape</b>(.), and use the above two functions to deploy it.

<u>PLOTSHAPE</u>

\tp  =  <b>plotshape</b>(<# blue>ShapeType, <# red>Coords1,  Coords2,  <# magenta>LineType, LineWidth, LineColour,  <# green>FillColour, 
\t\t\t\t\t\t\t\t<# brown>PivotX, PivotY,  MagnifierX,  MagnifierY,   RotationAngle<# black>);

The first seven arguments (to FillColour) are obligatory; the rest are optional.

<i>ShapeType</i> -- One of the following: "rectangle", "polygon", "ellipse", "arc", "chord", "sector". Missing are: square (use 'rectangle'), triangle (use 'polygon') and circle (use 'ellipse' with equal radii). A 'chord' is not just the chord itself but includes the arc which it subtends; a 'sector' is the arc with extremes joined to the centre like a pie slice. All shapes except 'arc' can be filled with a colour (or just left transparent). 

Re the <i>reference origin</i> for the shape:  The reference origin is what would be the origin if you used 'plotshape(.)' without including arguments PivotX and PivotY.  Where arguments Coords1 and Coords2 define a shape in terms of dimensions rather than actual coordinates, this origin is at the centre of the shape. This is true for "ellipse", and for the three associated shapes: "arc", "chord", "sector" (i.e. the reference origin is the centre of the ellipse of which they form part). Where arguments are actual coordinates, then the reference origin is (0, 0) in the same coordinate system.

<i>Coords1</i> and <i>Coords2</i> -- different meanings for different shapes. The two arrays must have equal length, and that length must be at least as indicated below (excess length being ignored). Remember that in defining the shape with these coordinates, you are automatically setting both the centre of rotation (which will be the point (0, 0) ) and the zero-degrees state of rotation.
<bullet>Polygon -- Coords1 is the <b>X</b> coordinates of all the apices, Coords2 is the corresponding <b>Y</b> coordinates. Note carefully that the order is different to the order in 'plot(.)'! The minimum length of the arrays is 3.
<bullet>Rectangle -- arrays of length 2; Coords1 holds the X extremes (any order), Y the Y extremes. (The sides of the rectangle must be parallel to the axes in this docked position.)
<bullet>Ellipse -- Coords1[0] = horizontal <i>radius</i> (not diameter);  Coords2[0] = vertical radius;  Coords1[1] is the number of segments used to draw one quarter of the circumference; must be at least one. A lower value (e.g. 0) defaults to 10.  (Coords2[1] is not used.) This docked form of the ellipse will have its centre at (0, 0), and its maximum and minimum radii will be aligned with the axes.
<bullet>Arc, Chord, Sector -- This is an elliptical arc, so Coords1[0] = horizontal radius;  Coords2[0] = vertical radius;  Coords1[1] is the start angle, Coords2[1] the end angle; Coords1[2] is the number of segments for the whole arc. (In the case of 'chord' it does not include the chord itself, and in the case of 'sector' it does not include the two drawn radii). It defaults to 4, if the value is below 4. Coords2[2] is not used.
<i>LineType, LineWidth, LineColour</i> have their usual meaning, as for 'plot(.)'.
Just one qualification: If you want a filled shape but with no outline, still set LineType to a valid line-drawing value (e.g. '_'), but set its width to 0. If you use a nonvalid value (or ' ') for LineType, no fill will occur, and the shape will be completely invisible. (Of course, that may be what you temporarily want.)
<i>FillColour</i>, if an array representing a valid colour, fills the shape (exception: 'arc', which has no fill). If invalid or any scalar, the shape is not filled, i.e. is transparent. (This is different to the case of LineColour, where a valid scalar colour number will be correctly interpreted as a colour.)
NB - The Linux drawing application <i>Cairo</i> which underlies <i>MonoMaths</i> causes colour filling to overlap the shape's outline; if you change an existing filled shape to being transparent, its outline will appear to double in thickness.

The preceding arguments all define the shape in its docked form at the origin. To actually deploy the shape, provide it with the following values:

<i>PivotX, PivotY</i> -- The shape's <i>reference origin</i> (see above) is translated to this point. (This does not change the internally registered reference origin; further uses of 'moveshape' below, for example, will move the shape as if it were starting from its original position, not from this point.) 

<i>MagnifierX, MagnifierY</i> -- These distort the shape in the direction of the original docked X and Y axes (before any rotation occurs).

<i>RotationAngle</i> -- The angle by which orientation varies from the docked form (angles being positive anticlockwise, as always). If you plan to rotate a shape, choose the original 'centre' carefully, as this (translated) is what rotation will be around (hence the names 'PivotX/Y' for the translated centre). 

You should always supply limits for the graph, rather than rely on the automatic sizing system for graphs. This is because the automatic system will only take into account the coordinates of the docked shape, not those of the translated or rotated shape.

All shapes, including ellipses, are plotted as polygons. If you want to know <b>the coordinates of the polygon's vertices</b>, the function to use is <# blue>pointsof(.)<# black>.

<u>MOVESHAPE</u>

\t<b>moveshape</b>(<# blue>GraphID, PlotID, PivotX [, PivotY [, MagnifierX [, MagnifierY [, Rotation]]]] <# black>)  -- VOID; the plot retains its identity (in particular its Plot ID no.), but is moved. Where an argument is omitted the plot retains its original value. However if an argument is supplied, it must be valid (i.e. there are no code values for "don't change"). The arguments have the same meanings as in 'plotshape(.)'.
If GraphID is invalid - e.g. 0 or negative - then no graph will be updated, though the plot will still be moved. (If some graph does hold the plot, the change will not appear until some other action causes redrawing of that graph.) If GraphID is valid, and does indeed already contain the plot, the graph will be visibly refreshed. If GraphID is valid but that graph does not yet contain the plot, then it will be inserted.

<u>COPYSHAPE</u>

\t<b>copyshape</b>(<# blue>PlotID, PivotX [, PivotY [, MagnifierX [, MagnifierY [, Rotation]]]] <# black>)  -- RETURNS the ID of a new plot which copies the docked coordinates and other parameters of the original shape, altering only what you supply in the arguments, which have the same meanings as in 'plotshape(.)'.

<u>PAINTSHAPE</u>

\t<b>paintshape</b>(<# blue>GraphID, PlotID, LineType [, LineWidth [, LineColour [, FillColour]]] <# black>)  -- VOID; the plot retains its identity (in particular its Plot ID no.), but is recoloured. Where an argument is omitted the plot retains its original value. However if an argument is supplied, it must be valid (i.e. there are no code values for "don't change"). The arguments have the same meanings as in 'plotshape(.)'.
As mentioned above under 'LineType': If you want a filled shape but with no outline, still set LineType to a valid line-drawing value (e.g. '_'), but set its width to 0. If you use a nonvalid value (or ' ') for LineType, no fill will occur, and the shape will be completely invisible. (Of course, that may be what you temporarily want, e.g. to have some "now-you-see-me-now-you-don't" shape.)


<u>EXAMPLE 1</U>

<# red>__ DRAW A SPINNING ASTEROID ORBITING A PULSATING SUN

<# red>__ Build the basic 'docked' shapes ('docked' = centred at the origin, and aligned with axes).
<# magenta>// THE ASTEROID. Drawn as a rather irregular polygon. Here are the coordinates of its angles:
<# blue>Asteroid_X = data(0,     0.3,  0.3,   0.5,  0.4,   0.2,   0,     -0.2,   -0.4,  -0.5,  -0.4,  -0.2); <# magenta>// X coords of all the apices 
<# blue>Asteroid_Y = data(0.5,  0.4,   0.2,  0,    -0.2,  -0.4,  -0.5,  -0.4,  -0.2,     0,    0.3,    0.4); <# magenta>// Y coords of all the apices
<# magenta>// Plot the asteroid:
<# blue>pAst = plotshape("polygon", Asteroid_X, Asteroid_Y,   '_',  4, "black", "brown");
<# magenta>// THE SUN. Drawn as a circle.
<# blue>Sun_radius = 0.5;  
<# blue>segsPerQuarter = 10; <# magenta>// The sun is drawn as a polygon, with 10 line segments for each quarter of its circumference.
<# blue>pSun = plotshape("ellipse",  data(Sun_radius, segsPerQuarter),  data(Sun_radius, 0),  '_',   4, "red", "yellow");

<# red>__ Deploy the shapes - make the sun pulsate, and make the asteroid both orbit and rotate.
<# magenta>// Parameters of orbiting:
<# blue>scalar pivotX, pivotY; <# magenta>// coordinates of the asteroid's pivotal point.
<# blue>Orbit_angle = 0;
<# blue>Orbit_incAngle = -rad(1); <# magenta>// a one-degree decrement of the asteroid's orbital angle. (It is orbiting clockwise.)
<# blue>Orbit_radius = 4;  
<# magenta>// Parameters of rotating (spinning): 
<# blue>Asteroid_rotn = 0; <# magenta>// Initial rotational angle of the asteroid.
<# blue>Asteroid_incRotn = rad(10); <# magenta>// a ten-degree increment of asteroid's pivotal rotation. (It rotates anticlockwise.)
<# magenta>// Parameters of pulsating:
<# blue>Pulsn_angle = 0; <# magenta>// Angle used to pulsate the sun
<# blue>Pulsn_incAngle = rad(5);
<# blue>scalar Sun_magX, Sun_magY; <# magenta>// stretchers of the sun in the X and Y directions.
<# magenta>// Initialize the graph:
<# blue>G = graph(pAst, pSun); <# magenta>// Technically this starts the asteroid off superimposed on the sun; but too briefly to be seen.
<# blue>grid(G, -5, 5, 2,  -5, 5, 2);
<# blue>graphresize(G, 400, 400);

<# red>__ THE ACTION LOOP
<# blue>interval = 20;
<# blue>while (true)
<# blue>{ <# magenta>// Orbit the asteroid:
	<# blue>Orbit_angle += Orbit_incAngle;
	<# blue>pivotX = Orbit_radius * cos(Orbit_angle);   pivotY = Orbit_radius * sin(Orbit_angle);
  <# magenta>// Rotate the asteroid on its own pivot counterclockwise		
	<# blue>Asteroid_rotn += Asteroid_incRotn;
  <# magenta>// Change the shape of the sun gradually:
	<# blue>Pulsn_angle += Pulsn_incAngle;
	<# blue>Sun_MagX = 1 + 0.2*cos(Pulsn_angle);	
	<# blue>Sun_MagY = 1 + 0.2*sin(Pulsn_angle);	
  <# magenta>// Alter the PLOTS with the above data:
	<# blue>moveshape(G, pAst,  pivotX, pivotY, 1, 1, Asteroid_rotn);
	<# blue>moveshape(G, pSun, 0, 0, Sun_MagX, Sun_MagY, 0);
	<# blue>if (lastclosed() != 0) break; <# magenta>// Close any graph, and the program ends.
	<# blue>starttimer(0);
	<# blue>while (timer(0) < interval) { dummy = 1; }
<# blue>}


<# black><u>EXAMPLE 2</U>

<# red>__ SINNING PARTICLES
<# magenta>// All particles start off pure lily white. With each illicit liaison ( = collision on the graph) they become a little darker,
<# magenta>// until they are eventually black with sin.

<# red>__ Movement parameters
<# blue>population = 20;
<# blue>loopInterval = 20; <# magenta>// millisecs. of wait time between processings of positional data.
<# blue>meanVeloc = 0.02; <# magenta>// distance moved in a loop interval (i.e. at each looping).
<# blue>radius = 0.02; <# magenta>// particle radius
<# magenta>// Arrays describing the state of each particle:
<# blue>dim(PosnX, PosnY, Angle, Veloc, Luminescence,    population); <# magenta>// Luminescence is the HSL colour parameter that alters at collisions.
<# blue>dim(Plots, population); <# magenta>// One plot per particle.
<# magenta>// Initialize the arrays:
<# blue>noCollisions = false;
<# blue>while (!noCollisions) <# magenta>// i.e. keep looping till there are no particles colliding at the moment of creation.
<# blue>{	rand(PosnX, 1);  PosnX = 1.8 * PosnX - 0.9; <# magenta>// Randomized original X coordinates, range -0.9 to +0.9. (Graph extends from -1 to +1.)
<# blue>	rand(PosnY, 1);  PosnY = 1.8 * PosnY - 0.9; <# magenta>// Same for Y coordinates.
<# blue>	ouch = DetectCollisions(PosnX, PosnY, 4 * radius); <# magenta>// Keep starting positions at least 4 radius lengths apart.
<# blue>	noCollisions = (max(ouch) == 0); <# magenta>// If all elements of 'ouch' are 0, there were no collisions.
<# blue>}
<# blue>rand(Angle, 1);     Angle *= 2*PI; <# magenta>// Any angle in the range 0 to 2PI.
<# blue>Veloc += meanVeloc; <# magenta>// All particles will have the same velocity for this example; consider using 'randgauss(.)' to vary velocities.
<# blue>Hue = 1;  Satn = 0.8; <# magenta>// These HSL colour parameters don't change.
<# blue>Luminescence += 1; <# magenta>// 1 = white, the original particle colour; 0 = black. Intermediate colours are shades of red.

<# red>__ Set up the environment
<# blue>G = graph();
<# blue>grid(G, -1, 1, 1,    -1, 1, 1); <# magenta>// Axes span -1 to 1. No hairlines on graph.
<# blue>graphresize(G, 400, 400); <# magenta>// Make it square.
<# blue>scaleoverx(G, '#');   scaleovery(G, '#'); <# magenta>// No scale markings.
<# red>__ Build the original shape
<# blue>pOrig = plotshape("ellipse",  data(radius, 3),  data(radius, 0), '_', 2, "blue", "white"); <# magenta>// '3' = segments per quarter-circumference
<# red>__ Make copies of it
<# blue>for (i, population)	Plots[i] = copyshape(pOrig, PosnX[i], PosnY[i], 1, 1, 0);

<# red>__ THE ACTION LOOP
<# blue>firstLoop = true; <# magenta>// In the first loop we add particle plots to the graph; in all later loops we just update them.
<# blue>while (true)
{ starttimer(0); <# magenta>// Get the loop timer going 
<# magenta>// Place the particles:
<# blue>	MoveAndReflect(Plots, PosnX, PosnY, Angle, Veloc); <# magenta>// REF args, all updated; if wall(s) have been hit, particles will be reflected;
				<# magenta>// but in this very simple example we don't change the dynamics of particles when they collide with one another.
<# blue>	if (firstLoop) { addplot(G, Plots); firstLoop = false; }
<# blue>	Ouch = DetectCollisions(PosnX, PosnY, radius); <# magenta>// 'Ouch' will be a pseudoboolean array: 1 if a collision, otherwise 0.
<# blue>	AdjustColours(Plots, Luminescence, Ouch);
	<# magenta>// The waiting loop:
<# blue>	while (timer(0) < loopInterval) { dummy = 1; }
<# blue>	if (lastclosed() != 0) break; <# magenta>// Close the graph to end the program.
<# blue>}

<# red>__ ~~~~~~~~~~~~ FUNCTION ZOO  ~~~~~~~~~~~~

<# blue>function MoveAndReflect(ref Plots, ref PosnX, ref PosnY, ref Angle, ref Veloc)
<# blue>{	import scalar population, G;
	<# magenta>// Move the particles, without regard to the walls at this stage:
<# blue>	for (i, population)
	{	angle = Angle[i];  velocity = Veloc[i];
		PosnX[i] += velocity * cos(angle);
		PosnY[i] += velocity * sin(angle);
	}
	<# magenta>// Catch prisoners escaping through the walls.
<# blue>	for (times, 2) <# magenta>// Looped, because corner collisions will need two passes.
<# blue>	{	escapeesFound = false; 
		for (i, population)
		{	x = PosnX[i];   y = PosnY[i];   angle = Angle[i];
			if         (x > 1)	{ PosnX[i] =  2 - x;   Angle[i] = PI - angle;   escapeesFound = true; } 
			else if (x < -1)	{ PosnX[i] = -2 - x;   Angle[i] = PI - angle;  escapeesFound = true; }
			if         (y > 1)	{ PosnY[i] =  2 - y;   Angle[i] = -angle;        escapeesFound = true; } 
			else if (y < -1)	{ PosnY[i] = -2 - y;   Angle[i] = -angle;       escapeesFound = true; }
		}
		if (!escapeesFound) break;
	}
	<# magenta>// Replot them in their new positions:
<# blue>	for (i, population)	moveshape(G, Plots[i], PosnX[i], PosnY[i], 1, 1, 0);
}

<# magenta>// This is a very simple collision detector; distances between particles are not calculated. If particles have their 
<# magenta>//   X coordinates closer than criticalSeparation, and same for their Y coordinates, a collision is registered.
<# magenta>// We only check final positions of particles; if during their last move they crossed but are now apart again,
<# magenta>//   no collision will be detected. (Think of this as quantum mechanics uncertainty perhaps.)  
<# magenta>// RETURNED: An array holding 1 for each particle involved in a collision, otherwise 0.
<# magenta>// NB - there is currently no refractory period after a collision, so that if two colliding particles are only moving
<# magenta>//  slowly, they will register two or more collisions with each actual collision, till they move apart.
<# blue>function DetectCollisions(PosnX, PosnY, criticalSeparation)
{	import scalar population, radius;
	dim(result, population);
	for (i, population)
	{	x = PosnX[i];  y = PosnY[i];
		for (j = i+1; j < population; j++)
		{	if (abs(PosnX[j] - x) < criticalSeparation  &&  abs(PosnY[j] - y) < criticalSeparation) 
			{ result[i] = true;  result[j] = true;  break; } 
		}
	}	
	return result;
}

function AdjustColours(ref Plots, ref Luminescence, Ouch)
{	import scalar G, Hue, Satn;
	incLumin = 0.1; <# magenta>// luminescence increment at each collision.
<# blue>	for (i, size(Ouch))
	{	if (Ouch[i]) <# magenta>// involved in collision:
<# blue>		{	lummy = Luminescence[i] -incLumin; <# magenta>// darken the colour a little
<# blue>			if (lummy \<= 0) lummy = 0;
			paintshape(G, Plots[i], '_', 2, "black", hsl_to_rgb( data(Hue, Satn, lummy)));  
			Luminescence[i] = lummy;
		}
	}
}
==================================================================
//PLOTSOF -- see KILLGRAPHS
==================================================================
//PLU//
//PLURAL//
<b>RETURN THE SINGULAR OR PLURAL FORM OF SOME WORD, DEPENDING ON A VALUE</b>

The function is <b>plu(..)</b>.

There are four ways of calling this function:

<b>plu(<# blue>char. array Text,  scalar Value<# black>)</b> -- Returns the singular or plural form of Text. If Value is exactly 1, Text is returned as is; if any other value, its plural form is returned. An attempt is made to adjust the plural form according to the ending: "cat" --> "cats"; "city" --> "cities"; "boss" --> "bosses"; "dash" --> "dashes"; "catch" --> "catches". The algorithm is not extensive; you can fool it ("child" will not go to "children"; "locus" will not go to "loci").
The <i>letter case</i> of alterations to Text will be the same as that of the last letter of Text. 

<b>plu(<# blue>scalar Value,  char. array Text<# black>)</b> -- Exactly the same, except that the value itself is returned before the plural form: "1 cat", "2.54 cats", ... 

<b>plu(<# blue>array Text,  scalar Value, array PluralText<# black>)</b> -- If Value is exactly 1, Text is returned as is; if any other value, PluralText is returned instead. It is intended for irregular plurals: <# blue>plu("child", 2, "children");<# black>. But no analysis of Text occurs; therefore this could be used in any situation where any array is to be conditionally replaced by any other array.

<b>plu(<# blue>scalar Value,  array Text, array PluralText<# black>)</b> -- As above, but with Value preceding the text, as for the second case above.

==================================================================
//POINTSOF//
<just c><b>RETRIEVING PLOTTED POINT COORDINATES FROM A GRAPH</b>
<just l>
<b>pointsof(<# blue>scalar PlotID,  bool ScaledCoordinates [, bool OriginalShape ]<# black> )</b> -- returns point plotting details for the given plot.


<u>ARGUMENTS</u>

<i>ScaledCoordinates</i>:  If TRUE, then the coordinates in terms of the graph's scaling are returned; if FALSE, actual pixel values are returned. In this case the pixel value is relative to the whole drawing surface - i.e. all below the header and above the footer - and not to the plotting surface margin. Also, be aware that Y pixel coordinates increase as one moves down the graph.

<i>OriginalShape</i>:  Only accessed for plots created by 'plotshape(.)', and then only where scaled coordinates are requested. Even then, it only has point if the shape has been moved since creation by function 'moveshape(.)'. In that particular case, this returns the polygonal vertex coordinates <i>before</i> any and all moves of the original shape as created by 'plotshape'. The default for absent argument is FALSE.
(Note that where <i>pixel</i> coordinates are requested, these are always those of the latest graphing of the shape, irrespective of the value of this argument.)


<u>RETURNED VALUE</u> 
<bullet>Pixel coordinates required:  always returns a matrix of size 2 x N, where N is the number of plot points. (In the case of a shape plot, this is the vertices of the polygon which makes up the plot.)  The first row holds the X coordinates and the second row the Y coordinates.
<bullet>Scalar coordinates required:  Again given N points, for a 2D graph the matrix size is 2 x N, rows as above; for a 3D graph,  the matrix is 3 x N, with the final row holding Z coordinates.
<bullet>Error occurred: The 'empty' array { NaN } is returned. Only happens if PlotID is not recognized. No errors crash the program.


<u>CAVEATS</u>
<bullet>The function does not take a GraphID argument. If the plot occurs in more than one graph, the information comes from the graph in which the plot was most recently (re)drawn.
<bullet>In the case of shapes, where the latest coordinates are requested (i.e. OriginalShape is missing or false), it is important to understand that these coordinates are only ever generated when the shape is (re)drawn. It is permissible to move a shape without it being (yet) redrawn; you call 'moveshape(.)' with a nonvalid graph ID (like 0) to do so. In that case, the coordinates which are returned by 'pointsof' will be those generated at the last graphing, before this ungraphed move.


<u>EXAMPLE</u>
An ellipse is created and then altered (translated, rotated and magnified). The graph displays the 'before' and 'after' ellipses. Function <# blue>pointsof(.)<# black> is used to obtain both the original and the moved sets of points. (MonoMaths plots an ellipse as a polygon, as indeed it does for all other shapes.)

<# magenta>// Set up the graph:
<# blue>g = graph();
graphresize(g, 400, 400);
grid(g, -1, 1, 10,   -1, 1, 10);
<# magenta>// Plot the basic shape (an ellipse, centred at the origin):
<# blue>p = plotshape("ellipse",  data(0.7, 0),  data(0.5, 0), '_', 1, 'red', 0);
<# magenta>// Display a copy of the original shape:
<# blue>pCopy = copyshape(p, 0); <# magenta>// We want to display the shape both before and after it is moved, hence this copy.
<# blue>addplot(g, pCopy);
paintshape(g, pCopy, '_', 1, 'blue', 0); <# magenta>// The 'before' shape is blue, the 'after' shape red.
// Move the shape:
<# blue>moveshape(g, p,  0.25, 0.25, 0.5, 0.25, PI/4); <# magenta>// translation, rotation and magnification.
// Get the points:
<# blue>mxOrig = <b>pointsof</b>(p, true, true); <# magenta>// the points for the ORIGINAL shape 
<# blue>mxMoved = <b>pointsof</b>(p, true, false); <# magenta>// the points for the MOVED shape
// Display the results:
<# blue>writeln("Before the shape was moved:");
writeln(neat(mxOrig, "G2"));
writeln("After the shape was moved:");
writeln(neat(mxMoved, "G2"));

==================================================================
//POKE -- see SELECT
//POLAR -- see COMPLEX
==================================================================
//POLYNOMIAL//
//POLYNOMIALS//
//POLYSTRING//
//SOLVEPOLY//
//DIFFPOLY//
//EVALPOLY//
//ROOTSTOPOLY//
//CURVEFIT//
<B>Functions Handling Polynomials</B>

<B>Polynomials</B> are stored as list arrays, in ascending order of degree:
<# blue>polly = 'data(-1,2,3);'<# black> stores polynomial 3X^2 + 2X -1.

<B>Polynomial roots</B>, being often complex, are stored as Nx2 matrices; element Mx[n,0] is the real part of the nth. root, Mx[n,1] is the imaginary part.

<B>evalpoly(polly, argmt)</B> -- 'argmt' can be one of three structures: (1) a scalar; the result is then itself scalar, the evaluation of the polynomial with <I>real</I> argument 'argmt'. (2) a list array; the result is then another list array, a series of evaluations for the various <I>real</I> values in 'argmt'. (3) an Nx2 matrix of <I>complex</I> numbers (format as under 'polynomial roots' above), which will produce an Nx2 matrix representing the complex evaluations.

<B>rootstopoly(roots)</B> --  'roots' is either: (1) a list array, in which case all elements are regarded as <I>real</I> roots; or (2) an Nx2 matrix of <I>complex</I> roots, formatted as above. NB: complex roots MUST come in exact conjugate pairs (order unimportant), or an error will be raised. (Real roots are entered with imaginary part '0', and obviously do not need to be paired.) Roots are assumed to be in rectangular (non-polar) form.

<B>diffpoly(polly)</B> --  produces the polynomial which is polly differentiated; e.g. if polly is [1, -2, 3], representing 3X^2 - 2X + 1, the function will produce [-2, 6], representing 6X - 2.

<B>solvepoly(polly [, negligible] [, output format] )</B> --  Solve the equation: polly = 0. An Nx2 matrix of complex roots is returned, formatted as above, N being the degree of the equation (e.g. 2 for a quadratic equation). Mostly no other arguments needed. 'negligible' is the value below which intermediate results are interpreted as zero; the default value is 1e-15, which should suit most situations. Roots are sorted, with real roots being lower in the returned matrix than complex roots.The default output format is rectangular; if you want polar, put 'P' (or 'p') here. ('R','r' --> rectangular; but they are redundant, as they are the default values.)
CAVEAT: All polynomial solvers have their shortcomings. Equations with multiple equal roots will produce much less accurate results than usual; and occasionally the solver will produce a complex root with a tiny imaginary value where it should have produced a real value. To be really sure, you can do the following: 
\t<# blue>polly=data(1,2,3,4,3,1);
\t<# blue>soln=solvepoly(polly);
\t<# blue>polly2=rootstopoly(soln);<# magenta> // re-create a polynomial from the offered roots.
\t<# blue>comp=compare(polly,polly2); <# magenta> // compare the original and recreated polynomials.
\t<# blue>rms=comp[8]; <# magenta> // Choose the root-mean-square result of 'compare'. It should be of the same order as 'negligible', or around its square root at worst.<# black>

If the polynomial cannot be solved (very rare), an array of size 1 is returned ([0] = 0); therefore always test the result before processing it. One other caution: every few hundred polys you will get one which appears to solve, but which is wrong because a spurious tiny imaginary quantity was taken as valid, so that a conjugate root was devised - which throws the process out. It is not a bad idea to crosscheck using functions 'rootstopoly(..)' (to recreate a polynomial from the solution) and 'compare(..)' (to compare the original and the reconstructed polynomial - use the RMS result returned by 'compare'). For valid solutions, RMS values will constellate around the CutOff value.

<B>curvefit (Array of X values, Array of Y values, Degree of fit polynomial)</B> -- Fit a polynomial curve to a set of data, using the least squares method. An array of polynomial coefficients is returned (as usual, in ascending order of degree of term). 
Constraints: Degree must be 1 (for a straight line) or higher. The two arrays must be equal in length, and represent at least (Degree+1) points (no upper limit). NB: The points must be sorted such that X values are in ascending order, and no X values are duplicated.

<B>polystring (array Polynomial [, scalar Precision [, bool PowersAsSuperscripts [, char. array IndepVariable ]]]</B> -- Accepts a polynomial as an array (ordered by ascending index). If Precision has a value from 1 to 15, then that number of significant digits is used; .NET decides whether to use a fixed decimal format or an exponential format, using whichever is shorter. (Faulty argument invokes a default of five significant digits.) If PowersAsSuperscripts is present and TRUE, then superscript tags are added; these will be recognized by 'show(.)' and 'writeln(.)' to display powers as superscripts. Otherwise powers are represented with carats: "X^2". The default text for the independent variable is "X". If the final argument is present, its contents will replace this default.
==================================================================
//POPULATE//
<U>POPULATE:</U>
Fills an array of one or more dimensions with values based on one list array for each dimension.

<U>Version 1</U> 
<# blue><B>populate </B>Struct<B> through </B>aa, bb, cc <B>using</B> Foo;
<# black>Note that -
<bullet>'Struc' is created by the statement, so does not have to be declared beforehand.
<bullet>There is a list of one or more comma-separated arrays aa, bb, ... , one for each dimension of Struc. The dimensions of Struc will be A x B x C x ..., where A is the length of aa, B of bb, etc.
<bullet>A user function (here, 'Foo') is referenced. You can use just the name - without brackets and arguments - or can supply the argument list: 'Foo(a, b, c, ...)'.
<bullet>You must have written such a function Foo(x, y, ...) with at least as many arguments as there are arrays aa, bb,...; and it must return a scalar value. (If there are extra arguments, obviously you cannot use the function name alone, without an arguments list.)

<U>Version 2</U> 
<# blue>dim(Mx, 11, 21);
<# blue>populate Mx through <B>(</B>low1, high1<B>),(</B>low2, high2<B>)</B> using Foo;
<# black>Note that -
<bullet>The array Mx is predimensioned.
<bullet>There is a list of one or more bracketted sets (low, high), one for each dimension of Mx (optionally with commas between bracketted sets). They represent ranges of values, equally spaced, one for each element of the corresponding dimension of the array.
<bullet>The value of Mx[p, q] will be given by Foo( [the pth value in the first range], [the qth. value in the second range]).

In version 1, there is no need for arrays aa, bb... to be arithmetic progressions, or even in ascending order; their values are arbitrary. It is therefore more generally applicable than version 2.

<U>More on the Function Name:</U>
If the function has exactly as many arguments as there are dimensions to the first array ('Struc' and 'Mx' in the above examples), you can omit the arguments as above; writing any of "Foo(a, b)",  "Foo" or even "Foo(boo, hoo)" - will have the same effect. (The last because the first arguments are ignored and overwritten by values from the 'through' arrays.) If the function has more arguments, then the extra ones will be faithfully preserved. E.g. for a matrix as the 'populate' argument, "Foo2(x, y, 100, p+1)" would replace the first two arguments but leave the last two to values which were provided before the 'populate' code. 


<U>Examples</U>

This example fills a list array nonlinearly:

<# magenta>// user function for populating the array; returns the square of x
<# magenta>//   if x < 6, otherwise an exponentially calculated value.
<# blue>function Foo(x)
<# blue>{ if (x <= 6) {z = x*x;} else {z = 100 - 64*exp(6-x) }; return z }
<# magenta>// Main program:
<# blue>xx = ladder(11,0,10); <# magenta>// produces the array [0,1,2,...,9,10]
<# blue><B>populate</B> yy <B>through</B> xx <B>using</B> Foo; <# magenta>// each yy[i] becomes Foo(xx[i])
<# blue>p = plot(yy,xx); 
<# blue>g = graph(p); 


<# black>The equivalent code for the second version of 'populate':

<# blue>function Foo(x)
<# blue>{ if (x <= 6) {z = x*x;} else {z = 100 - 64*exp(6-x) }; return z }
<# magenta>// Main program:
<# blue>dim(yy, 101);
<# blue>populate yy through <B>(0,10)</B> using Foo;
<# magenta>// As a result, yy[0] = Foo(0), yy[100] = Foo(100).
<# blue>p = plot(yy, 0); <# magenta>// '0' generates an X axis array [0, 1, 2, 3, ..]
<# blue>g = graph(p); 

<# black>Note the brackets, with a comma separating two values. (The values can be expressions rather than literal numerals.)

A matrix example, incorporating parameters into the function; it is used here to produce a 3D surface plot:

<# blue>function Fn(x, y, a, b){return a*x*x + b*y*y;}
<# blue>xx = ladder(11,0,10);  yy = ladder(5,0,4); <# magenta>// corresp. to X-axis and Y-axis ticks
<# blue>populate zz through <B>xx,yy</B> using Fn(xx, yy, 10, 20);
<# blue>p = plotmesh3d(zz, yy, xx); <# magenta>// Note the order; zz must be a matrix of dimensions (size of xx) x (size of yy).
<# blue>g = graph3d(p); 
==================================================================
//PREVALENCE//
<just c><b>FINDING THE FREQUENCY OF OCCURRENCE OF VALUES IN AN ARRAY</b>
<just l>
The function that handles this problem is <# blue>prevalence(.)<# black>. It has two distinct usages, with different argument requirements.


<u>SITUATION 1 -- Organize all values in the input array in order of frequency of their occurrence</u>

<b>prevalence(<# blue>InArray,  scalar OnlyIfDuplicatedThisOften [, scalar IgnoreThisValue ]<# black>)</b> -- returns a matrix in which row 0 holds values of InArray and row 1 holds the number of times each is represented. 

The matrix is sorted on the second row, in descending order, so that the most frequently occurring value is in the 0th. column. (Sorting does not occur within ties; e.g. if '1', '2' and '3' all occur with the same frequency, their order with respect to one another is indeterminate.)

<i>OnlyIfDuplicatedThisOften</i> is rounded (and converted to 1 if \< 1). The output matrix only includes those values which occur at least this number of times. If no values are so duplicated, the 'empty' array { NaN } is returned.

If <i>IgnoreThisValue</i> is present, then the result will be as if InArray did not contain any instance of ThisValue.


<u>SITUATION 2 -- Record how often some particular values occur within the input array</u>

<b>prevalence(<# blue>InArray,  array LoValues [ , array HiValues ]<# black>)</b> -- returns a list array - call it 'Result' - which is longer than LoValues by one.

Where there is no third argument, values in InArray which exactly match values in LoValues are scored; and Result[i] will contain the number of occurrences of LoValues[i]. The last element of Result will give the number of elements of InArray which do not occur in LoValues.

Where there is a third argument, Result[i] will contain the number of occurrences of InArray elements 'v' such that  LoValues[i]  ≤  v  <  HiValues[i]. (Note that the upper limit is excluded.)  The last element of Result will again contain the number of elements of InArray which did not lie within any of the given ranges.


<# black>Where you only want to <b>remove duplicates</b> from an array, use one of functions <# blue>removedups(.), removeruns(.)<# black>.

==================================================================
//PRIMES//
<B>primes</B>(..) -- Computes a range of prime numbers. NB: this function uses the simplest of algorithms (a sieve), and so is only useful for something of the order of the first 100,000 primes, but depending on your computer. (Mine, a cheapish laptop of 2010 vintage, takes 0.6 secs. to return 100,000 primes, and 20 secs. to return the first million primes. Just don't try to print them all out in the Results Window!) It is therefore not intended for numerical research, but for situations where you need a set of numbers guaranteed not to have common factors. The best way to explain the arguments is by examples:

<I>(a) Using Cardinal Numbers:</I>
\t<# blue>arr = primes(11, 20); <# magenta>// returns all primes between 11 and 20 inclusive.
\t<# blue>arr = primes(11, 0, 10); <# magenta>// returns 10 primes, starting with 11. Note that the middle argument is now zero 
\t\t<# magenta>// (or it can be negative), which tells the program to ignore it and use the third argument instead.
\t<# blue>arr = primes(9, 0, 10); <# magenta>// returns the same as the above, as 9 is not prime.
\t<# blue>arr = primes(14, 16); <# magenta>// returns an array of size 1, value 'NaN' - i.e. no primes.

<I>(b) Using Ordinal Numbers:</I>
Ordinal numbers are those with 'st.', 'nd.', 'th.' after them. The first prime is 2 in this system.
It is <I>the presence of a fourth argument</I> which tells you that you are using ordinal numbers; it does not matter what that argument is. A good choice is the explicit array "th", but you could just as easily use 0.
\t<# blue>arr = primes(1, 100, 0, 'th'); <# magenta>// returns all from the first to the hundredth prime.
\t<# blue>arr = primes(4, 0, 10, 'th'); <# magenta>// returns 10 primes, starting from the 4th. prime (which is 7).
\t<# blue>arr = primes(1000, 0, 1, 'th'); <# magenta>// returns the thousandth prime (in an array of size 1).
\t<# blue>arr = primes(1000, 1000, 0, 'th'); <# magenta>// does the same.

Where there are no primes in range, an array of size 1, value NaN, is returned, and a call to function 'empty(.)' returns TRUE.
==================================================================
//PRODROWS//
//PRODCOLS//
<B>prodrows</B>(<# blue>Mx [, FromRow [, Extent [, IgnoreZeroes]]]<# black>) -- returns a list array whose length is the length of a row of Mx, and whose ith. value is the product of all the elements in the ith. column of Mx. If the 4th. argument is supplied and nonzero, then any zeroes <I>after the first</I> in a column will be ignored (i.e. treated as if they were 1).

If 2nd. +/- 3rd. arguments are supplied and are wrong, the outcome is as if the matrix had rows of zeroes extending to infinity both before the first and after the last row; for example, FromRow = -1 with Extent = 1 would return an array of zeroes (the values of virtual 'row -1'). Similarly, Extent <= 0 returns an array of zeroes. The only error raised is if Mx is not a matrix.  (See also 'sumrows' and 'sumcols'.)

<B>prodcols</B>(<# blue>Mx [, FromCol [, Extent [, ZeroesToOne ]]]<# black>) -- the column equivalent of 'prodrows(.)'; it behaves in exactly the same way.

Examples :

<# blue>\tMx = fill(12, 1, 1);  redim(Mx, 3, 4);    <# magenta>// generates this matrix:
<# magenta>\t//\t1    2    3    4
<# magenta>\t//  Mx = \t5    6    7    8
<# magenta>\t//\t9   10  11  12

<# blue>\tarr = prodrows(Mx);     writeln(arr);<# magenta>// -->  [45, 120, 231, 384 ]
<# blue>\tarr = prodcols(Mx);     writeln(arr);<# magenta>// -->  [24, 1680, 11880]

<# magenta>\t//Now we insert zeroes as follows:
<# blue>\tMx[0,0] = 0;   Mx[1,1] = 0;  Mx[2,3] = 0;  <# magenta>// The matrix is now:
<# magenta>\t//\t0    2    3    4
<# magenta>\t//  Mx = \t5    0    7    8
<# magenta>\t//\t9   10  11  0

<# blue>\tarr = prodrows(Mx);     writeln(arr);<# magenta>// -->  [0, 0, 231, 0 ]
<# blue>\tarr = prodcols(Mx);     writeln(arr);<# magenta>// -->  [0, 0, 0 ]
<# blue>\tarr = prodrows(Mx, 0, 100, true);     writeln(arr);<# magenta>// -->  [ 0, 20, 231, 32 ]
<# blue>\tarr = prodcols(Mx, 0, 100, true);     writeln(arr);<# magenta>// -->  [0, 280, 990 ]

==================================================================
//PRODUCT//
<B>product</B>(<# blue>Array [, ZeroesToOne]<# black>) -- the product of all elements of the array (irrespective of its structure). If the 2nd. argument is supplied and is not zero, then any zeroes <I>after the first</I> will be ignored.

<# blue>\tx = product( data(1,2,3,4) );  <# magenta>// --> 24
<# blue>\tx = product( data(1,2,3,4,0) );  <# magenta>// --> 0
<# blue>\tx = product( data(1,2,3,4,0), true );  <# magenta>// --> 24
<# blue>\tx = product( data(1,2,0,3,4), true );  <# magenta>// --> 24
<# blue>\tx = product( data(0,1,2, 3,4), true );  <# magenta>// --> 0 (First 0 never ignored).
==================================================================
//PROGRAMFILE//
<B>programfile</B>(<# blue>scalar Dummy or array WhichPart<# black>) -- Always returns a chars. array, the path and/or name of the current MonoMaths user program. (If the program has never been saved to disk, an error will be raised.) <i>Argument:</i>  If a scalar argument, the whole file path and name is returned. If an array, its first character is checked; if 'P' or 'p', only the path is returned (terminated by the character '/'); if 'N' or 'n', only the name is returned; anything else defaults to returning the full path and name.
==================================================================
//PROGRESSIVE//
<B>progressive</B>(<# blue>array Subject,  array Operation<# black>) -- Operation can be  '+'  or  '*' (only the first character is checked). 

Used to perform cumulative operations on array Subject. Returns an array of the same structure as Subject (but as a non-chars. array).
<bullet>If Operation is '+', then the nth. term of the output array is the sum of all of the terms in Subject up to and including the nth. term.
<bullet>If Operation is '*', then the nth. term of the output array is the product of all of the terms in Subject up to and including the nth. term.

EXAMPLES:

\t<# blue>arr = data(1,2,3,4,5);
\t<# blue>brr = progressive(arr, '+');  <# magenta>// Output array is  [1, 3, 6, 10, 15].
\t<# blue>crr = progressive(arr, '*');  <# magenta>// Output array is  [1, 2, 6, 24, 120].

Warning: There is no test for overflow, which may be important with Operation '*'.

==================================================================
//PUSH//
//POP//
<just c><b>BUILDING AND USING A STACK</b>
<just l>
You can build a stack as a <i>list array</i> (in which case any amount of data can be 'pushed' onto the stack and 'popped' off the stack at any stage) or as a <i>matrix</i> (in which case only whole rows can be pushed or popped).

(You can also use a system list as a stack - but that is another story.)

The two functions that handle access to such stacks are <b>push(.)</b> and <b>pop(.)</b>.


<u>PUSHING ONTO THE STACK</u>
	<b>push</b>(<# blue>NAMED array <b>Stack</b>,  array / scalar <b>NewData</b>,  scalar <b>SizeLimit</b> [,  bool <b>PushOntoLowEnd</b> ]<# black> ) -- a VOID function, changing Stack directly. 
<bullet><i>Stack</i>:  Is either a list array or a matrix. (The two are handled differently, as explained below.) It is permissible, and often very useful, to start with an 'empty' Stack. If the stack is to operate as a list array, Stack would be set to data(NaN). If the stack were to be a matrix, instead you would make Stack a 1xN matrix (N being the intended row length), all its values being NaN. (E.g. use the instruction <# blue>Stacko = matrix(1, rowLength, fill(rowLength, NaN))<# black> .) In either case the contents of Stack would be replaced by that of NewData.
<bullet><i>NewData</i>: If Stack is a list array, this can have any length. If Stack is a matrix, the length of NewData must be an exact multiple of the length of one row of Stack.
<bullet><i>SizeLimit</i>: The stack may grow until this limit is reached; thereafter it stays the same size, as much being discarded from one end as is being added on at the other end. NB - when Stack is a <i>matrix, SizeLimit is a number of rows, not a number of elements</i>.
<bullet 30,>  No internal adjustments are made to SizeLimit; it must round to at least 1. If you want your stack to have unbounded size, set SizeLimit to some ridiculously high value.
<bullet><i>PushOntoLowEnd:</i>  If this argument is <i>absent</i>, or is set to TRUE, data is added onto the low-index end of Stack; otherwise onto the high-index end.


<u>POPPING OFF THE STACK</u>
	<b>pop</b>(<# blue>NAMED array <b>Stack</b>,  scalar <b>HowMuchData</b> [,  bool <b>PopFromLowEnd</b> ]<# black> ) -- a NONVOID function,  which <i>both</i> returns the popped data  <i>and</i> changes Stack directly (by removing from it the popped data). 
<bullet><i>Stack</i>:  As for 'push', is either a list array or a matrix; and again, the two are handled differently. It is again permissible to start with an 'empty' Stack (i.e. the list array [NaN], or a matrix consisting of one row with all values NaN).
<bullet><i>HowMuchData</i>: If Stack is a list array, this is the number of elements you want. If Stack is a matrix, it is the number of rows. (You may not get all that you want - see under 'returned' below.)
<bullet><i>PopFromLowEnd:</i>  If this argument is <i>absent</i>, or is set to TRUE, data is taken from the low-index end of Stack; otherwise from the high-index end.
RETURNED: Always a list array. If there was enough data in Stack, this will be the amount of data that you requested. If not, it will be the whole contents of Stack. If Stack was already empty, the return is the 'empty' array, [NaN].

If Stack is left empty by your popping, it will become an 'empty' array. If it was a list array, this will be the list array [NaN]. If it was a matrix, this will be a 1xN matrix containing nothing but NaN. (In both cases, the function "empty(.)" would return TRUE for Stack.)
==================================================================
//RAD -- see TRIGONOMETRY
==================================================================
//RANDOM//
//RAND//
//RANDSIGN//
//SEED//
//RANDGAUSS//
//RANDUM//
//RANDRANGE//
<B>rand</B>(..) -- generates a random no. of uniform distribution. It comes in one VOID and two NONVOID forms. 
<bullet>"p = rand(scalar N)" - Nonvoid; returns a single random number. If N (rounded) is 1 or less, this generates a random no. in the range 0 \<= N \< 1.0.  If N (rounded) is 2 or more, a random integer from 0 to (rounded) N - 1 is generated. 
<bullet>"arr = rand(scalar Size, scalar N [, bool NoDuplications] ) - Nonvoid; returns a list array of size 'Size', N functioning as above. If N >= 2 (so that an integral value is returned), then a 3rd. argument, if present and 'true', ensures that no value in the returned array will be duplicated. (If N < Size, this is impossible; an error will be raised.)
<bullet>"rand(ArrName, scalar N [, bool NoDuplications] ) - Void; the array's contents are overwritten by random numbers. The remaining arguments function as above.
If 'Size' is < 1 or 'ArrName' is invalid, an error is raised.

 
<B>randum</B>(scalar NoBytes) -- Returns NoBytes random bytes generated by the Linux kernel rather than through Mono; the returned array holds one byte (0 to 255) per element. Hugely slower than "rand(Arr, 256)" for NoBytes 1000 or below, and still 3 times slower for very large sizes. Only useful where you want the purest possible supply of random bytes, not generated in accordance with a seed as in Mono.


<B>randsign</B>(scalar or array Original [, PropnOfPlusses] ) -- returns a copy of 'Original' with all of its values multiplied randomly by +1 or -1. The probability of multiplication by +1 is 0.5 if no second argument is supplied. If it is supplied, it MUST lie between 0 and 1 (inclusive), or a crash occurs.


<B>randgauss</B>(..) -- generates a random no. of Gaussian distribution. It comes in a VOID and a NONVOID form. The nonvoid form first:
\t"<# blue>x = randgauss(mean, SD [, LowLimit, HighLimit] );<# black>" generates a value with mean and standard devn. as shown. The extremes of possible returned values are ± 5.476 standard deviations from the mean. (As a rough guide, normal curve heights, as a fraction of the maximum, are: 1 SD -- 0.61;  1.5 SDs -- 0.32;  2 SDs -- 0.14;  2.5 SDs -- 0.04;  3 SDs -- 0.01;  3.5 SDs -- 0.002;  4 SDs -- 3 e -4;  4.5 SDs -- 4 e -5;  5 SDs -- 4 e -6.)
You can supply <I>exactly</I> two further scalar arguments, LowLimit and HighLimit. If they are present, the function will only return values within that range (inclusive). But there are restrictions: (1) the window must be wider than SD/10 (the underlying algorithm would take too long, as it has to keep producing values till it finds one in range); and (2) the window must not be further away from the mean than 4 SD's (for the same reason). In both cases an error will be raised.

\tAnd the void form:
\t"<# blue> randgauss(xx, mean, SD [, LowLimit, HighLimit] );<# black>" fills variable xx (whether scalar or array) with random gaussian numbers over the same range as above. This form also may have exactly two extra parameters, precisely as above.
\tSee also <# blue>seed(..)<# black> below, where generation is discussed.
\tAnd see also function <b>perturb(.)</b>, which allows you to perturb a whole array in a Gaussian random manner.

<b>randrange</b>(NamedVariable, scalar / array LowLimit, scalar / array HighLimit [, IntegersOnly] ) -- Always VOID. The first argument must be either a named array or a named scalar; the random values will be inserted into the variable, overwriting any preexisting data. If the limits are the wrong way around, they will be reversed internally. If the last argument is present and TRUE, then LowLimit and HighLimit will be rounded, and returned values will be integral, in the range INCLUSIVE of both limits.
If LowLimit and HighLimit are not both scalars, then they must both be arrays, and must have the same length as NamedVariable (which cannot be scalar); in this case, NamedVariable[i] will be developed using limits LowLimit[i] and HighLimit[i].
  _________________________

<B>seed</B>(<# blue>[Scalar]<# black>) -- a void function which resets the seed value for the calculation of random numbers (using <# blue>rand (..)<# black> or <# blue>randarr(..)<# black>). The argument (which should be in the range 1 to 2,147,483,647 - which is hex 7FFF FFFF) is always rounded. If it rounds to less than 1 (i.e. is 0.5 or below), or is omitted, then an internal NET generation method applies, using a value obtained from the computer clock. Otherwise the supplied number (rounded) becomes the seed. A new internal random seed is always generated before all user programs, so 'seed()' is normally not necessary. NB: If you do use 'seed()' (empty argument) to randomize the seed, DO NOT include it in a loop, as the loop will usually operate much faster than the changes of system clock used internally, so that you will in fact have long runs with the same seed being generated each time.

==================================================================
//READGRID  -- see ANIMATE 
//REAL  -- see COMPLEX 
//REDIM -- see DIM
//REDIMLIKE -- see DIM
==================================================================
//REMOVEDUPS//
//REMOVERUNS//
<b>REMOVING DUPLICATIONS WITHIN AN ARRAY</b>

There are two functions for this:
<bullet><b>removedups(.)</b> removes all duplicated values <i>whether those values are consecutive or not.</i>
<bullet><b>removeruns(.)</b> removes duplications <i>that occur consecutively, as runs</i>.

Consider for example the array "AABCA". The first function would note that there is more than one 'A' in this array, and so would keep the first instance and remove the rest, to return "ABC". The second function would only be looking for runs, and on finding a run "AA" it would replace this with "A"; so the function would return "ABCA".

There is a further difference [that may later be rectified]: <b>removedups</b> as currently written will remove all duplications of all values; it cannot be set to e.g. remove duplications of just "A". On the other hand, <b>removeruns</b> can either range across all values or can be set to remove only runs of a particular value. [Maybe in the future it might be possible to specify more than one such value.]

A final difference is that <b>removedups</b> can be used to remove duplicated rows or columns from a matrix.

In detail...

<b>removedups(<# blue>Array)</b> <# black> -- the returned array will be a copy of Array with all duplicated values removed. E.g. the array [1, 2, 1, 2, 3, 3] would produce a returned array [1, 2, 3]. The structure of Array is ignored; the returned array is always a list array, of the same 'chars' rating as 'Array'.

<b>removedups(<# blue>Matrix,  array RowsOrColumns)</b> <# black> -- the returned matrix will have duplicated rows removed, if RowsOrColumns[0] is 'R' or 'r', or duplicated columns removed if RowsOrColumns[0] is 'C' or 'c'. Any other value of RowsOrColumns[0] would raise an error. 


<b>removeruns(<# blue>InArray [,  scalar / array OfThese ] )</b> <# black> -- the returned array will be a copy of InArray with runs of values replaced by a single value. For example,  <# blue>removeruns("AAABAADD")<# black>  would return "ABAD".

If a second argument is supplied, just the value(s) in it will have runs removed; runs of other values will remain. E.g.
	<# blue>aa = removeruns("AAABBBCCCDDD", "BD");<# black>
would return "AAABCCCD".

The structure of InArray is ignored. The output array is always a list array, of the same chars. rating as InArray.
  ______________________________

If you only want to <b>detect duplicates</b>, use function <# blue>prevalence(.)<# black> instead.
==================================================================
//REMOVEPLOT -- see KILLGRAPHS
==================================================================
//REORDER//
<B>reorder</B>(<# blue>array Key,   arrays Array1[, Array2...]]<# black>) -- Void.

<i>Key</i>  is an array of size N which contains integers within the range 0 to N-1 (after rounding), which will represent addresses in Array1, Array2...

<i>Array1, Array2</i>...  are initialized arrays (not array expressions), which will have their contents altered. They all must be of the same size as Key.

Elements of each of Array1, Array2..  will be reordered according to the rule:  Array[i]  <--   Array[ Key[i] ].

Duplications within KeyArray are legal.

Example (which does involve duplication): 

\t<# blue>arr1 = data(10, 20, 30, 40, 50);
\t<# blue>key1 = data(4,3,2,1,4);
\t<# blue>reorder(key1, arr1); <# magenta>// arr1 becomes: [50, 40, 30, 20, 50]<# black>
==================================================================
//REPARTITION//
//REPOSITION//
<b>MOVE / RESIZE THE MONOMATHS INSTANCE OR ITS WINDOWS</b>

To change the position and size of the <i>MonoMaths instance as a whole</i>, use function <b>reposition(.)</b>.
To keep the current position and size but to change the relative heights of its two windows, use function <b>repartition(.)</b>.


<b>reposition(<# blue>new left, new top, new width, new height<# black>)</b> -- the four values may be supplied as any mix of scalars / arrays, but there must be exactly four.

RETURNS a list array of size 4: [final left, final top, final width, final height].

If any dimension is negative, that dimension will not be altered. (So if you only want existing data, and not to change anything, set all four values to e.g. -1.)
Any dimension  >= 0 and <= 1 is taken as a fraction of screen width / height as appropriate.
Any dimension > 1 is rounded and taken as pixels.

Impractical values are corrected back to feasible values before  being applied.


<b>repartition(<# blue>array WhichWindow, scalar NewHeight<# black>)</b> -- WhichWindow[0] must be 'A' (Assignments Window) or 'R' (Results Window) - case-sensitive. As above,
Any dimension  >= 0 and <= 1 is taken as a fraction of screen height;
Any dimension > 1 is rounded and taken as pixels.
Impractical values are not corrected by MonoMaths; the underlying Mono Gtk will do what it will, if you supply an impractical value.

RETURNS the final window heights (in pixels) as a list array of size 2: [AsstWindowHt,  ResWindowHt]. If no changes occurred (see below), these will be the existing heights.

If WhichWindow is not 'A' or 'R', no changes occur. (WhichWindow is allowed to be scalar, in which case it would have to be the unicode value for one of these.)
If NewHeight (after rounding) is 0 or negative, no changes occur. (Hence either of these two 'errors' may be used simply to return existing heights without change.)
If NewHeight \> (combined window heights ‒ 20), it is corrected down to this value.
Be warned that NewHeight \< 20 works oddly with small MonoMaths instances; use trial and error for a chosen size of instance, to find the right smaller value.

No errors are raised (apart from using the wrong number of arguments). If NewHeight is an array, it will be taken as scalar 0.
==================================================================
//REPLACE, REPLACETO  --  see COPY
//REPLACEROWS,  REPLACECOLS  --  see INSERTROWS
//REPOSITION -- see REPARTITION
==================================================================
//REQUEST//
<b>DATA INPUT USING A DIALOG BOX</b>

The function to use is <b>request(</b><# blue>Btn, Heading, BodyText, Label1, Content1 [, Label2, Content2, [ ... ] ] , ButtonsEtc <# black><b>)</b>. It returns the data as an array, and also sets the value of "Btn".

<i>Btn</i> MUST be a predefined scalar variable; the function will reset its value to the code of the button that closed the dialog box.

<i>Heading</i> is the short snippet of text which goes inside the title bar of the dialog box. (No formatting tags are valid.)

<i>BodyText</i> is explanatory text which can be much longer; it will be printed above the textboxes. Only Pango text formatting can be used, which includes the following tags, all of which must be strictly paired: "\<b> .. \</b>", "\<i> .. \</i>", "\<u> .. \</u>", superscript "\<sup> .. \</sup>", subscript "\<sub> .. \</sub>". For more Pango options (including colouring), enter 'format' into the Assignments Window and press F1; scroll to the end of the display.

<i>Label - Content pairs</i>:  Any number allowed (but at least one pair). The number of text boxes is set by how many pairs you supply. 'Label' is the text displayed to the left of the text box, and 'Content' is its initial content. If either is scalar, the corresponding string in the dialog box will be the empty string. 

<i>ButtonsEtc</i> - A set of button titles delimited by '|'; e.g. "ACCEPT|CANCEL". You can have any number of buttons, but at least one. Buttons are displayed from left to right on the dialog box in the order supplied.

The 'Etc' refers to an optional final substring, which must be introduced by "#:", and which tells the function what to do in each text box if ENTER is keyed while the box is in focus. The whole string might look like this: "ACCEPT|CANCEL|#:101, 102, 1". Note that one or more integers follow the "#:", and that they are delimited by commas. (Spaces are ignored.) There should be one integer per text box. The integer codes have the following meanings:
<bullet>-1:  Close the dialog box, after setting the REF argument <i>Btn</i> to 100 + the no. of the text box (the first box being no. 0).
<bullet>0:  Do nothing. (This is the default, if this 'Etc' substring is omitted.)
<bullet>1, 2, 3, ...:  Send focus to the button of this number (1 being the leftmost button).
<bullet>100, 101, 102, ...  Send focus to textbox 0, 1, 2, ....

To set the size of the dialog box to other than the default, use function <b>setbox</b>.

<u>Special Case:</u>  It is possible to condense several label - content pairs into a single pair, using the 3-character delimiter <b>{|}</b> between labels in Label1, and the same number of instances of the same delimiter in Content1. (Of course in such a case, there must be no Label2 and Content2 as further arguments.)  The purpose of this is to allow you to set the number of text boxes at run time, if necessary, rather than design time. Empty content is allowable; for example, if you have chosen three text boxes and want them all to be blank, you can set Content1 to "{|}{|}".


<b>RETURNED</b>
(a) The button click which closed the dialog box is automatically stored in the named argument variable Btn. It will be 0 if the user closed the box using the corner icon; otherwise it will be the number of the button, the leftmost button (and the first referenced in argument 'Buttons') being 1. (If you used the 'Etc' part of 'ButtonsEtc', and set up for text box no. N to cause the dialog to close, then if that happens the return will be 100 + N. Note that text boxes are numbered from 0 upwards.)

(b) The data in the text boxes when the dialog is closed.
If only one text box was present, this will be a chars. array, trimmed of white spaces at both ends. If the text box was empty, it will be an array of size 1, containing the space character.
If there were multiple text boxes, the return is a 'jagged matrix' containing the contents of all boxes, the first box corresponding to row 0. Before the jagged matrix is built, the text box content is trimmed at both ends. In the process of building the jagged matrix, MonoMaths pads smaller rows out to the size of the longest text, using the space character for padding. In the event that all boxes were empty at the time of closure, the matrix will have size (No. boxes x 1), each row consisting of a single space.

<b>PROCESSING THE DATA</b>
There is <b>no internal parsing</b> of data by this function; whatever is typed (or not) in the box is returned. However you may parse scalar and array data using the function <# blue>stringtovalue(..)<# black>. Here is an example, where an array is expected:

	<# blue>scalar Btn; <# magenta>// Must be defined before its use in "request(.)".
	<# blue>Heading = "ENTER AN ARRAY";
	BodyText = "Enter an array in the top box and a scalar in the bottom box. For the array, use the comma ',' to separate values.";
	Label1 = "Your array:";
	Content1 = 0; <# magenta>// This will cause the text box to be blank at the start.
	<# blue>Label2 = "Your scalar:";
	Content2 = "0.0";
	Buttons = "ACCEPT|CANCEL";
	isValidData = false;
	scalar X;   array Arr; <# magenta>// These will be assigned the user's input values.
	<# blue>while (true)
	{\tjaggo = request(Btn, Heading, BodyText, Label1, Content1, Label2, Content2, Buttons);
	\tif (Btn != 1) break; <# magenta>// User cancelled. Outside the loop, this is recognized because 'isValidData' remains false.
	<# magenta>// Retrieve the text box contents:
	<# blue>\tbox0 = unjag(jaggo, 0); <# magenta>// This automatically removes any padding of spaces at the end of the box's text.
	<# blue>\tbox1 = unjag(jaggo, 1);
	<# magenta>// Check validity of entries, and only leave the loop if both boxes contained valid data:
	<# blue>\tArr = stringtovalue(box0, ",",  NAN); // the return for incorrect formatting is set as NAN.
	<# blue>\tif (empty(Arr))  <# magenta>// 'empty' is TRUE for an array consisting only of NAN.
	<# blue>\t{  show("Unable to decode the array. Try again.");  continue;  } <# magenta>// Redisplay the dialog box.
	<# blue>\tX = stringtovalue(box1, MAXREAL); <# magenta>// This sets MAXREAL as the scalar returned if there is a formatting error.
	<# blue>\tif (X == MAXREAL)
	<# blue>\t{  show("Unable to decode the scalar. Try again.");  continue;  } <# magenta>// Redisplay the dialog box.
	<# magenta>// Both values are valid, so exit the loop, after setting 'isValidData':
	<# blue>\tisValidData = true; break;
	}

===============================================================
//REVERSE//
//REVERSED//
<B>reverse</B>(<# blue>Named Array<# black>) -- VOID; reverses the contents of the array, wihtout interfering with its structure or characters rating.
<B>reversed</B>(<# blue>any no. of variables<# black>) -- NOT void; returns a list array consisting of all the data contained in the variables - whatever their type or structure - but in reverse order. (Returned array is of 'non-characters' type.)
==================================================================
//RGB//
<b>RETURN THE RGB VALUES FOR A NAMED COLOUR</b>

<b>rgb</b>(<# blue>ColourRef [, DefaultColourRef ]<# black>) -- Always returns an array of size 3.

If 'ColourRef' can be identified as a colour, then the return has values:
<bullet>[0] = R(ed) value (0 to 255);
<bullet>[1] = G(reen) value;
<bullet>[2] = B(lue) value.

If 'ColourRef' cannot be identified, but 'DefaultColourRef' is present and a valid colour reference, then it is returned instead, in the same manner.

Otherwise the return is an array of all zeroes (equivalent to the colour black).

'ColourRef' can be:
<bullet 30,1.> A recognized colour name (type 'colour' and key F1, for list of allowed names; spaces are ignored);
<bullet 30,2.>  An integer (can be negative);
<bullet 30,3.>  Three values, taken as the R, G, B values (in which case using this function is pointless);
<bullet 30,4.>  four values, the first of which will be ignored (this allows for an unused 'brightness' byte; the rest are R, G, B values); 
<bullet 30,5.>  a hex number of length 6 digits, preceded by '0x' ('0' = zero, not the letter O); format "0xRRGGBB". (It accepts 8 hex digits also, ignoring the first 2, as for item 4 above).

Wherever 'gray' occurs in a legal name, the UK English version 'grey' is also allowed.
==================================================================
//ROTATE//
//ROTATEROW//
//ROTATECOL//
//SWAP//
<B>ROTATING / SWAPPING VALUES</B>

The main function to use is <b>rotate(.)</b>. It can do the following tasks, distinguished from one another by the number and types of arguments. In all cases the positive direction of rotation is movement of data to a higher index (if within an array); or to the next argument on the right (where variables are swapping their entire content with one another). All versions are VOID; they directly change their arguments. (These arguments need not be named variables, except for case 1 below when all arguments are scalar).

If you just want to rotate the contents of one row or one column of a matrix, the functions are <b>rotaterow(.)</b> and <b>rotatecol(.)</b>.


<u>1.  ROTATING THE ENTIRE CONTENTS OF VARIABLES TO OTHER VARIABLES</u>
Use <# blue>rotate(two or more variables)<# black> -- void. Variables in the list must be of the same type (all scalar or all array). If arrays, they must all have the same total size (though their dimensional structure will be ignored and may differ). "rotate(aa, bb, cc)" resets bb to have aa's old value, cc to have bb's old value, aa to have cc's old value.

<u>2.  ROTATE VALUES WITHIN ONE ARRAY</u>
Use <# blue>rotate(Array [, scalar NoTimes])<# black> -- a void function. The contents of the array are rotated the given number of times. If 'NoTimes' is positive, values move to higher indexes (e.g. if NoTimes is +1, the contents of [0] become the contents of [1]). If negative, downwards. If NoTimes is omitted, it is taken as +1. (If it is present but 0, no rotation occurs.) NoTimes may overflow or underflow the size of Array, as its modulo is used.
Array structure is unaffected; only the internal data strip is affected. For example, in a 2x3 matrix 'Mx', with NoTimes = 1, data in Mx[0, 2] will be moved to Mx[1, 0], and Mx[1, 2] will be moved to Mx[0, 0].

<u>3.  ROTATE ALL ROWS OR COLUMNS OF A MATRIX</u>
Use <# blue>rotate(Matrix, IsRows, NoTimes [, scalar/array Replacement) ]<# black>.
<i>IsRows:</i>  a boolean, to tell whether you want to rotate rows of the matrix or columns.
<i>NoTimes:</i>  As above. If positive, the contents of row/column 0 goes to row/column NoTimes. Overflow or underflow is no problem, as the modulo is taken.
<i>Replacement:</i>  If this argument is absent, 'wrapping' occurs; all the original rows and columns are preserved, but in a new order. If present, then the supplied value will replace the last row or column at each rotation by one. Replacement may be scalar (in which case the new row or column will be wholly made up of its value) or an array. If an array, its size must exactly match the row or column size of the matrix, as appropriate.

There is no argument 'Replacement' for type 2 above; to get the same effect you would have to redimension 'Array' to a 1 x N matrix and then use type 3.

<u>4.  ROTATE CONTENTS OF A SINGLE ROW OR COLUMN IN A MATRIX</u>
The two functions are:
<# blue>rotaterow(Matrix, RowNo [, NoTimes [, scalar/array Replacement [, scalar StartAt [, scalar EndAt ] ] ] ] )<# black>.
<# blue>rotatecol(Matrix, ColNo [, NoTimes [, scalar/array Replacement [, scalar StartAt [, scalar EndAt ] ] ] ] )<# black>.
<i>Matrix:</i> should be a named matrix. No error is raised if it is not, but you will never see any result.
<i>NoTimes:</i>  As above; can be positive or negative. If absent, defaults to 1. If NoTimes = N, then for <i>rotaterow</i> the contents of Matrix[i, j] goes to Matrix[i, (j + NoTimes) modulo row length ]. For <i>rotatecol</i>, the contents of Matrix[i,j] goes to Matrix[ (i + NoTimes) modulo no. rows, j].
Overflow or underflow is no problem, as the modulo is taken.
<i>Replacement</i>: If omitted, or if it is an array (any array, but we suggest: "wrap"), wrapping of values will occur; e.g. the row "[1, 2, 3]", rotated once, will become "[3, 1, 2]". If present and scalar, values left empty will be filled with this value. E.g. if Replacement is 99, the row rotated once becomes "[99, 1, 2]".
<i>StartAt, EndAt</i>: If present, they define a subrange of the row or column which will rotate; the rest of the row or column will remain exactly as before. For example, for row [0, 1, 2, 3, 4, 5, 6], with StartAt = 2 and EndAt = 4, rotating once produces [0, 1, 4, 2, 3, 5, 6] (if wrapped) or [0, 1, 99, 2, 3, 5, 6] (if not wrapped, with Replacement = 99).
If StartAt is negative it is adjusted to 0. If EndAt is negative or beyond row / column end, it is adjusted to that end. If the pointers cross, simply no rotation will occur.

==================================================================
//ROOTSTOPOLY -- see POLYNOMIAL
//ROUND -- see MOD
==================================================================
//ROWOP//
//COLOP//
<B>REPLACING A ROW/COLUMN WITH A LINEAR COMBINATION OF OTHER ROWS / COLUMNS</B>

You have a matrix Mx, and want to replace row1 with, say, 2* row2 + row3; <B>rowop(..)</B> is the one for you. (Or you could replace row1 with 3*row2 + const; or simply 3*row2.)  Or, if it is a square matrix, you may want to replace column 0 with, say, row1 * column1. The same function will do all of these easily. <B>colop(..)</B> is analogous, to replace a column.

<B>rowop</B>(<# blue>matrix Mx, scalar RowNo, scalar Coeff1, array isRowOrCol1, scalar RCNo1 [, array Sign, scalar Coeff2, array isRowOrCol2, scalar RCNo2] <# black>) -- VOID. Replaces the row RowNo in the Matrix with data, derived as follows. Suppose Coeff1 is 10, isRowOrCol1 is 'R' (for 'row'), RCNo1 is 2 (for row no. 2). Then for the 5-argument version, we would replace Mx[RowNo] with 10*Mx[2]. Continuing on with the 9-argument version, Suppose Coeff2 is 100, isRowOrCol2 is 'C', and RCNo2 is 3. (This would have to be a square matrix, if we are combining a row and a column.) Finally, suppose 'Sign' is '-'. Then row Mx[RowNo] would be overwritten by:  10*Mx[2]  -  100*Mx[ ][3].

<I>isRowOrCol1</I>:  Only the first char. is examined. 'R','r' tells us that RCNo1 is a row no; 'C','c' that it is a column no. Any other value - e.g. a space ' ' - will generate a row or column of appropriate length but containing all ones; in effect, you will be replacing every value in Mx[RowNo] with Coeff1. This is fairly pointless for the first term, but more useful for the second term, where for example you want Mx[RowNo] to be replaced by (Coeff1 * row1 + a constant, Coeff2).

If you use the ' ' option, then you can use any value for RCNo1, as it is not accessed.  '-1' is not a bad option.
 

<I>Sign:</I>:  Only recognized ones are " + - * / "; any other crashes. There is no test, in the case of division, for zero in the divisor; you have to precheck that in the rare situation where you would want to use this sign.


<B>colop</B>(<# blue>matrix Mx, scalar ColNo, scalar Coeff1, array isRowOrCol1, scalar RCNo1 [, array Sign, scalar Coeff2, array isRowOrCol2, scalar RCNo2] <# black>) -- All the above applies, the only difference  being that you are overwriting a column, rather than a row.

<U>EXAMPLE</U>
<# blue>Mx = fill(12, 1, 1);   redim(Mx, 3, 4);
<# magenta>// Replace row 0 with K1 * row1 + K2 * row2. We will use K1 = 10, K2 = 1000.
<# blue>VictimRowNo = 0;  <# magenta>// will be overwritten.
<# blue>K1 = 10;   K2 = 1000;
<# blue>Row1 = 1;  Row2 = 2;
<# blue>writeln("Before:", 10, neat(Mx) );
<# blue>rowop(Mx,  VictimRowNo,    K1,  'R', Row1,    '+',      K2,  'R', Row2);
<# blue>writeln("After:", 10, neat(Mx) );

<# black>The output will be:
<# blue>Before:
<# cyan> [0]  <# blue>1, 2, 3, 4;
<# cyan> [1]  <# blue>5, 6, 7, 8;
<# cyan> [2]  <# blue>9, 10, 11, 12;
colours
<# blue>After:
<# cyan> [0]  <# blue>9050, 10060, 11070, 12080;
<# cyan> [1]  <# blue>5, 6, 7, 8;
<# cyan> [2]  <# blue>9, 10, 11, 12;
==================================================================
//ROWVEC -- see DATA
==================================================================
//RUN -- see EXEC
==================================================================
//SAMPLING//
//SAMPLE//
//UPSAMPLE//
//DOWNSAMPLE//
<B>upsample</B>(<# blue>Array, Scalar UpsamplingRate, variable Method [, Scalar StartPtr[, Scalar EndPtr [, Scalar LopCount ]]]<# black>) -- Nonvoid. Returns a list array, the result of upsampling the data in Array.

<i>Array</i> -- may have any structure, but must contain at least 3 data items. Whatever its structure, the returned array is always a list array.

<i>UpsamplingRate</i> -- This is rounded; the resulting integer should be ≥ 2, for upsampling to occur. If it is ≤ 1, the function simply returns a copy of the data of the original array (as a list array), ignoring remaining arguments.

<i>Method</i> -- If Method is 'Z' or 'z' or 0, interpolated values are all zero. If 'L' or 'l' or 1, linear interpolation occurs. If 'S' or 's' or 2, stepwise interpolation (the previous value is perpetuated over the interpolation interval). If 'C' or 'c' or 3, cubic splining is used, giving something looking like a polynomial fit curve.

<i>StartPtr, EndPtr</i> -- If supplied, only that part of the data within the defined subarray will be upsampled; but the returned array still contains the original data before StartPtr and after EndPtr.
If EndPtr is too large, it is internally downsized to the last member of the array, without error. Don't mess with StartPtr, though.

<i>LopCount</i> -- If present and a sensible value, that no. of values are lopped off the end. (The main use: set to 1 with stepwise upsampling, where you don't want the final riser included, but just want to end on a flat top step.) You can use '-1' as a filler for StartPtr and/or EndPtr where you are supplying LopCount (in which case they assume default values).

EXAMPLE: 
\t<# blue>arr = data(1,2,1,2,1);  newarr = upsample(arr, 10, 'C'); <# magenta>// try 'L', 'S' and 'Z' also
\t<# blue>writeln(newarr);
\tgraph(plot(newarr));

<# black>A particular situation, frequently needed: we have an array ArrIn = [0, 1, 2], and from it we want to develop a step series like this: [0,0,0, 1,1,1, 2,2,2]. The way to do it:
\t<# blue>ArrIn = data(0,1,2); <# magenta>// In a practical case, has been defined earlier in the program somewhere.
\t<# blue>ArrOut = upsample( data(ArrIn, 0), 3, 'S', -1, -1, 1); <# magenta>// Add a dummy value onto the end of ArrIn; later, lop it off - the final '1' organizes this.
<# black>

<B>downsample</B>(<# blue>Array, Scalar DownsamplingRate[, Scalar StartPtr[, Scalar EndPtr]]<# black>) -- Suppose StartPtr and EndPtr are left out. Then what happens is this: the first element and then every (DownsamplingRate)th. element is retained. E.g. for input array [0,1,2,3,4,5,6,7] and rate 3, the return is [0,3,6]. If StartPtr is > 0, then all before it is retained untouched, and the retaining count starts at StartPtr.  (For the above, with StartPtr 2, the return would be: [0,1;  2, 5].)  Also, all values after EndPtr (if supplied) are retained.

The structure of Array is ignored; it is treated as if all of its data were in a list array. The returned array is a list array.

StartPtr can be negative, in which case downsampling notionally starts from that negative index, even though the input array is not referenced till its index has incremented to 0. This is useful if you want the downsampled array to start with Array[p] (where 0 < p < downrate) rather than with Array[0]. To achieve this, set StartPtr to (p - downrate).

Excessive EndPtr is trimmed back to the end of the input array. Crossed pointers is an error, as is a rate below 1 (though 1 is allowed, trivially returning the array untouched).
============================================================
//SAVE//
<just c><b>SAVING DATA TO A FILE</b>
<just l>
There is a single function, <B>save(..)</B>, which handles this task. It has four different working modes, distinguished by the first argument. Different modes require different numbers of arguments, and the same arguments are in some case differently deployed for different modes. The general format of the function is:

<b>save</b>(<# blue>array <b>Mode</b>, array <b>Data</b>, array <b>FileName</b>, array <b>WhatIfFileExists</b>,  Argument5, Argument6, array <b>DefaultExtension</b><# black>).

The <b>return of the function</b> is simply boolean - 'true' if the file was successfully saved. However it is more useful to use the associated functions <b>iok()</b> and <b>iomessage()</b> for testing success; their use is described lower down this page.

The modes are as follows. Where arguments are irrelevant to the mode (and so can be any value of any type), I have replaced them by the word "<# magenta>dummy"<# black>. The arguments are described further down.

<u>1.  SAVING TEXT</u>
<b>save</b>(<# blue><b>'T'</b>, array <b>Data</b>, array <b>FileName</b>, array <b>WhatIfFileExists</b> [,  <# magenta>dummy,  dummy,  <# blue><b>DefaultExtension</b> ]<# black>) -- The function treats the array Data as being a set of UTF8 character unicodes, and save it as such in a text file. (There is some built-in protection against impossible codes: negative values and NaN translate to 0, and values above 65535 translate to that value. But there are unicodes below 65535 which do not correspond to UTF8 characters and could lead to a crash. So use the function sensibly.)

<u>2.  SAVING AN ARRAY IN CODED FORM</u>
<b>save</b>(<# blue><b>'A'</b>, array <b>Data</b>, array <b>FileName</b>, array <b>WhatIfFileExists</b> [,  bool <b>ApplyPrefix</b> [, array <b>Description</b> [, array <b>DefaultExtension</b> ] ]<# black>) -- The underlying Mono platform - like .NET - has a method which codes each double into eight bytes. This is used here, so that the resulting file will have a size which is eight times the size of the array. The data in the array is taken straight from the internal data strip, with no regard to its structure.

If <i>ApplyPrefix</i> is missing or 'false', this is all that happens; there is no information in the file as to how the array was structured. If 'true', then the array data is preceded by a prefix which encodes the array's name (if it had one), its dimensions and its chars. rating, together with the time as at the moment of saving (as the number of seconds since the start of the year 1AD). This is read by the analogous function <i>load('A', ...)</i>, which will return an array of the same structure and chars. rating. (See the help file for function 'load' to see how to retrieve this recorded information.) If you want the prefix to contain other data (e.g. explanatory text, or a message to your mother), you can supply that data in the final optional argument <i>Description</i>; such data will be inserted into the prefix <i>instead of</i> the array's name. As long as your added text does not contain two colons together, any printable characters can be used; but spaces will be trimmed from the ends.

<u>3.  SAVING MULTIPLE VARIABLES IN A HUMANLY-READABLE TEXT FORMAT</u>
<b>save</b>(<# blue><b>'F'</b>, array/scalar <b>Data</b>, array <b>FileName</b>, array <b>WhatIfFileExists</b>,  array <b>VarNameInFile</b> [,  <# magenta>dummy,  <# blue>array <b>DefaultExtension</b> ]<# black>) -- Saves the data in a specifically formatted form, but one that is easily human-readable. Such a file may contain more than one variable; <i>save('F', ...)</i> can be used either to create the file or to append new data to an existing such file. (Only one variable at a time may be saved by the 'save' function call.) As this file format is verbose, it is not practical for very large arrays; but it has the advantage that it alone allows for scalars to be saved. Later, when you want to retrieve the data, you will use the instruction <b>load('F', ...)</b>. (For the curious, the formatting system is detailed at the end of the Help section 'Data I/O and Display'; but such knowledge is not required to use 'load('F', ...)' and 'save('F', ...).)

<u>4.  SAVING DATA IN THE FORM OF 8-BIT BYTES</u>
<b>save</b>(<# blue><b>'B'</b>, array <b>Data</b>, array <b>FileName</b>, array <b>WhatIfFileExists</b> [,  <# magenta>dummy,  dummy,<# blue>  array <b>DefaultExtension</b> ]<# black>) -- will save data stored in an array as bytes, but ONLY IF every element of the array rounds to a value between 0 and 255 inclusive; if any values are outside this range, the function will fail.


<u>MORE ON THE ARGUMENTS</u>
<b>Data</b>: It must be an array (except for mode 'F', where it may be scalar). Further restrictions on values for particular modes are as described above.

<b>FileName</b>:  If no file path precedes the name, the current data path will be used. The shortcut "~/" is allowed for the user's personal home directory. If 'FileName' is empty (spaces only) or begins with '?', a dialog box will open for user choice of file. Also if 'FileName' is a directory (and so ends in '/'), a dialog box will open at that directory.
Leading and trailing spaces are trimmed from 'FileName', together with unicode 0, so that a row from a jagged array (as, for example, produced by function 'split(.)') can be used as is.

<b>WhatIfFileExists:</b> If the file already exists, action will be taken in accordance with the first character in this array. To overwrite without asking, use the letter 'O' or 'o'. Where the file may possibly already exist, and you want to either create it (if it does not yet exist) or append to it (if it does exist), use 'A' or 'a' here. Any other value for this argument (we suggest '?') will provoke a dialog box, if the file exists. 

NB: Don't use 'A' or 'a' if you are saving in mode 'A' AND supplying a prefix. The function will still work, but when appending it will not take any notice of the preexisting file's prefix, which therefore will indicate wrong dimensions for the appended file. When you reload the file you will get a warning message; there will not be a crash, but you will have to manually skim off the prefix from the returned array, to get at the valid data.

<b>VarNameInFile:</b> This does not have to be the original name of the variable; use any text and any printable characters <i>except for the colon</i> ':' (which is used in the text file format to delimit the name). Leading and trailing spaces will be trimmed off, but internal spaces remain. <b>NB:</b> there is no check for duplication of name; if a variable with the same name is appended to an existing file, the corresponding function <i>load('F', ...)</i> will only ever find the first instance.

<b>DefaultExtension</b>:  This is only relevant where a dialog box will open and the user will choose or enter a file name. If this argument is present and is an array (hopefully of unicodes), it will automatically be added to whatever the user has put into the file name text box, <i>but only if</i> the file name does not already contain a full stop '.'.  Therefore if the user wants to override the default extension, he ends his file name in the textbox with the stop.
DefaultExtension may be written with or without an initial stop (e.g. "txt" and ".txt" both have the same effect).


<u>TESTING FOR SUCCESS</u>
All modes of <i>save(.)</i> RETURN a boolean, 'true' if saving was successful. But rather than test for this, it is usually better to use the function pair <b>iok()</b> and <b>iomessage()</b> - both with no arguments. The information which they hold will persist until the next disk operation. They behave as follows:
<bullet><i>Saving was successful:</i>  <b>iok()</b> returns 'true'. (There is no need to consult iomessage() in this case; but if you do, it will have length 1, consisting of a single space.)
<bullet><i>Saving failed, raising an error:</i>  <b>iok()</b> returns 'false', and <b>iomessage()</b> returns the error message.
<bullet><i>There was a dialog box, and the user cancelled out of it:</i> <b>iok()</b> returns 'false' as above, but this time <b>iomessage()</b> returns an array of length 1, consisting of a single space. (Error messages never begin with a space.)


<u>RETRIEVING THE FILE NAME</u>
If the call to 'save' evoked a dialog box, then you might like to know what was the user's final choice of file name. The function to use is <b>iofile(.)</b>, which like the above two functions, holds its data until the next disk operation. Its use:
<bullet><i>iofile()</i> -- returns the full path and file name.
<bullet><i>iofile('P')</i> -- returns the path only.
<bullet><i>iofile('N')</i> -- returns the file name only.


<u>OTHER USEFUL FILE FUNCTIONS</u>
(Details of use not given here).
<b>choosefilename</b> -- Opens a file dialog and enables the choice of one or more file names from that directory.
<b>currentdirectory</b> -- gets or sets the current directory (i.e. the directory at which file dialogs will open by default). 
<b>homedirectory</b> -- Returns the current user's personalized home directory, e.g. "/home/fred/".
<b>checkdirectory</b> -- returns 'true' if this directory exists AND is also accessible. 
<b>filesize</b> -- Returns the file size, or -1 if the file does not exist (and so is useful as a test for the existence of a file).

============================================================
//SCALE//
//SCALEFORMATX//
//SCALEFORMATY//
//SCALEFORMATZ//
//SCALEFUDGEX//
//SCALEFUDGEY//
//SCALEFUDGEZ//
//SCALEOVERX//
//SCALEOVERY//
//SCALEOVERZ//
//SCALEJUMPX//
//SCALEJUMPY//
<U>MODIFYING OR OVERRULING AUTOMATIC SCALING</U>
In all of the following functions, <B>the graph ID must be present</B>.
Also, only the X axis versions are described; in each case, change the 'x' in the function name to 'y' or 'z' for use with other axes.

<B>(a) Don't have every hairline labelled.</B>
<i>(Works for 2D graphs only.)</i> You can cause some automatic scaling tags to be dropped. Suppose we count the left extreme of the X axis as division 0, and then call the successive hairlines division 1, 2, 3, ... We require that the first hairline to be labelled will be hairline 1, and thereafter every 3rd. hairline: { 1, 4, 7, ...}. The function call is:
\t<# blue>firstLabelled = 1;  hairlineJumps = 3;
\t<# blue>scalejumpx(graphID, firstLabelled, hairlineJumps);
<# black>
<B>(b)  Multiply automatic scaling values by a scaling factor and a suffix</B>
<i>(Works for 2D graphs only.)</i> Suppose you are graphing a trigonometric function; the X axis is to extend from 0 to 2 π. You want four segments between these two limits. If you use the function "gridx(0, 2*π, 4), the automatic scale generation will supply these scale tags: "0,  1.571,  3.142,  4.712,  6.283". You can change this to "0 π,   0.5 π,   1 π,   1.5 π,   2 π " using this function call:
\t<# blue>scalefudgex(graphID, 1/π, " π"); <# magenta>// note the leading space before 'π'. You must supply such a space, if you want it.

<# black>But you have two further arguments to refine this.
<bullet>If you want to replace "0 π" with just "0", add a boolean argument:
\t<# blue>scalefudgex(graphID, 1/π, " π", 1);  <# magenta>// Now the scale will be: "0,   0.5 π,   1 π,   1.5 π,   2 π "
<bullet><# black>If you also want to replace "1 π" by just "π", add a second boolean argument:
\t<# blue>scalefudgex(graphID, 1/π, " π", 1, 1);  <# magenta>//Now the scale will be: "0,   0.5 π,   π,   1.5 π,   2 π "

<# black>The program doesn't let you use a scaler (like 1/π here) in the absence of a suffix; this, for example, will achieve nothing:
\t<# blue>scalefudgex(graphID, 1/π, "   ");
<# black>It's not that we don't trust you; it's just that it is too risky - you could make the adjustment to the wrong graph, for example, and have no way of knowing that the scale was actually false. If you <I>must</I> fudge the purely numerical results, you can use method (b) below.

<# black>You can't use formatting tags in 'scalefudgex'. However you can implant special characters (as we did with 'π' above) simply by copy-and-paste from a character source.

<B>(c)  Supply a characters array that overwrites the machine-generated values</B>
The functions <b>scaleoverx/y/z(.)</b> have exactly two arguments - the graph identifier (which cannot be omitted), and the characters array of strings to go at hairlines, using commas as separators. (Spaces are significant.)
<i>NB -- the function works differently for the 2D and 3D cases!</i>
<i>2D Case:</i>
Suppose that the naturally generated scale numbers were "1, 2, 3, 4, 5". You could alter this as follows:
\t<# blue>scaleoverx(graphID, "cat,dog,rat,hog,bat"); <# magenta>// The scale tags will be: "cat, dog, rat, hog, bat".
<# black>If too few new tags are supplied, naturally generated numbers make up the rest:
\t<# blue>scaleoverx(graphID, "cat,dog,rat "); <# magenta>// The scale tags will be: "cat, dog, rat, 4, 5".
<# black>If too many new tags are supplied, excess tags will be ignored:
\t<# blue>scaleoverx(graphID, "cat,dog,rat,hog,bat,sat,mat,hat"); <# magenta>// The scale tags will be: "cat, dog, rat, hog, bat".
<# black>Empty tags are permitted. For example you could blank all five scaling tags with:
\t<# blue>scaleoverx(graphID, ",,,,");
<# black>An easier shorthand for blanking ALL scaling tags is to supply as argument a single '#' (no blanks):
\t<# blue>scaleoverx(graphID, "#");
<# black><i>3D Case:</i>
The 3D graph does not have strings against hairlines; instead there is a summary of the scales printed to the right of the graph; for each axis there are 3 values, "From: ...", "To ..." and "Step ...". These are calculated internally, but you can overwrite the internal values with these functions. However the array argument must have <i>exactly three values</i> or it will be ignored.

<# black>You can't use formatting tags in 'scaleoverx', however as with 'scalefudgex' you can implant special characters simply by copy-and-paste from a character source.

<# black>Function <I>scalejumpx(.)</I> is ignored for the scaling extent which is overwritten by this function.

One other set of functions occasionally of use is <B>scaleformatx(GraphID, char. array)</B>, and the -y(.) and -z(.) equivalents (works for both 2D and 3D graphs). the array is any format string as recognized by .NET. These are not listed here, save to say that the default is "G4", which allows for 4 significant digits, and presents them either in decimal format or scientific format, whichever is shorter. (1234567 --> '1.235E+06';  123.4567 --> '123.5';  0.1234567 --> '0.1235';  0.00012345 --> '0.0001235'.)

A bit of exotica, rarely needed, is <B>scalefit(.)</B>, which mimicks the internal automatic generation of an axis scale, given two extreme values. Key F1 with the cursor at the name if wanting more details.
================================================================
//SCALEFIT//
<B>scalefit</B>(<# blue>2 to 4 values in any form<# black>) -- rarely useful, but here as a bit of exotica. Typically could be used to make tidy scale markings for an axis where curve endings are untidy numbers. For example, if you had a curve ranging from X = 0.2134 to X = 1.112, you would prefer the graph to have tidier scale markings like [0,  0.5,  1,  1.5], accepting the fact that there will be 'dead space' at both sides of the curve. You never need to use this function when drawing graphs, as the 2-argument version is called internally whenever you don't specify axis extents; for example, "plot(X,Y);" without a "grid(.)", for the above limits in X, would indeed automatically produce a graph with scalings [ 0.2, 0.4, 0.6, 0.8, 1, 1.2 ] (a tighter fit than our suggestion above).

There are two versions - 
<bullet>The version with only two values, which are XLow and XHigh. This is the one used internally for graphs, and always returns between 4 and 7 segments. It tends to give neater numbers, but at the cost of some looseness of fit.
<bullet>The version with 3 or 4 values, the 3rd. being the least number of segments you want (at least 2), and the 4th. being the most segments you will allow. (If no 4th. argument, then the 3rd. stipulates an exact number of segments.) You get a tight fit, but often less neat values.

Both versions return an array of three values: [0] is the new X low, [1] is the new X high, and [2] is the number of segments proposed for the graph. (You would go on to produce actual graph scale values by using "scalery = ladder(NoSegs+1, NewXLo, NewXHi);" ).

Argument errors return a zeroed array; so if testing for this, test [2], which is always nonzero if there is no error.
================================================================
//SEED:  see RANDOM
================================================================
//SEEKNO//
<b>FIND A NUMBER IMBEDDED IN A CHARACTER STRING</b>

You have a string which may contain a numerical value, e.g. "My age is 32.". You want to get at that value. The function is:

	<# blue><b>seekno</b>(array <b>TheString</b> [, scalar <b>StartPtr</b> [, scalar <b>EndPtr</b> [, bool <b>IntegerOnly</b> [, bool <b>AllowNegSign</b> ] ] ])<# black>
<bullet><i>TheString</i>:  Taken as a string of unicode chars.
<bullet><i>StartPtr:</i>  Defaults to 0 if absent, or if negative.
<bullet><i>EndPtr:</i>  Defaults to end of TheString if absent or too large or negative (so '-1' is fine where you don't know the size of the string).
<bullet 50,➯>All characters before StartPtr or EndPtr are ignored; e.g. the minus sign of the string "-12" if StartPtr is 1.
<bullet><i>IntegerOnly:</i>  Defaults to FALSE if absent. If TRUE, will only look for numeric characters 0 to 9; if FALSE, will look for a sequence of characters which appears to represent any valid number (e.g. "1.23" or "2.3e-21"). (There is no test for whether or not any integer found is within e.g. the Int32 range.)
<bullet><i>AllowNegSign</i>:  Defaults to FALSE. If TRUE, "-12" would return -12; if FALSE, it would instead return 12.

<u>RETURNED</u>
An array of size 3. Its values are as follows:
<bullet>A value was found:
<bullet 50,➯>[0] points to its first character in TheString;  [1] points to its last character;  [2]  is the parsed value of this substring.
<bullet>A potential value was found, but it was outside the range of .NET/Mono  type double (like "1e999"):
<bullet 50,➯>[0] and  [1] again point to its first and last character;  but [2]  is NaN. (This value would never be validly returned from TheString, as characters out of the Unicode range are substituted out before the search.)
<bullet>No value found:
<bullet 50,➯>[0] and  [1] are both -1;  [2]  is NaN.

================================================================
//SELECT//
//SELECTROWS//
//SELECTCOLS//
//POKE//
//POKEROWS//
//POKECOLS//
//EVICT//
<B>SAMPLING AND REPLACING MULTIPLE ARRAY VALUES AT ONCE</B>

Use <B>select(.)</B> and <B>poke(.)</B> to sample / replace at a list of individual locations, and <B>selectrows(.) / selectcols(.)</B> and <B>pokerows(.) / pokecols(.)</B> to sample / replace a list of whole rows or columns.

<B>1.  SAMPLE / REPLACE AT A LIST OF INDIVIDUAL LOCATIONS</B>
Suppose that you have some large data array (list type or structured type), but that you are interested in only a few particular values within that array. You can read those values into a list array using <B>select(.)</B>, and you can feed new values from such a list array back into the original array using <B>poke(.)</B>.

<u>FUNCTION <b>select</b></u>
There are two forms which do quite different jobs. They are distinguished by the form and number of their arguments. The first argument, <i>SourceArray</i>,  is always the array from which you want to extract values; the last argument, <i>IndexesArray</i>, is always the array which tells you which values to extract. Both forms return a list array made up of the extracted values.
<bullet><B>select</B>(<# blue>SourceArray, IndexesArray<# black>) -- In this form, IndexesArray is simply a list of indexes within SourceArray. The structure of SourceArray is important; sets of values in IndexesArray must constitute valid indices for its locations. For example, if SourceArray is an MxN matrix, with rows m (0 <= m < M) and columns n (0 <= n < N), then the format would be: <# blue>arr = select(SourceArray, data(m1, n1, m2, n2, ...) );<# black> this would return a list array: [SourceArray[m1,n1],  SourceArray[m2,n2], ...). All indexes <i>must be valid</i> for SourceArray, or else the function crashes.
<bullet 30,>The structure of IndexesArray is ignored; it would usually be a list array, but for the above example could also be a matrix with two columns, column 0 for M values and column 1 for N values, as the internal data strip would then have the same values in the same order as would the corresponding list array version of IndexesArray.
<bullet><B>select</B>(<# blue>SourceArray,  scalar LowKey [, scalar HighKey],  IndexesArray<# black>) -- IndexesArray this time must have exactly the same total length as SourceArray (the actual structure of the two arrays is irrelevant). Suppose you have only supplied one scalar, 'LowKey'. Then for every index n in IndexesArray such that IndexesArray[n] = LowKey, SourceArray[n] is added to the collection of values to be returned. If you have supplied both scalars, then for every index n such that   LowKey ≤ IndexesArray[n] ≤ HighKey,  SourceArray[n] is added to the collection to be returned. If no values in IndexesArray fall within the range, the empty array [NaN] is returned.

Here is an example of how you might use the second form, with two scalar arguments. You have written a polynomial solver, and for some fifth degree polynomial it has given you the following solutions (idealized by removing mantissae, so as not to fill this window with decimal fractions):
		1 + j.2,     1 ‒ j.2,     0 + j.0,     7 + j. 1e-15,     7 ‒ j. 1e-15
(It is usual for polynomial solvers to return what should be paired real roots as instead paired complex roots with extremely small imaginary parts.)
You want to discard complex solutions and retain the real ones. We decide that no numerical rounding errors of the underlying C# will be as large as Err, which we set to 1e-10. Then the selection process goes like this:
	<# blue>real_part  =  data(1, 1, 0, 7, 7);
	imag_part = data(2, -2, 0, 1e-15, -1e-15);
	Err = 1e-10; <# magenta>// Higher than maximum expected numerical error, lower than any expected valid imag. part	<# blue>
	real_solutions = select(real_part, -Err, Err, imag_part);
	writeln(real_solutions);  <# magenta>// This will display:  0, 7, 7.<# black>

Another example: You want to retrieve all values from some array which lie between two given values:
	<# blue>Arr = rand(20, 0);  <# magenta>// Create an array of random numbers between 0 and 1.<# blue>
	Brr = select(Arr, 0.4, 0.6, Arr);  <# magenta>// Select values in Arr between 0.4 and 0.6 inclusive. Note the double use of 'Arr'.<# blue>
	writeln(Brr);  <# magenta>// On average, this will return you 4 values between 0.4 and 0.6 (occasionally many more, occasionally none).<# black>
(This particular task would be better done in a single step using function 'clipcull'.)

Yet another. You want to find all the integers between 10,000 and 11,000 which are perfect squares. (Not the most efficient way to do this!)
	<# blue>Arr = fill(1001, 10000, 1); <# magenta>// Array [10,000,   10,001,   10,002,  ...  11,000 ]<# blue>
	max_error = 1e-10;
	Brr = select(Arr,  -max_error,  max_error,   frac(sqrt(Arr))   );
	writeln(Brr);  <# magenta>// Displayed array is   [10000, 10201, 10404, 10609, 10816].<# blue>
  	writeln(sqrt(Brr));  <# magenta>// Displayed array is   [100, 101, 102, 103, 104].<# black>


<B>evict</B>(<# blue>SourceArray, IndexesArray<# black>) -- the converse of <B>select(.)</B>; it instead returns a list array consisting of <I>all but</I> the entries indicated in SourceArray. All the above applies regarding the arguments.

It is possible for IndexesArray to refer to every entry in SourceArray; in this case, the function returns an array of size 1, content NaN; a call to function 'empty(.)' would then return TRUE.

<B>poke</B>(<# blue>structured array Subject, array of Indices, array of Values OR scalar SingleValue<# black>) -- A VOID function. Use this if you have an array 'Subject', and you want to change values at some particular locations. The locations are defined in the array Indices; the values you want to insert are listed in the array Values. If Subject is an MxN matrix, then Indices will consist of ordered pairs [m1, n1, m2, n2, ...], the outer dimension preceding the inner dimension. Likewise if it is an MxNxP structure, Indices must take the form [m1, n1, p1, m2, n2, p2, ...]. 

If the last argument is scalar, then SingleValue will go into every indicated location. If an array, then its size is important: for each such set of coordinates there must be one corresponding value in the array Values, which will be inserted into Subject at the given location.

While the structure of Subject is important, that of Indices and Values is ignored. If, for example, Subject were a matrix, and Indices were a matrix with rows of length 2, each row corresponding to one coordinate of matrix Subject, then the function would work just fine..

Here is an example of how to use the two functions together:
\t<# blue>mx = data(1,2,3,   4,5,6);  redim(mx, 2, 3); <# magenta>// 'mx' is now a 2x3 matrix.
\t<# blue>indices = data(0,1,   1,2); <# magenta>// references to mx[0,1] and mx[1,2].
\t<# blue>values = select(mx,  indices); <# magenta>// 'values' becomes [2, 6].
\t<# blue>values += 0.01; <# magenta>// 'values' becomes [2.01, 6.01].
\t<# blue>poke(mx, indices, values); <# magenta>// mx is now: [1, 2.01, 3;  4, 5, 6.01]   


<# black><B>2.  SAMPLE / REPLACE A LIST OF WHOLE ROWS OR COLUMNS</B>

<B>selectrows</B>(<# blue>matrix Source, list array RowNos<# black>) -- returns a matrix whose rows are the selected rows from matrix Source. The second argument holds the required row numbers; its structure is ignored.

<B>pokerows</B>(<# blue>matrix Destination, list array RowNos, matrix Source<# black>) -- A VOID function. Destination is a preexisting matrix, which is to have some of its rows overwritten. Source is an array of the replacement rows (i.e. a matrix), and RowNos tells where, in Destination, each row is to go: the nth. row of the Source matrix becomes the (RowNos[n])th. row of matrix Destination. Obviously the size of RowNos and the number of rows in Source must be the same.


<B>selectcols</B>(<# blue>matrix Source, list array ColumnNos<# black>) -- returns a matrix whose columns are the selected columns of matrix Source. The second argument holds the required column numbers; its structure is ignored.

<B>pokecols</B>(<# blue>matrix Destination, list array ColumnNos, matrix Source<# black>) -- A VOID function. Destination is a preexisting matrix, which is to have some of its columns overwritten. Source is an array of the replacement columns (i.e. a matrix), and ColumnNos tells where, in Destination, each column is to go: the nth. <I>row</I> (not column) of the Source matrix becomes the (ColumnNo[n])th. <I>column</I> of matrix Destination. Obviously the size of ColumnNos and the number of <I>rows</I> in Source must be the same.
================================================================
//SETALIAS -- see ALIAS
================================================================
//SETBOX//
<just c><b>CHANGING SIZE AND PLACEMENT OF DIALOG BOXES</b>
<just l>
Dialog boxes invoked by functions <b>show, decide, request</b> are of a set size, which is usually fine. But sometimes you want to change their size, or where they appear on the screen. The function for this is:

	<b>setbox</b>(<# blue>Width, Height [, CentreX, CentreY]<# black>) -- either exactly two or exactly four values, in any mix of arrays or scalars. 

Any dimension D in the range 0 \< D ≤ 1 will be regarded as a fraction of the screen width or height (as appropriate). Dimensions \> 1 are taken as pixel dimensions. Silly values are corrected internally or ignored.

CentreX and CentreY refer to where the centre point of the dialog box is to be.

The value to invoke the default dimension is -1. The one proviso is that you cannot separately set one of Width and Height to default; setting either to -1 has the same effect as setting both to -1. (This is not the case with the other two arguments.)

The box setting lasts only till you call the next dialog box. If you want a setting to last longer you will have to repeatedly call 'setbox' before each dialog box call.

The function has no effect on the size of file dialog boxes.
================================================================
//SETFUNC  -- see FUNC
//SETGRAPHPARAMS  -- see ANIMATE
//SETSEGMT -- see GETSEGMT
//SETVAL -- see ALIAS
//SEQUENCE -- see UNPACK
//SHOW:  see WRITE
===============================================================
//SHOWARRAY//
<just c><b>FUNCTION TO DISPLAY THE CONTENT OF AN ARRAY</b>
<just l>
During and after a run, you can display the content of an array (if it is still in scope) by clicking the F1 key while the cursor is at the name of the array in the Assignments Window. You can get exactly the same display window programmatically, via the function

	<# blue>showarray(Arr);<# black>

You can also use this with unnamed arrays; e.g. "showarray(Arr+1)" would work fine. (I can't imagine why you would want to do this, though.)
================================================================
//SHOWHAIRLINES//
<U>SHOWING / HIDING THE HAIRLINES</u>
You can choose to have full hairlines (the default), or hairlines reduced to just stubs on the axis, or no hairlines or stubs. The function is <b>showhairlines</b>(<# blue>GraphID, scalar HowX [, HowY [, HowZ ] ] <# black>). If e.g. HowX is zero, the graph's X axis will have no hairlines or scale markers; if 1, no hairlines but small scale markers will occur where hairlines would go; if 2 (the default) - or any other value - full hairlines are present. Note that scaling strings at hairline locations are not affected by this function.
================================================================
//SHUFFLE//
//SHUFFLEMX//
<B>shuffle</B>(<# blue>Array [, ReturnOriginalIndices]<# black>) -- Two versions, one VOID and one NONVOID. In both cases, Array is directly altered by the function, by being shuffled. 

If there is only one argument (or if the second argument is exactly 0), the function is VOID.

If there is a second nonzero argument, the function returns an array consisting of the <I>original indices</I> of the elements of Array. If the ith. element of the original Array becomes the jth. element after sorting, then the returned array will have element [j] = i. As an example, if Array was originally [0, 10, 20], and after sorting became [20, 0, 10], the returned array would be [2, 0, 1].

<I>Special case:</I> If Array contains only zeroes (as it does when created by "dim(..)" ), then what is returned instead is a shuffled version of the array [0, 1, 2, ... Length-1]. (This is only useful for the void case; in the nonvoid case it would simply return a copy of the shuffled Array.)


<B>shufflemx</B>(<# blue>Matrix, array RowsOrCols [, array ImposedOrder] <# black>) -- A NON-void function. It returns a matrix of exactly the same size as 'Matrix'. If there is no third argument, the matrix will be a copy of 'Matrix' but with its rows or columns randomly shuffled. (If RowsOrCols is 'R' or 'r', rows; if 'C' or 'c', columns.) If a third argument is present, it must be exactly as long as the number of rows / columns; this will be the order of rows / columns in the reordered copy of 'Matrix'. Duplications and omissions are allowed in 'ImposedOrder', as long as the total length is as described.
================================================================
//SIFT//
//SWITCH//
<just c><b>THE "SIFT"  STATEMENT</b>
<just l>
A <b>sift</b> block allows one to choose one of several competing code blocks on the basis of the evaluation of some expression. (While it resembles the 'switch' block of C-like languages, there are important differences.)

Here is a simple example. Suppose that X is a scalar variable:
	<# blue>sift (X)  <# magenta>// Note the brackets around 'X'.<# blue>
	{
		1:	{ writeln("X = 1");  y = 100; }   <# magenta>// Note the colon, and note the  braces '{..}' after it.<# blue>
		2:  writeln("X = 2");  <# magenta>// You can only omit the braces if there is just one simple assignment or operation after the colon.<# blue>
		else:  { writeln("X isn't 1 or 2"); }  <# magenta>// Note the colon after 'else'.<# blue>
	}

<# black>A 'sift' block can always be replaced by a chain of 'if' statements; for example, the above gives the same output as:
	<# blue>if (X == 1)  {  writeln("X = 1");  y = 100; }
	else if (X == 2) writeln("X = 2");
	else writeln("X isn't 1 or 2");
<# black>

However the sift block is <b>much more powerful</b> than the above example.
<bullet>You can replace 'X' above by <i>any variable, scalar or array</i>; and by <i>any expression</i>: "sift(Array1 + Array2)".
<bullet>You can use any of the standard conditional test symbols: ">= 2: { ... }".
<bullet>You can include '&&' and '||': ">0 && < 1: { ... }";   "2 || 3 || 4: {..}".
<bullet>You can use expressions before the colon: "> sqrt(Y): { ... }".
<bullet>If 'X' is an array variable or expression, you can use index addressing. E.g. for a test on Arr[0]:  " [0]: { ... }".
<bullet 50,⇨>But you can only use it before any conditional test symbol; e.g. "[0] > 10: { ... }" is fine, but this will fail: "[0] > [1]: { ... }".
<bullet>You can nest 'sift' statements: " 1: { sift (Y) {... } }"  (though I can't begin to imagine why you would want to do that).


<b>Points of syntax to note</b>
<bullet>The keyword <b>sift</b> must be followed by brackets "(..)" containing a variable or an expression (which I still denote by 'X' below).
<bullet>Braces "{ ... }" must follow, containing the rest of the sift block.
<bullet>Note the colons, which <i>must</i> be present for every instance of X.
<bullet>Whatever goes before that colon is <i>anything</i> that could be legitimately written for '?' in the statement "if (X  ?)". For example, "\> 1", because it is possible to write "if (X \> 1) ..."; or "!= a^2" because it is permissible to write "if (X != a^2)...".
<bullet>If there is no conditional symbol before the colon, the symbol is assumed to be "==" (and is in fact inserted internally).
<bullet>The 'else:' line is optional.

<b>Points of operation to note</b>
<bullet>Important note for those familiar with C-type languages: Instances are completely separate from one another; focus does not 'fall through' from one to the next, as it does in the C 'switch' block.
<bullet 50,⇨>Therefore the keyword 'break' (used in C 'switch' blocks) should never be used to end an instance!
<bullet>The only situation in which you can dispense with the braces inside an instance is where the code block is a simple assignment. (This is the same rule as for the braces following an 'if' statement.) (This is another way in which this statement differs from the C-type 'switch' statement, where braces are unnecessary and usually omitted.)
<bullet>The block still works if the colon is left off the end of the  final 'else:'. This is accidental to the design of the code; should I revise the code in the future, I would ensure that the version with the colon was unaffected, but would not struggle to preserve this ambiguity. Therefore - don't omit the colon!

================================================================
//SIGMOID//
<b>SIGMOID FUNCTIONS</b>

<B>sigmoid</B>(<# blue>array XX, scalar A, scalar B,  char array Mode <# black>) -- returns a list array giving the appropriate sigmoid function value for each element of XX. The structure of XX is ignored.


Three 'sigmoid' functions are computed. They are distinguished by the first character of the 'Mode' argument (further characters ignored).

<u>Mode "r" (for "rising")</u>

				1
	y  =     ----------------
			1  +  B.e<^>‒Ax</^>

This is a sigmoid curve which has amplitude 0 for x = -infinity,  1/(1+B) for x = 0, and 1 for x = +infinity; i.e. it "rises" from left to right.

<u>Mode "f" (for "falling")</u>
The same curve as above, but subtracted from 1. Hence it is 1 for x = -infinity, B/(1+B) for x = 0, 0 for x = +infinity.

<u>Mode "c" (for "compressed")</u>

				1
	y  =     ----------------
			1  +  (x / C)<^>A</^>

This would be obtained from the first equation as follows. Use 'ξ' for 'x' in the original equation, and 'ψ' for 'y'. Define x = e<^>‒ξ</^>; that is, ξ = ‒ln(x). This produces  ψ = 1 / (1 + Bx<^>A</^>). If you substitute   C<^>A</^> = 1/B you get the 'compressed' mode equation.

The effect is of a sigmoid curve compressed from the left, such that  y(0) = ψ(-infinity);  y(C) = ψ(0);  y(+infinity) = ψ(+infinity).

The point of using  (C<^>A</^> = 1/B) is that C is then always that value of x for which the curve has fallen to half of its original height.

Here is some code which will illustrate the effects of the compressed sigmoid function. All curves use the value 2 for 'C' in the above equation; the curves are drawn for different values of 'A'.

<# red>__ DEMO OF FUNCTION SIGMOID IN 'COMPRESSED' MODE
<# magenta>// The equation for this mode is:
//		Y = 1 /  (1 + (X / Xhalf)^A).
// In this mode, curves produced with positive X-axis values will have Y values starting at 1 (for X = 0)
//   and falling to a Y value of half at some chosen X, which we call 'Xhalf'. I use 2 for this here; that is,
//   I set the third argument of the system function to 2.
// The graph then shows curves corresponding to different values of the index A in the formula above
//   which is the second argument of the function).
<# blue>IndexValues = data(1, 2, 3, 4, 5, 10, 50);
noIndices = size(IndexValues);
Xhalf = 2;
xx = ladder(101, 0, 5); <# magenta>// We'll graph the function from X = 0 to X = 5.<# blue>
dim(plotto, noIndices);
description = " "; <# magenta>// will build into some explanatory text under the graph<# blue>
for (i, noIndices)
{	yy = sigmoid(xx, IndexValues[i], Xhalf, "compressed");	
	plotto[i] = plot(yy, xx,  ' ',0,0,  '_', 1, palette(i) );
	description = text(description, "  \<# ", palette(i), "\>", IndexValues[i]);
}
g = graph(plotto);
header(g, "COMPRESSED SIGMOID FUNCTION CURVES");
footer(g, "\tCurve colours correspond to the following indexes:  ", description);

================================================================
//SIGN//
Problem: You have an array Arr, and wish to have a matching array of tags, the tags indicating whether entries in Arr are postive, zero or negative. The function to use is...

<b>sign</b>(<# blue>scalar / array Values [, scalar ReturnForZero [, scalar ReturnForPositive [, scalar ReturnForNegative [, scalar VirtualZero ] ] ] ]<# black>):
The function's return will be of the same type and structure as Values.
Suppose we call the function's return "Result".
If there are no more arguments, then Result[i] will hold +1 if Values[i] is positive, 0 if Values[i] is exactly zero, and -1 if Values[i] is negative.
The next three arguments will alter these defaults of +1, 0 and -1 to any other values you wish.
<i>VirtualZero</i>:  If Arr has been derived by division (and some other operations), then it is quite possible that where there should logically be a zero there is a very tiny positive or negative value. To negate this, set VirtualZero to some value well below any you anticipate in your array (like 1e-10). Then any Values[i] which has an absolute value ≤ VirtualZero will be treated as zero.

<u>Examples</u>
	<# blue>aa = data(-2, -0.1, 0, 0.1, 2);
	bb0 = sign(aa);  writeln(bb0);  <# magenta>//  --> [ -1, -1, 0, 1, 1 ]<# blue>
	bb1 = sign(aa, 99);  writeln(bb1);  <# magenta>//  --> [ -1, -1, 99, 1, 1 ]<# blue>
	bb2 = sign(aa, 100, 101, 99);  writeln(bb2);  <# magenta>//  --> [ 99, 99, 100, 101, 101 ]<# blue>
	<# magenta>//  Illustrating VirtualZero:<# blue>
	bb3 = sign(aa, 0, 1, -1, 0.099);  writeln(bb3);  <# magenta>//  --> [ -1, -1, 0, 1, 1 ]<# blue>
	bb4 = sign(aa, 0, 1, -1, 0.1);  writeln(bb4);  <# magenta>//  --> [ -1, 0, 0, 0, 1 ]<# blue>
	bb5 = sign(aa, 0, 1, -1, 0.101);  writeln(bb5);  <# magenta>//  --> [ -1, 0, 0, 0, 1 ]<# black>

================================================================
//SIN -- see TRIGONOMETRY
================================================================
//SIZE//
<B>size</B>(<# blue>Variable [, Scalar]<# black>) -- Intended for arrays. If one argument, returns the total array size, irrespective of dimensions. If two arguments, returns a particular dimension; e.g. for a 2x4 matrix, <B>size(arr,0)</B> returns 4, <B>size(arr,1)</B> returns 2, <B>size(arr,2)</B> returns 0. For an impossible number of dimensions, -1 is returned. 
For scalar first arguments any second argument is ignored, and 0 is returned. (The total size of an array is never 0, so <B>size(xx)</B> can be used to distinguish a scalar from an array.)
================================================================
//SMASH -- see KILL_ON_EXIT
================================================================
//SOLVE//
<B>SOLVE....</B>
There are three functions at present which solve something:
<B>solvepoly(..)</B> solves polynomials, yielding an array of (possibly) complex solutions.
<B>solvesim(..)</B> solves simultaneous equations (real only).
<B>solveexp(..)</B> solves a simple expression supplied as a string.

Details of each function are provided by entering the name into the Assignments window and then keying F1.
================================================================
//SOLVE_DE//
<just c><b>SOLVING A FIRST-ORDER DIFFERENTIAL EQUATION</b>
<just l>
Suppose you have an equation expressed algegraically in the form
	<# blue>y'  =  ƒ(x, y)<# black>

To use MonoMaths to solve this, first you would write a user function of arbitrary name - say, "Foo(x, y)" - which has these arguments in this order, and which evaluates the RHS of the above equation as a scalar, for given scalars x and y. (Only scalar values will be given to it here, even if it can handle array arguments; and if there are further <i>optional</i> arguments, they will be ignored).

Next you decide on a range of x values for integration, and a number of points (N), and so create an array of all X values:
	<# blue>XX = ladder(N, Xlow, Xhigh);<# black>

Then you fix the constant of integration, which must be the value of y(0) for the value x = Xlow. Call it "Y0" for now.

Finally you decide on a method, which currently can only be one of two: the Euler method or the Runge-Kutta method.

Then the function goes like this:

	<# blue>YY = solve_de("Foo", Y0, XX [, Method] )<# black>

"Method": not case-sensitive, and only the first 3 letters are examined. If not supplied, the Euler method is used. If supplied, it must be <i>exactly</i> one of these values: "eul(...)", or "run(...)" (for Runge-Kutta 4th. order method).

Small print: the named function ("Foo" in this case) must not be in a recursive call when solve_de is invoked; if it is, the function will crash.

<u>EXAMPLE</u>
Consider the function
	<# blue>y' = y<^>2</^><# black>
If y = -1 when x = 0, the solution for the D.E. is
	<# blue>y = -1 / (1 + XX)<# black>
Try the following with different values of N, and with both methods. (Runge-Kutta works brilliantly for just 21 points, while Euler is a bit inaccurate for so few points.)

	<# blue>N = 21; <# magenta>// No. of points
	<# blue>xx = ladder(N,  0, 2);
	y0 = -1;
	yy_solved = solve_de("RHS", y0, xx, "Eul");
	yy_exact = YY(xx); <# magenta>// The exact solution of the differential equation, for y0 = -1
	// Graph the function output (red) on top of the exact solution(black):
	<# blue>pSolved = plot(yy_exact, xx,  '.',7, 'black', '_', 3, 'black');
	pExact = plot(yy_solved, xx,  '.',3, 'red', '_', 1, 'red');
	G = graph(pSolved, pExact);

	<# red>__ THE FUNCTIONS	
	<# magenta>// The RHS of the differential equation:
	<# blue>function RHS (x, y)
	{	return y ^2;
	}
	<# magenta>// The exact solution, given that y0 = -1:<# blue>
	function YY(XX)
	{	return (-1 / (XX + 1));
	}











================================================================
//SOLVEEXP//
<b>SOLVING A STRING EXPRESSION</b>

The function is <b>solveexp(.)</b>, which comes in two flavours:

<u>(1) The single argument version</u>
You have a string expression like: "a + b*(c - d)", and wish to evaluate it. The values (represented by 'a'..'d') may be any of:
<bullet>literal values (as in "1.2 + 3.4");
<bullet>constants (as in "PI^2");
<bullet>main program scalar variables that have already been assigned values (as in "PI^aa + 2").
The format then is -
	<# blue>expresso = "3*(PI^2 + z)"; <# magenta>// You have previously defined z as a scalar, and have given it a value.
	<# blue>x = solveexp(expresso);<# black>

<u>(2)  The two argument version</u>
This time you have all your values stored in a second argument, Values; and you reference them in the expression by their index in Values, surrounded by braces:
	<# blue>Values = data(1, 2, 3, 4);
	<# blue>x = solveexp("{1} + {3}",  Values );<# black>
Here, {n} refers to Values[n]; so the function will evaluate Values[1] + Values[3], that is, 2 + 4, and so will return 6.

<u>Rules for the expression</u>
Whichever form you use, it should contain only the following (correctly placed relative to each other):
<bullet>Values, in the forms given above;
<bullet>Operation signs, which may only be from the following list: '+', '-', '*', '/' and '^';
<bullet>Brackets '(' and ')', which may be nested to any depth.
<bullet>Spaces, tabs and paragraph marks, all of which the function will remove before any parsing begins.

The hierarchy of signs is the reverse order of the above list; '^' is done first, '+' last. Use brackets to avoid ambiguities,
as the computing language you are used to may have slightly different hierarchies (e.g. treating '*' and '/' on the same level).

Errors sadly crash, so check out your expression before submitting it; or else use the error-handling functions to protect from crashing (enter 'error' into the Assignments Window and key F1).
================================================================
//SOLVEPOLY -- see POLYNOMIAL
================================================================
//SOLVESIM//
<B>SIMULTANEOUS EQUATIONS</B>

<B>Arr = solvesim(Mx, RHS)</B> -- Mx is a square matrix, the LHS (lefthand sides) of the equations, and RHS is a list array or vector, holding the RHS of the equations. There must be at least 2 equations, or an error is raised.
<B>Returned array: </B> If size > 1, always holds the required solutions. If size is 1, solution failed; in that case Arr[0] holds an error indicator - 1 = homogeneous equations (all RHSs zero); 2 = indeterminate equations (e.g. one is a multiple of another).
================================================================
//SORT//
//SORTBYKEY//
<B>SORTING</B>

<B>sort</B>(<# blue>Array[, scalar SortType [, scalar StartPointer[, scalar EndPointer]]]<# black>) -- a VOID function that sorts the array (retaining its original structure). If SortType is omitted or is positive (or zero), ascending sorting occurs; if it is negative, descending sorting. StartPointer and EndPointer give the range within the array to be sorted. Out-of-range pointers are corrected; but crossed pointers raise an error. 

Allows array of size 1 (does nothing to it, though pointers still checked).


<B>sortbykey</B>(<# blue> array Data1 [, array Data2 [, ... ] ], array (Key)[, scalar SortType [, scalar StartPointer[, scalar EndPointer]]]<# black>) -- a VOID function that sorts one or more data arrays according to the key array 'Key'. All arrays must have the same total length, irrespective of pointer values. Structure and chars. rating is ignored for all of the array arguments.

The scalar arguments have exactly the same significance as in 'sort(..)', applying to the sorting of the key array.

<B>Warning!</B> The key array is also sorted; so if you want to preserve the original key, make a copy of it first.

Allows arrays of size 1 (but does nothing to them).
================================================================
//SOUND -- see PLAYSOUND
================================================================
//SPAN  --  see COPY
//SPLIT  --  see JAGGED
================================================================
//SQR//
//SQRT//
//SQUARE//
<B>sqr(Variable)</B> -- If 'Variable' is scalar, returns its square. If an array, returns an array in which every element is the square of the corresponding input element.

<B>sqrt(Variable)</B> -- If 'Variable' is scalar, returns its square root. If an array, returns an array in which every element is the square root of the corresponding input element. An error is raised if the argument is negative.
================================================================
//STACK//
<B>SETTING UP A STACK</B>

There are two ways of doing this using intrinsic functions:

(1) Use a list as a stack. For details, enter <B>list</B> into the Assignments Window and then key F1.

(2) Use an array as a stack. For details, enter <B>push</B> into the Assignments Window and then key F1.
================================================================
//STARTTIMER -- see TIMER
//STATISTICS -- see MOMENTS
============================================================
//STR//
//STRINGTOVALUE//
//ASC//
//UNICODE//
//VAL//
//VALUETOSTRING//
<U>CONVERTING BETWEEN UNICODE AND NUMERICAL VALUES</u>

<B>unicode</B>(<# blue>Any no. and mix of scalars or arrays<# black>) -- returns a chars. array using the supplied values as unicode values. These values are rounded; also, any values below 0 or above char. hex. DFFF (decimal 57343) are converted to 32 (space). 

<B>asc</B>(<# blue>chars array Arr<# black>) -- returns the unicode value of the first character of String. Seeing that the value is simply Arr[0], Its only use is where the argument is a literal, as in this usage:  
\t<# blue>if (thisWord[0] >= asc("A") && thisWord[0] <= asc("Z") )  isCapitalLtr = true;<# black>

<b>stringtovalue</B>(<# blue>chars. Array [, .... ]<# black>) -- Given the string form of a scalar or array value, returns the scalar or array. Two forms:
<i>Encoded scalar expected:</i>  <b>stringtovalue</B>(<# blue>chars array Arr [, Scalar: failureValue]<# black>). If there is a parsing error, failureValue is returned instead. If there is no second argument, the returned value in the case of parsing failure is MAXREAL.
<i>Encoded array expected:</i>  <b>stringtovalue</B>(<# blue>chars array Arr,  array Delimiter [, Scalar: failureValue]<# black>). (Note that the second argument must be an array, and the third, if present, scalar.) Returns the encoded array; or if there is any error parsing any value, an array of size 1, value failureValue, is returned. (As for the scalar case, the default failure value is MAXREAL.)
FORMAT: Input strings may have leading and trailing spaces, but there must be no internal spaces, and no non-numerical characters, and no wrongly deployed legal numerical characters (such as 'e' or '.' in the wrong place). All of these sins would return -1.  A leading '+' is allowed, though rather pointless.

<b>val</b>(...) -- exactly the same function as above. Useful if you need to use the function often.


<b>valuetostring</b>(<# blue>scalar or array Value [, array: FormatHow]<# black>) -- returns a character array, expressing the value as a string of characters. If Value is an array, the separator ", " occurs between separate value strings. If FormatHow is present, it must be such as is recognized by C#, as it is passed uncritically to C#. If the format is faulty, one of the following can happen: (a) it is ignored, and the default format occurs; (b) garbage is returned (usually the variable type name in C#); or occasionally (c) MonoMaths crashes without an error message. So don't get it wrong. Standard values are given in the next section, below.

You don't normally need to use this with 'write(.)', 'show()' or equivalent text display functions, as it is automatically applied to variables in their argument lists.

<b>str</b>(...) -- exactly the same function as above. Useful if you need to use the function often.


<b>Number formatting strings that can be used with function 'valuetostring'</b>
The string always takes the form of a letter (case-insensitive), either alone or followed by a 1 or 2 digit nonnegative integer.
The code letter is always case-insensitive; only the upper case form is listed here.
'β' after the code letter below always stands for the nonnegative integer.

'C'	The region's currency symbol precedes, 2 digits (cents) after decimal point.
'Cβ'	β specifies the number of digits after the decimal point.

'E'	Scientific form, with 6 digits forced after the dec. pt.
'Eβ'	Scientific form, with β digits forced after the dec. pt.

'F'	2 digits forced after the decimal point.
'Fβ'	β digits forced after the decimal point.

'G'	The shortest of 'E' or 'F', but with no conditions re no. digits after the dec. pt.
'Gβ'	The shortest of 'E' or 'F', but with β significant digits (rather than no. digits after dec. pt.)

'N', 'Nβ' – as for 'F', 'Fβ'. ('N' can be programmed in C# to have further properties.)

'P'	x 100, add '%'.  2 digits forced after the decimal point.
'Pβ'	x 100, add '%'.  β digits forced after the decimal point.

'R' – 'round trip' specifier (No 'Rβ' form.). A way of getting the most accurate string representation of a number with maximal digits. A double value will normally convert to a string in C# with no more than 15 digits precision. With this specifier, the string is tested with a back-conversion to the value; if this does not return the same value, then a new string is created with 17 digits of precision. (That value may be slightly different to the input value due to numerical handling errors, as in the example below.)
\t<# blue>a = 0.1234567890123456;  <# magenta>//16 decimal digits
\t<# blue>aa = str(a);		<# magenta>// returns 0.123456789012346 -- 15 decimal digits.
\t<# blue>bb = str(a, "R");	<# magenta>// returns 0.12345678901234559 -- 17 decimal digits

==================================================================
//STRINGTOVALUE -- see STR
//STRUCTURE -- see DIM
//SUBMATRIX -- see COFACTOR
============================================================
//SUBSTITUTE//
//PECK//
<B>REPLACING OR REMOVING SPECIFIC VALUES IN AN ARRAY</B>

<B>substitute</B>(<# blue>array Source, ...., scalar/array Replacer<# black>) -- returns a copy of Source which has certain values replaced by Replacer.
Four forms are possible:
<bullet>Form 1: <# blue>arr = substitute(array Source, scalar Value, scalar Replacer)<# black>. Every value in Source which exactly equals Value is replaced. (This is the one form in which Value may be NAN.)
<bullet>Form 2: <# blue>arr = substitute(array Source, scalar LoVal, scalar HiVal, scalar Replacer)<# black>. Every value in Source which is between <I>or at</I> the limits LoVal and HiVal is replaced. (The order of these two values is not important.) 
<bullet>Form 3: <# blue>arr = substitute(array Source, array Values, scalar Replacer)<# black>. Every value in Source which exactly equals any value in Values is replaced. 
<bullet>Form 4: <# blue>arr = substitute(array Source, array Value, array Replacer)<# black>. Every segment of Source which exactly equals Value is replaced.

The returned array will have the same characters rating as Source; it will also have the same structure, except for form 4, where arrays Value and Replacer have different lengths; in that case alone, the returned array is always a list array.

To remove instances without replacing them, see function <b>expunge</b>.

<B>peck</B>(<# blue> array Subject,  scalar Sought [, scalar Replacemt]<# black>) -- alters Subject itself (i.e. does not return an altered copy). Looks for the first (and only the first) instance of Sought. If found, the action depends on the number of arguments.
<bullet><I>2-arg. version:</I> if Subject is a list array, the instance is removed, thus shortening Subject by one. (If it is a structured array, the function crashes, as there is no sensible way to shorten it).
<bullet><I>3-arg. version:</I>  the instance is simply replaced by Replacemt, the structure of the array remaining unchanged.
The function returns 1 (TRUE) if a find has occurred (along with a replacement / removal), and 0 (FALSE) if not. (Note that it does not return -1 for a no-find, in this respect differing from function 'find(.)')
In the 2-arg. version, if the returned array would logically be empty (from pecking for 'n' in an array of length 1, with [0] = n), then its single value is changed to NaN, and a call to 'empty(.)' will return TRUE. (The function's returned value would still be 1, reflecting a genuine find.)
================================================================
//SUM//
<B>sum</B>(<# blue>Array [, scalar StartAt [, scalar EndAt ] ]<# black>) -- the sum of the contents of the array (irrespective of its structure); if no limits, the whole array is summed. If only the first limit, summing starts from there. The limit arguments are adjusted if out of range; crossed limits returns 0.
================================================================
//SUMROWS//
//SUMCOLS//
<B>sumrows</B>(<# blue>Mx [, FromRow [, Extent ]]<# black>) -- returns a list array whose length is the length of a row of Mx, and whose ith. value is the sum of all the elements in the ith. column of Mx. If 2nd. +/- 3rd. arguments are supplied and are wrong, the outcome is as if the matrix had rows of zeroes extending to infinity both before the first and after the last row; for example, FromRow = -1 with Extent = 1 would return an array of zeroes (the values of virtual 'row -1'). Similarly, Extent <= 0 returns an array of zeroes. The only error raised is if Mx is not a matrix. (See also 'prodrows' and 'prodcols'.)

<B>sumcols</B>(<# blue>Mx [, FromCol [, Extent ]]<# black>) -- the column equivalent of 'sumrows(.)'; it behaves in exactly the same way.
================================================================
//SWAP -- see ROTATE
================================================================
//SWING//
<B>swing</B>(<# blue>2, 4 or 6 args., either all scalar or all equal-length arrays<# black>) -- returns angle(s) of rotation. The following explanation is in terms of scalars; the same applies for the ith. values of all array arguments.

(a) swing(Xto, Yto) -- the angle which a ray hinged at the origin makes in swinging from the X axis (positive direction) to the 'to' point (Xto, Yto).

(b) swing(Xto, Yto, Xfrom, Yfrom) -- the angle which a ray hinged at the origin makes in swinging from the 'from' point (Xfrom, Yfrom) to the 'to' point.

(c) swing((Xto, Yto, Xfrom, Yfrom, Xpivot, Ypivot) -- the angle which a ray hinged at the 'pivot' point (Xpivot, Ypivot) makes in swinging from the 'from' point to the 'to' point.
================================================================
//READTABLE//
<B>TABLE  LOOKUP</B>

You have a table, which is in the form either of a matrix (row 0 being values to look up, row 1 being corresponding values to return) or of two simple arrays (the first has lookup values, the second has values to be returned). The function <b>readtable</b> allows you to present input values to this table and to return corresponding table outputs.

The function is:
	<B>readtable</B>(<# blue>matrix <b>Table</b>,  scalar / array <b>InputValues</b>,  array <b>LookupRule</b> [, scalar <b>StartPtr</b> ]<# black>)
OR - splitting the table up into two separate list arrays -
	<B>readtable</B>(<# blue>array <b>InRow</b>,  array <b>OutRow</b>,  scalar / array <b>InputValues</b>,  array <b>LookupRule</b> [, scalar <b>StartPtr</b> ]<# black>)

The function RETURNS a structure of the same type as InputValues.

ARGUMENTS:
<bullet><b>Table</b> -- This matrix must have exactly two rows, row 0 (call it "InRow") holding values to look up, row 1 (call it "OutRow") holding corresponding table output values. Rows must have at least length 2.
<bullet><b>InRow, OutRow</b> -- As in the second version of the function; the two arrays must have equal length, at least of length 2.
<bullet><b>InputValues</b> -- Need not be sorted, EXCEPT in the case of a negative StartPtr - see later.
<bullet><b>LookupRule</b> -- Three allowed values:
<bullet 50,➯>"=" - An input value must exactly match an InRow value, or else the error code MINREAL is returned for that  value.
<bullet 50,➯>"~" - The nearest InRow value to the input value is found, and the corresponding OutRow value is returned. If the input value is exactly halfway between, say, InRow[i] and InRow[i+1], then InRow[i] will be selected, and OutRow[i] will be returned.
<bullet 50,➯>"L" - Linear interpolation occurs. Suppose the input value is 1/3 of the way between InRow[i] and OutRow[i+1]; then the output value will be 1/3 of the way between OutRow[i] and OutRow[i+1].
<bullet 30,>If input values are outside of the range in InRow, extrapolation occurs on the same basis.
<bullet><b>StartPtr</b> -- If present, causes the function to ignore all elements of InRow earlier than InRow[StartPtr]. It is an error to set this to beyond the end of the table, or - in the case of LookupRule "L" - to beyond the last two elements of the table.
<bullet 30,><i>Special case:</i> Where the table is large and there are many input values, it saves a lot of time if (a) InputValues is sorted (duplicates allowed), and (b) you set StartPtr to any negative value. In this case, each successive search will start in InRow where the last search finished, rather than going back to InRow[0] each time. NB! If, in this situation, InputValues is not sorted, "garbage-in-garbage-out" will apply to your results.
<bullet 30,><font same, 10><# lightslategrey>Re the saving of time: The following experiment was done: InRow was set to the arithmetic series [1, 2, ..., 1000], and InputValues was set to the same. (OutRow was irrelevant - I just set it to InRow + 1000.) In the first run, no StartPtr was used; in the second, StartPtr was set to -1. For all three values of LookupRule, the first run took 40 times longer than the second run. When repeated with all 1000 values of InValue set to 1000, the first run took 80+ times longer than the second run.<# black></font> 

EXAMPLES:
	<# blue>InRow = data(10, 20, 30, 40);
	OutRow = data(100, 200, 300, 400);
	InValues = data(-10, 10, 13, 15, 20, 60);
	ans1 = readtable(InRow, OutRow, InValues, "="); <# magenta>// ans1 = [  MINREAL, 100, MINREAL,  MINREAL,  200,  MINREAL ];<# blue>
	ans2 = readtable(InRow, OutRow, InValues, "~"); <# magenta>// ans1 = [  100, 100, 100, 100, 200, 400 ] <# blue>
	ans3 = readtable(InRow, OutRow, InValues, "L");  <# magenta>// ans1 = [  -100, 100, 130, 150, 200, 600 ] <# blue>

See also functions 'placement' and 'interpolate'.
============================================================
//TAN -- see TRIGONOMETRY
//TEXT -- see WRITE
============================================================
//THISLINENO -- see FINDLINENO
============================================================
//TIMER//
//STARTTIMER//
<b>USING TIMERS</b>

There are (notionally) 20 timers, which count up in milliseconds from zero. You have to initialize a timer by using <B>starttimer(n)</B>; thereafter the time that has elapsed since that initialization can be retrieved by <B>timer(n)</B>. (Such a call does not reset the timer, which notionally continues ticking until reset by a further call to 'starttimer(n)').

You can pause a timer by supplying a second argument, which must be an array beginning with 'P' or 'p' (or an error is raised):  <b>timer(n, "pause")</b>. This and subsequent calls to "timer(n)" will return the time counted up to the pause. You can then resume counting by a call  <b>timer(n, "resume")</b> (or other second argument beginning with 'R' or 'r'); the current count is returned as usual.

You can also query a timer, to see if it is paused. (The call has no effect on the timer's operation.) In this case, the second argument must begin with '?'; we suggest you use "?paused" as the argument, as the return is TRUE if it is paused, or FALSE if not. (The actual time is not returned.)

If you fail to use <B>starttimer(n)</B> and just call <B>timer(n)</B>, you will get the number of milliseconds since 1 AD.

Function <b>starttimer(.)</b> can start more than one timer at once; it takes up to 20 timer identifiers as arguments (any mix of scalars and arrays). However all forms of <b>timer(.)</b> can only take a single timer indentifier.

There are <b>two special arguments</b> for timer: <b>timer(-1)</b> returns the time (msecs.) since the user program started; <b>timer(-2)</b> returns the time (msecs.) since this instance of MonoMaths started. (In both cases, any second argument supplied will be ignored.)

For all functions, an <b>error is raised</b> if the timer identifier is outside of the range 0 to 19.

Note that MonoMaths does not generate some internal timer object when you use <B>starttimer(n)</B>. All it does is record the absolute time at that moment. When you later use <B>timer(n)</B>, all that happens is that MonoMaths again reads the absolute time in milliseconds and subtracts from it the earlier absolute time. (Adjustments to the total time are made for the durations of any pauses.)

An example:

<# blue>starttimer(0);  <# magenta>// or just 'starttimer()'.
<# blue>for (i, 10000)
<# blue>{   x = sin(cos(sin(cos(1)))); } <# magenta>// just waste some time.
<# blue>
writeln("time elapsed: ", timer(0), " msecs.");
writeln("MonoMaths started up ", timer(-2) / 1000, " secs. ago");
writeln("duration of program so far: ", timer(-1), " msecs.");

<# black>(If you run this code inside a loop you will see how extremely variable is the time taken for this piece of code, due to the many processes running in your computer at the same time, and due to unpredictable garbage collecting within the underlying Mono system.)


If you want to retrieve the present computer date and time, use function <B>datetime()</B> instead.
============================================================
//TOUCH_ARRAY//
<b>		!!!!!!!!!!!  DANGER -- FOR HACKERS ONLY  !!!!!!!!!!!!!</b>

The following function allows you to directly alter an element of a main program array from a function (or elsewhere in the main program), if you know the literal name of that variable. It is NOT intended for regular use. Modifying main program variables in this way is highly dangerous, as there is no indication in the main program that something has been done to such variables. (I invented the function only for a special situation in which I needed to alter an event counter array - based in the main program - to register events occurring within functions, and to do so more quickly than could be done using system lists, as the application was time-critical.) Even in programs which do have global variables, it is clear in the main program what variables are global (and so open to change from anywhere) and what are local. There are no global variables in MonoMaths, so that no array is safe from tinkering by 'touch_array' used within a user function.

<b>touch_array</b>(<# blue> chars. array VariableName [include quote marks!],  scalar AbsolAddress,  scalar NewValue,  scalar/array Operation<# black>).

The name of the variable must be in quotes. A boolean is returned, TRUE if the operation was successful. There are no error messages to tell you why a failure occurred; it would be because (a) no main program array has that name; (b) one does, but it has not yet been assigned a value; (c) you got the array index wrong; (d) you left out quotes on the first argument; (e) the second and third arguments were not scalar; (f) the Operation argument was improper. (As mentioned, this one is for hacking purposes only, so don't expect comfortable error messages.)

'Operation' - If an array, only the first character is examined; if a scalar, must be the unicode version of same.
\t'#' -- simply replace the old value with NewValue.
\t'+', '-', '*', '/' -- the final value is:  Old Value <operation> NewValue

Example of use:
\t<# blue>xx = data(0, 1, 2, 3, 4, 5); <# magenta>// This definition must be in the main program.
\t<# blue>outcome = touch_array("xx", 2, 99, '#');  <# magenta>// Usually, of course, this call would occur in a function.<# black>
\t<# blue>writeln(xx);  <# magenta>//  the result will be: "0, 1, 99, 3, 4, 5"<# black>
<# black>
==================================================================
//TOZERO  --  see MOD
==================================================================
//TRAIN//
<just c><b><b>SEQUENCES OF SUBARRAYS -- "TRAINS"</b></b>
<just l>
A 'train' consists of a sequence of 0 or more subarrays of any nonzero length, together with a 'header' section at the start of the train which tells how many subarrays there are, and how long each subarray is. I call these subarrays 'carriages'.

The format of a train is as follows.
   <# blue>[no. carriages] [length of first carriage] [length of 2nd. carriage] ... [length of last carriage] [ --- ALL DATA (no delimiters) --- ]<# black>

For example, suppose our train, called 'Puff', has three carriages; carriage 0 is the subarray [1, 2, 3, 4]; carriage 1 is [10, 11];  carriage 2 is [20, 21, 22]. Then the formatted train would be:
	<# blue>Puff = data( 3,     4,  2,  3,       1, 2, 3, 4, 10, 11, 20, 21, 22 );<# black>

A train may have no carriages, in which case it is the NULL train, an array of length 1, value 0. BUT if a train has carriages, NO CARRIAGES MAY BE EMPTY.


There is just one function, <# blue><b>train(.)</b><# black>, which handles all processes involving trains. Different processes are distinguished by the first argument, which is <i>always</i> a chars. arrray, <# blue>Mode<# black>.

Some points about these functions:
<bullet>Except for the first three, all have the operand train as the second argument.
<bullet>The function is never void, and never changes the operand train.
<bullet>There are no optional arguments; for each mode the number of arguments is fixed.
<bullet>Where the function returns contents of an operand train or data array, the return will have the same chars. rating as that operand. 
<bullet>Where there is an operand train, it is always checked for correct formatting before any action; if it is not a correctly formatted train the function crashes.

<b>Creating / converting a train</b>
<# blue>Puff = train("new");  <# black>
The return will be the NULL train, data(0). Add carriages using DoWhat = "append", as explained below.

<# blue>Puff = train("from",  DelimitedArray,  scalar/array Delimiter);  <# black>
For example, if Delimiter is 99, and DelimitedArray is [1, 2, 3, 4, 99, 10, 11, 99, 20, 21, 22], then the train returned will be that mentioned at the top of this page.
Empty subarrays will be ignored. For example, if DelimitedArray were just [99, 99, 99] for the same delimiter, the returned train would be the NULL train.
If Delimiter is an array, only its first element will be used.

<# blue>Puff = train("from",  JaggedMatrix,  scalar/array Padder);  <# black>
The rows of the jagged matrix will have the padder trimmed off, and what is left of each row will become a carriage of the train. If some row consists entirely of padders, there will be no carriage created for it, as empty carriages are not allowed on trains. Hence a jagged matrix consisting of nothing but padders would return the NULL train.

<b>Convert the train to a delimited list</b>
<# blue>Arr = train("delimit",  Puff,  scalar/array Delimiter);  <# black>
If the train has just one carriage, there will be no delimiter in the output. If the train is NULL, the output will be just the delimiter (as an array of length 1).
If Delimiter is an array, only its first element will be used.

<b>Retrieving the header, retrieving carriages</b>
<# blue>Header = train("header", Puff);<# black>

<# blue>Arr = train("read",  Puff,  scalar WhichCarriage);  <# black>
Returns the content of the indicated carriage. If there is no such carriage, or the train is NULL, the 'empty' array [NaN] is returned.

<# blue>NewPuff = train("copy",  Puff,  scalar StartCarriage, scalar NoCarriagesToCopy);<# black>
Returns a new train containing the indicated carriages of "Puff".
StartCarriage must be correct, but NoCarriagesToCopy is allowed to be larger than possible. E.g. if you want to copy all to the end of the train but don't know how long is the train, set this to a ridiculously high value.
If Puff is the NULL train, or if the scalar arguments indicate a nonexistent part of Puff, the NULL train is returned. It is also returned if StartCarriage is negative.

<b>Manipulating the train</b>
<# blue>Puff1 = train("append", Puff,  scalar/array NewCarriage);<# black>
For example, if Puff were data(1, 3, 10, 11, 12) - representing a train with one carriage of length 3 - and NewCarriage were data(100, 101), Puff1 would be data(2, 3, 2, 10, 11, 12, 100, 101).
This is the only function which allows you to build onto a NULL train.

<# blue>Puff1 = train("insert", Puff,  scalar WhichCarriage,  scalar/array NewCarriage);<# black>
WhichCarriage must be an existing carriage. Hence (a) it crashes, if Puff is a null train; and (b) it cannot be used to append to the train.

<# blue>Puff1 = train("alter", Puff,  scalar WhichCarriage,  scalar/array NewCarriage);<# black>
The original carriage numbered 'WhichCarriage' will be replaced by the new carriage. As for 'insert', WhichCarriage must be an existing carriage. Hence it crashes if Puff is a null train.

<# blue>Puff1 = train("delete", Puff,  scalar StartCarriage,  scalar NoDoomedCarriages);<# black>
StartCarriage must be correct, but NoDoomedCarriages is allowed to be larger than possible. E.g. if you want to delete all to the end of the train but don't know how long is the train, set this to a ridiculously high value. Again, it crashes if Puff is a null train.

<b>Finding data</b>
There are three modes for searching.
<bullet>Mode "find" searches for carriages which <b>exactly</b> match a supplied array.
<bullet>Mode "holds" searches for carriages which <b>hold</b> the supplied array as a subset. (If the one carriage holds more than one copy of the supplied array, it is still only counted once as a 'find'.) 
<bullet>Mode "starts" searches for carriages which <b>start with</b> the supplied array (but may contain more subsequent data) .
All three modes take the same arguments, and all return an array. The returned array is either the list of indexes of found carriages or is the array [-1] if no finds.
<# blue>findings = train(Mode,  Puff,  scalar/array Sought,  scalar FirstCarriageToCheck,  scalar MaxNoFinds);<# black>
If you want all finds returned, set MaxNoFinds to some ridiculously high value (e.g. the length of the train, or MAXINT32).
Silly scalar arguments do not cause a crash; simply nothing gets found. (This includes FirstCarriageToCheck being negative.)
==================================================================
//TRANSPOSE  -- see MATRIX
==================================================================
//TRIGONOMETRY//
//SIN//
//COS//
//TAN//
//ARCSIN//
//ARCCOS//
//ARCTAN//
//DEG//
//RAD//
<B>BASIC TRIGONOMETRIC FUNCTIONS</B>

<B>sin</B>(<# blue>Variable<# black>) -- the sine of the variable (which is taken as being in radians). 
<B>cos</B>(<# blue>Variable<# black>) -- the cosine of the variable (which is taken as being in radians).
<B>tan</B>(<# blue>Variable<# black>) -- the tangent of the variable (which is taken as being in radians).

<B>arcsin</B>(<# blue>Variable [, bool ClipIfOverLimits ]<# black>) -- the inverse of <# blue>sin(..)<# black>. Returns angles in the range -PI/2 to PI/2. If the boolean is 'true', any values outside +/- 1 will be trimmed back to these limits. (Use where numerical errors could produce an argument very slightly over / under the limits.) 

<B>arccos</B>(<# blue> Variable [, bool ClipIfOverLimits ]<# black>) -- the inverse of <# blue>cos(..)<# black>. Returns angles in the range 0 to PI. If the boolean is 'true', any values outside +/- 1 will be trimmed back to these limits. (Use where numerical errors could produce an argument very slightly over / under the limits.)

<B>arctan</B>(<# blue>array / scalars Numerator [,  Denominator ]<# black>) -- the inverse of <# blue>tan(..)<# black>. The one-argument version returns the arctangent as a value in the range -PI/2 to PI/2. The two argument version returns the angle in the correct quadrant (the numerator being taken as a Y increment and the denominator as an X increment), in the range -PI to PI. In both cases, if Numerator or Denominator is 0, POSINF or NEGINF, the geometrically correct angle is returned; this is not an error state. (If the value of [Numerator / Denominator] is indeterminate - e.g. both are 0 - then NAN is returned.)
In the two-argument version, both arguments must be of the same type (scalar or array), and if arrays, of the same length.

<B>deg</B>(<# blue>Variable<# black>) -- converts the variable from radians to degrees. No cutoff values; for example, deg(4*PI) will return 720, deg(-4*PI) will return -720.

<# black><B>rad</B>(<# blue>Variable<# black>) -- converts the variable from degrees to radians. No cutoff values; for example, rad(720) will return 4*PI, rad(-720) will return -4*PI.


\t<# blue>x = deg(PI); <# magenta>// returns 180.   
\t<# blue>x = rad(180); <# magenta>// returns 3.14159....   
============================================================
//TRIM -- see CULL
//TRUNC -- see PAD
//UNCHARS -- see CHARS
//UNDIM -- see DIM
============================================================
//UNICODE -- see STR
<B>unicode</B>(<# blue>Any no. and mix of scalars or arrays<# black>) -- returns a chars. array using the supplied values as unicode values. These values are rounded; also, any values below 0 or above char. hex. DFFF (decimal 57343) are converted to 32 (space). 

The inverse function is 'asc(.)'.
============================================================
//UNJAG -- see JAGGED
//UNMERGE -- see MERGE
============================================================
//UNPACK//
//SEQUENCE//
Two functions enable you to <b>assign values to several variables at one time</b>. Where those variables are to be scalars, they need not have been defined before their occurrence in either of these two functions.


<B>unpack</B>(<# blue>array Donor; any number of variable names<# black>) -- Copies the values in 'Donor' to the variables in the list, be they arrays (structure ignored) or scalars. It returns a success indicator; if there were not enough variable spaces to take all the donor wanted to give, then the indicator is positive, being the amount of data left over. If there was not enough in the donor to satisfy the demand, the indicator is negative, being the shortfall. Zero = complete match. Where the donor had insufficient data, the variables that missed out retain their preexisting values. True, even if data peters out half way through filling an array; the rest of the array retains its preexisting values. 

The first argument may be any array of any structure, assigned or not. For the rest, if an unassigned variable name is in the list it will be defined on the spot as a new scalar, and assigned the value due to it from its position in the list. Apart from 'dim(.)', this is the <I>only</I> function in <I>MiniMaths</I> which allows you to use new variable names as arguments; they will be set up as scalars. This is the real strength and purpose of the function: you can define a wad of new scalars from an array in one go. Here is an example, where graph parameters are assigned, the graph in this case having the ID "thisgraph":

\t<# blue>unpack(readgrid(thisgraph), Xmin, Xmax, Xsegs, Ymin, Ymax, Ysegs); <# magenta>// all new variables, not previously mentioned.

<# black>One use for this function is where you have a large wad of the same arguments to pass to several of your functions; you can wrap them up into an array in the main program, using function 'data(.)', and then unpack them locally in each such function, for your code simply using copy-paste to lift the arguments out of the 'data' statement and into the 'unpack' statement.


<B>sequence</B>(<# blue>scalar StartValue; any number of variable names<# black>) -- This function is used to assign integer values to any number of scalar variables, whether mentioned earlier or not. If not, they are defined by this function, as with <b>unpack(.)</b>. The first scalar will receive the value StartValue (rounded), and increment it; each subsequent scalar receives the updated StartValue and again increments it. The return is 
the last incremented value, so that the returned value minus StartValue equals the number of named variables.

	<# blue>n = sequence(5, a, b, c);  <# magenta>// This defines 3 new scalars, giving them values a=5, b=6, c=7. The return is 8.<# black>
============================================================
//UPSAMPLE  --  see  SAMPLING
//UNBIN -- see HEX
//UNHEX -- see HEX
//removeplot  -- see KILLGRAPHS
//VALUETOSTRING -- see STR
//VARIANCE -- see MOMENTS
==================================================================
//VECDIRNS//
<B>vecdirns</B>(<# blue>array PointsGrid, matrix Angles, scalar OR matrix ArrowLength<# black>) -- Used in the displaying of vector directions in a field. Recall that one of the options of 'plot(.)' is line type, and one of the options of line type is 'A', which causes only alternate pairs of points along a curve to be joined, giving a dashed effect; it also suppresses the first point, so that the second point becomes something like an arrow head (though the 'arrow' actually looks more like a sperm). You can provide the data for such a graph using this function. 

<I>The arguments:</I> 
<# blue>PointsGrid<# black> is an array of at least size 6, detailing which points in the field are to be sampled: [X min. value, X max. value, no. X intervals, Y min. value, Y max. value, no. Y intervals]. (Any further content is ignored.) For example if you want to show vector directions at X = 0, 0.1, 0.2, ... 0.9, 1, the first three arguments of PointsGrid would be: 0, 1, 10. 
<# blue>Angles<# black> is a matrix containing the angle (in radians) at every point in the grid; so its dimensions must be [No. Y segments + 1] x [No. X segments + 1].  <# blue>ArrowLength<# black> is what it says; all the arrows on the graph will have this length. It may be scalar - all arrows have the same length - or a matrix of exactly the same dimensions as Angles, holding the length of the vector at every point.

<I>The returned matrix</I> has dimensions [2 * total size of Angles] x 2. Note the two columns; column [0] holds all the x coordinates and column [1]  all the matching y coordinates.

Here is an <B>example</B> of use. For simplicity, we consider a radial field, centred on the origin, and directed outwards.

\t<# magenta>// Set the points grid:
\t<# blue>Xmin = -1;  Xmax = 1;  Xintvls = 20;   Xinc = (Xmax - Xmin)/Xintvls;
\t<# blue>Ymin = -1;  Ymax = 1;  Yintvls = 20;   Yinc = (Ymax - Ymin)/Yintvls;
\t<# blue>ptgrid = data(Xmin, Xmax, Xintvls, Ymin, Ymax, Yintvls);
\t<# magenta>// Compute the angles:
\t<# blue>dim(Angles, Yintvls+1, Xintvls+1);
\t<# blue>for (ycnt = 0; ycnt < Yintvls+1; ycnt++)
\t<# blue>{	y = Ymin + ycnt*Yinc;
\t	<# blue>for (xcnt = 0; xcnt < Xintvls+1; xcnt++)
\t	<# blue>{	x = Xmin + xcnt*Xinc;
\t		<# blue>if (x == 0) { x = 0.0001; } <# magenta>// don't allow division by 0 in next step.
\t		<# blue>ang = arctan(y/x); <# magenta>// but this only gives angles in the range -PI to +PI...
\t		<# blue>if (x < 0) { ang += PI; } <# magenta>// ...so add on PI for points on left side of Y axis.
\t		<# blue>Angles[ycnt][xcnt] = ang;
\t	<# blue>}
\t<# blue>}
\t<# magenta>// Set arrow length to a bit less than the diagonal of one graph square:
\t<# blue>arrowlength = 0.8 * Xinc; 
\t<# magenta>// Develop the matrix which holds coords. of arrow starts and ends:
\t<# blue>mx = vecdirns(ptgrid, Angles, arrowlength);
\t<# magenta>// Plot vectors:
\t<# blue>grid(Xmin, Xmax, Xintvls, Ymin, Ymax, Yintvls);
\t<# blue>p = plot(mx[][1], mx[][0] ,  '.', data(0,5), 'red',   '_ ', 1, 'blue', data(0,1),  data(0,1) ); // arrows have blue shafts, red heads.
\t<# blue>g = graph(p);
\t<# blue>graphresize(g, 500,500); <# magenta>// make a square graph, so the field looks symmetrical.
============================================================
//WINDOW//
//WINDOW_FIND//
<b>OPERATIONS ON THE ASSIGNMENTS AND RESULTS WINDOWS DURING A PROGRAM RUN</b>

(Be particularly careful about overwriting the text of a program currently running. It will not affect the actual program run, but means that what you see is not what is happening; and also if you operate menu item 'File | Save' you will overwrite your program with whatever else you put in the Assignments Window.)

<b>window</b>(<# blue>array WhichWindow, array Action [, array TheText, array / scalar Where [, bool Formatted OR scalar NoCharsToDelete ]]<# black>) -- operations on the Assignments Window and the Results Window during a program run.

<i>WhichWindow:</i>  The first letter must be one of: 'A', 'a' (Assignments Window),  'R', 'r' (Results Window).

<i>Action:</i>  The first letter must be one of: 'C', 'c' (clear of all text),  'F', 'f' (focus the window),  'R', 'r' (read all text),  'W', 'w' (write the supplied text into the window), 'M', 'm' (adjust markup tag status), 'D', 'd' (delete text). 

For Action 'C', 'F' and 'R', only the first two arguments are required or accessed. With 'clear' and 'focus', the funtion is VOID; with 'read', NONVOID, returning the text from the window. (If the window is empty, 'read' returns an array consisting of a single space.)

For Action 'M', the third argument 'TheText' must be present, and will be "+" (to turn markup tags usage on), '-' (to turn it off), '?' (to leave it alone - done where you just want to know the current status). For all three, the function is NONVOID, returning "+" or "-" to indicate status after the action. NB - can only be used with WhichWindow = 'A'. 

For Action 'W', 'TheText' is what is to be written to the window.
'Where' must be one of: "<# blue>fill<# black>" = replace any current text with this text; "<# blue>cursor<# black>" = insert text at current cursor position; "<# blue>start<# black>" = insert text at the start of existing text;  "<# blue>append<# black>" = append text to the end of existing text;  <# blue>numerals<# black> (e.g. the scalar 36, or its string form "36") = start inserting at the specific character position in the existing text. Any other value aborts the method. 
'Formatted:'  If present and TRUE, then formatting tags are handled (enter 'format' into the Assignments Window and key F1, for tag descriptions).
The function is VOID.

For Action 'D', all 5 arguments must be present, though 'TheText' is ignored (and so may be scalar). 'Where' must be an integer (either scalar, or as the string form of the integer). The final argument tells how many characters to delete, and must be at least 1. The function is VOID.

<i>Errors</i>  in arguments don't crash the program; simply nothing happens, AND scalar 0 is returned - important to know, if you were expecting an array back.


<b>window_find(</b>(<# blue>variable SoughtText<# black>) -- invokes the Search dialog box (exactly as with main menu item "Search | Find"). The position of the cursor is relevant. Works only for the Assignments Window. If 'SoughtText' is scalar, or if its first value is not a valid unicode \> 0, the dialog box opens with the 'search for:' text box empty. Otherwise SoughtText goes there as the default text.

<b>window_find(</b>(<# blue>char array SoughtText, bool MatchCase, bool WholeWord, bool FromCursorDown, bool MarkAll<# black>) -- carries out a search on Assignments Window text as above, but bypasses the dialog box. (However if any arguments are missing, or if 'SoughtText' is anything but valid text, the Search dialog box is invoked and all the other arguments are ignored.) MatchCase and WholeWord are obvious. If FromCursorDown is false, search starts from the cursor; otherwise from the start of window text. If MarkAll is true, all values are marked with background colouring (removed by keying 'ESC'). Otherwise the next find only is marked (with cursor placed there).

============================================================
//WRITE//
//WRITELN//
//SHOW//
//TEXT//
<B>TEXT-HANDLING FUNCTIONS</B>

There are several functions which all take the same arguments: 

<bullet>msg = <B>text(..)</B> -- loads an array ('msg', in the example) with text, and sets it to a 'characters' array.
<bullet><B>write(..)</B> -- displays text in the Results Window.
<bullet><B>writeln(..)</B> -- the same, but a line feed is supplied at the end.
<bullet><B>show(..)</B> -- displays the data in a message box, in which the 'OK' button must be clicked before program flow continues. (use function <b>setbox</b> if you want other than the default size of the message box.)

<B>Arguments:</B>
Any number of them (but at least one). Examples:
    <# blue>write(65);  <# magenta>//  -->  "A"   literal nos. interpreted as unicode chars.
    <# blue>write(65,10,66)  <# magenta> //  -->   "A"   on one line, "B" on the next.
		<# black><B>NOTE use of unicode '10' to insert a linefeed,</B> as an alternative to the more conventional method: <# blue>write(65, "\\n", 66) ).
    <# blue>write("X = ", x)   -->   "X = 23.4"  <# magenta> //  enter char. strings directly
    <# blue>Arr = data(65,66,67);     write(Arr)  <# magenta> //  -->   "65, 66, 67"
    <# blue>write(data("ABC"))   -->   "65, 66, 67"  <# magenta> //  'data' produces an array, so is treated as for the previous example. If you want to display a character string, don't use 'data(..)'.

<# black>You can force all values to be taken as unicode characters by using the function  <B>unicode(.), which takes any number of scalar or array arguments:  </B>:
    <# blue>aa = data(65,66,67);    writeln(unicode(aa));

<B><# black>To display a matrix</B> or higher structure by rows, use 'neat(..)':
    <# blue>write(neat(Mx))<# black>. 

<u>Further points re <b>show</b></u>
You can dictate the size of the dialog box by first calling function 'setbox', which see.

You can use <b>formatting tags</b> to make your text look prettier. For information on these, enter 'format' into the Assignments Window and key F1.

Note that <b>show()</b> always returns a chars. array. Normally it consists of a single space character. But if any text is highlighted in the dialog box at the time of its closure, then the highlighted text is returned.

This goes hand in hand with another capacity of <b>show()</b>: it can be made editable. To do this, make sure that the first 10 characters in the argument are exactly: "[EDITABLE]". E.g. <# blue>show("[EDITABLE]Edit me!")<# black> will display "Edit me!", and you will find you can change the text. These two extra capabilities of <b>show</b> mean that you can prompt the user to enter some text, direct him to select the text, and so retrieve that text for processing.

You can use the <b>concatenation operator '#'</b> in place of "text(.)", realizing that some of the above does not apply. For example, if you have a variable 'n' with the value 10, then <# blue>ss = text("The value is ", n)<# black> will result in the string "The value is 10". To get the same effect with the concatenation operator you would have to convert n to its string representation: <# blue>ss = "The value is " # str(n)<# black>. Also keep in mind that the output of a concatenator operation takes the chars. rating of the first array in the operation.

See also <B>nth(x)</B> which converts a scalar (after rounding) to a chars. array with the appropriate suffix - e.g. 'nth(21)' --> "21st.".
============================================================
//XOR -- see AND
//XORCOMP -- see AND
============================================================
//XMENU//
//XVISIBLE//
//XCLICK//
<B>CREATING AND USING NEW MENU ITEMS AT RUNTIME</B>

There is a hidden main main menu item which the user can invoke, equipping it with 1 to 20 submenus. This extra menu system is invoked with void function...

<b>xmenu( Title, Subtitles )</b>, where 'Title' is the title of the added main menu item, and 'Subtitles' is the accumulated titles of its successive submenus, delimited by '|'. E.g. <# blue>xmenu( "Change Colour", "Red | Green | Sky Blue" )<# black> will produce a menu named 'Change Colour' with three submenus. Note that spaces at the start and end of titles are ignored, but internal spaces (as in "Sky Blue") are preserved. To change even one title or subtitle, or the number of submenus, you have to call "xmenu(.)" again with all arguments, as if calling it for the first time. Empty titles and subtitles should be avoided. 

All submenus are automatically visible after the above. To alter visibility, use...

<b>xvisible(Visibility)</b>, where 'Visibility' is an array of 'true' (for 'make visible') and 'false' ('make invisible'). (It can also be a set of scalars, or a mix of both.) Visibility[0] applies to the main menu item, and Visibility[1+] to the submenus. If there are less argument values than menu items, only those addressed will have visibility affected. If there are more argument values, the excess will be ignored.
The function <b>xvisible(.)</b> is not void, but always returns the final visibility state of all items as an array. So if you don't want to change the visibility of the second submenu but just want to read its visibility, use <# blue>arr = xvisible(1);<# black> - which makes the main menu item visible (if it wasn't already) - and then test arr[2].

To read clicks, use...

<b>xclick()</b>. This returns the index of the submenu clicked, and then immediately resets the internal flag raised by that click so that a second call to 'xclick()' would return -1 instead. If no click has occurrred in the lifetime of the program, this function returns -1. Note that submenus are <i>numbered from 1 upwards</i>, as they are for function 'xvisible(.)'. Note also that this function does not detect a click on the main menu item itself. 
============================================================
//FORMAT//
(If you were looking for how to <b>format numbers</b> in string form, you are in the wrong place. Enter 'str' and press the F1 key for that.)

<B>FORMATTING TEXT FOR DISPLAY</B>
<stops 20, 200, 220>
<left 20><in -20>The following applies for system functions <B>write(.), writeln(.), show(.)</B>. At the end there is a further formatting instruction which applies only to <B>show(.)</B>, which allows you to specify the size of the displayed message box.

Tags are used more or less in the same way as in HTML; but there are far fewer tags available, and some are quite different. One <I>major difference</I> between the system here and HTML is that with HTML runs of spaces in the text are treated as if they were a single space; with our system, all spaces are faithfully reproduced.

Tag contents are NOT case-sensitive.

PAIRED TAGS THAT DO NOT ALTER TEXT: (Unpaired tags are removed from the text, but have no effect, as e.g. in "A<B>B" or "A</B>B".)
	BOLD	\<b\> ... \</b\>
	ITALIC	\<i\> ... \</i\>
	UNDERLINE	\<u\> ... \</u\>
	DOUBLE UNDERLINE	\<uu\> ... \</uu\>
	STRIKETHROUGH	\<x\> ... \</x\>

TAB STOPS: "\<stops 50, 100, 200, 220\>". (Further tabs replicate the distance between the last two tab stops.)
    Tab stops apply till (a) a new setting of stops; or (b) the closer tag "\</stops\>"; or (c) to the end of text.

PARAGRAPH JUSTIFICATION: "\<just yak\>" where only the first letter of 'yak' (case-insensitive) is checked, and must be one of:
    'l'(eft - the default, so only useful to negate another justification), 'c'(entre), 'r'(ight), 'f'(ill - both margins
    flush).
The setting stays in force till the first of: (a) another setting of the same type; or (b) the cancelling tag "\</just\>"; or (c) the end of text.
The closing tag, if present, should be the last entry in the last paragraph to which it applies, or else the very first entry in the next paragraph.

PARAGRAPH INDENTING: the indenting of the FIRST LINE of the paragraph relative to the margin set for the paragraph; can be negative (for hanging paragraphs).
	"\<in 30\>" (for 30 pixels); or just "\<in\>" for the default indent of 20 pixels.
The setting stays in force till the first of: (a) another setting of the same type; or (b) the cancelling tag "\</in\>"; or (c) the end of text.
The closing tag, if present, should be the last entry in the last paragraph to which it applies, or else the very first entry in the next paragraph.
Note that the setting is <i>relative to the previous paragraph's indenting</i>; hence negative indents are allowed, after earlier positive indents: "\<in -30\>".

PARAGRAPH MARGIN SETTING:
  LEFT MARGIN: "\<left 30\>" (for 30 pixels).  Cancelled by a new left margin setting, or else applies to end of text. There is no closer tag.
  RIGHT MARGIN: "\<right 30\>".   Cancelled by a new right margin setting, or else applies to end of text. There is no closer tag.
Note that left and right margins are distinguished by the sign of the value; they are absolute pixel values relative to the TextView's margin, not to the prior tag's margin.
      As with Indenting, you can use either without an argument: "\<left\>", "\<right\>"; the default is the same: 20 pixels.

HANGING PARAGRAPH:
Uses the above. E.g. to indent lines after the first by 20 pixels, start the first such paragraph with: "\<left 20\>\<in -20\>".

BULLET PARAGRAPH:
At the very beginning of each paragraph to be indented with a bullet, use "\<bullet\>". Unlike the above tags, the formatting does not carry over to the next paragraph, so there is no need of a cancelling tag.
Inner deeper levels of bulletting are possible, using a suffix, which is the indent (in pixels) of the left edge of all text in the bulletted paragraph. The default is 30, so you might like to try  "\<bullet 50\>" for the second level of bulletting. Again, there is no carry over of this value to the next paragraph.
You can even change the bullet symbol. To do this you must start with the indent, even for the default case (indent = 30); you then add a comma, and immediately after it the character (or character string) which you want as your new bullet. E.g. for the standard bulletted item, to change the bullet to '#', do: "\<bullet 30,#\>" (no quote marks).
If you don't want a bullet at all (e.g. for the 2nd. paragraph of a 2-paragraph bullet item), do  "\<bullet 30,\>".
Here are some possible bullets:  •‧⁕⁜⇨→∎∙⊕▻◾☛☞⚪⚫➯⭑⭐‣
You want numbered bullets? Then you use a sequence like "\<bullet 30,1.>", "\<bullet 30,2.>", ...   (You have to set the numbers yourself - they are not automatically assigned.)

COLOURS:
You can colour either: (1) the text itself - "\<# yak\>" (where 'yak' stands for the colour descriptor); or (2) the background behind the text - "\<~ yak\>". In both cases, note that there is a space before the colour descriptor. The colour change is cancelled either by another tag of the same type or by the appropriate cancelling tag ("\</#\>" or "\</~\>").
The colour descriptor can be one of the following:
<bullet>A colour name: "\<# blue\>". (The names are as recognized by .NET; there are 146 such names. Sorry, they are not listed here, so just try your luck. They are not case-sensitive, but no spaces are allowed inside the name. E.g. "\<# LightBlue\>", but not  "\<# Light Blue\>").
<bullet>The RGB code of a colour, as three numbers (in that order): "\<# 255,0,128\>".
<bullet>The RGB code of a colour, as a six digit hex number (2 digits for each colour, in that order): "\<# FF0080\>".
There are other ways of doing it, but you would have to check program code for details.

FONT CHANGES:
  FONT: "\<font Courier_New, 12\>". Cancelled either by a new font-changing tag or by the cancelling tag "\</font\>". Use underlines where there are spaces in the font name (as spaces are parsed out); OR put the name(s) spaces into double quotes: '\<font "Courier New", 12\>'.
There must be a size, and the size must be separated from the font name by a comma.
You can list several fonts, in order of preference, if not sure what will be available on the computer running the program: "\<font myfont1, myfont2, myfont3, 10\>".
You can also specify a level value (in pts.), the height or depth (neg. value) of the char. above the base line. Do this by appending it to the font size, after another comma: "\<font myfont1, myfont2, 6, -3\>".
If you just want to change the font size, replace the font name with the key word 'same': "\<font same, 5\>".
If you want to keep the same size but change the font, you can use '?': "\<font Courier_New, ?\>"
NB! ***  Within a segment of altered font, BOLD and ITALICS will not work. This is a Gtk problem; I have not yet found a workaround for it.

SUPERSCRIPT: Turned on by "\<^\>",  cancelled either by "\</^\>" or by a subscript tag (or by its cancelling tag).
SUBSCRIPT: Turned on by "\<v\>",  cancelled either by "\</v\>" or by a superscript tag (or by its cancelling tag).
As with font changes, BOLD and ITALICS will not work in a super/subscripted segment.

SPECIAL CHARACTERS:
<bullet><i>Reserved characters</i> -- i.e. those used as part of formatting instructions.
<left 50>*    '\<' and '\>' used to be a problem, where they were not part of a tag; but I think that problem is sorted now. However you are still free to use "\\\<" instead of "\<", and "\\\>" instead of "\>".
*    To display a literal backslash '\\', enter it doubled: "\\\\\".
<bullet><left -50><i>Linefeed, Tab</i> -- "\\n", "\\t". (Note that the letter must be lower case.)
<bullet><i>Greek Letters</i> --  "\<| x\>", where 'x' is any of the following Latin letters. (NB - note the space between '|' and 'x'.)
	Latin  letter:	a b g d e z @ 0 i k l m n x o p r  s c t u f  h y  w   A B G D E Z # 9  I K L M N X O P R S T U F H Y W
	Greek letter:	α β γ δ ε ζ  η θ ι κ λ μ  ν ξ ο π ρ σ ς τ υ φ χ ψ ω  Α Β Γ Δ Ε Ζ Η Θ Ι Κ Λ Μ Ν Ξ Ο Π Ρ Σ Τ Υ Φ Χ Ψ Ω
<bullet><i>Maths Symbols</i> --  "\<* x\>, where 'x' is any of the following characters. (NB - note the space between '|' and 'x'.)
	Code character:	 i	j	S	/	+	o	x	(	)	{	}	-	|	R	F	d	D	8	A	~	#	=	\<	\>
	Maths   symbol:	∫	∮	∑	√	±	°	×	‹	›	≪	≫	‒	‖	ℛ	ℱ	∂	∇	∞	∡	≈	≠	≡	≤	≥
<bullet><i>Unicode Character Codes</i> -- "\<& ...\>". E.g. for the letter 'A' - which has unicode 65 (decimal) or 41 (hexadecimal), you could write "\<& 65\>" or "\<& 0x41\>". (Note the space after '&'. Also, for hex numbers, the prefix '0x' uses the cipher '0', not the letter 'o'.)

format
<b>PANGO FORMATTING TAGS</b>
Labels in programs (like MonoMaths) written in the language C# using Gtk#, cannot use tags of the above sort; however they can use tags defined by the Pango element of Gtk. Here are some examples of what is allowable. There is no guarantee that they will all work; trial and error is the rule. But they are all described on the Net (search "Pango Markup Language" as a phrase).
Pango tags must always be paired, or the text gets mangled or disappears altogether. (Pango takes no prisoners.)

Bold: 	\<b>yak\</b>
Italic: 	\<i>yak\</i>
Underline: 	\<u>yak\</u>
Strikethrough:	\<s>yak\</s>
Monospace font: 	\<tt>yak\</tt>
Subscript: 	x\<sub>1\</sub> + x\<sub>2\</sub>
Superscript: 	E = mc\<sup>2\</sup>
Make font larger: 	\<big>yak\</big>
Make font smaller: 	\<small>yak\</small>
 
\<Span> Attributes

Font changes: uses the keyword 'font_desc':
        \<span font_desc="Verdana">yak\</span>
        \<span font_desc="24">yak\</span>
        \<span font_desc="Verdana 24">yak\</span>

Other keywords to use similarly, all with the 'span' tags:
    Style: 'normal', 'oblique' or 'italic'
    Weight: 'ultralight', 'light', 'normal', 'bold', 'ultrabold', 'heavy', or a numeric weight
    Underline: 'none', 'single', 'double', 'low' or 'error'
    Text colour: 'foreground', the argument being  "#RRGGBB" (RR etc. stands for a 2-digit hex RGB colour value). 
		e.g. for blue text:  <# blue>\<span foreground="#0000FF">yak\</span><# black>
    Background colour: 'background', the argument being as above.
	Underline colour: 'underline_color', the argument being as above.     
	Variant:	 either 'normal' or 'smallcaps'.
	Stretch: 	The font width - one of 'ultracondensed', 'extracondensed', 'condensed', 'semicondensed', 'normal', 'semiexpanded', 'expanded', 'extraexpanded', 'ultraexpanded'.

<b>Forcing a line break:</b> Inserting '\\n' into the text just does not work. You have to insert the value '10' - e.g. in the status bar label: <# blue>label('C', "This is line 1", 10, " and this is line 2.");
===================================================================




